let wasm;

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

let cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };

const MAX_SAFARI_DECODE_BYTES = 2146435072;
let numBytesDecoded = 0;
function decodeText(ptr, len) {
    numBytesDecoded += len;
    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
        cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );
        cachedTextDecoder.decode();
        numBytesDecoded = len;
    }
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return decodeText(ptr, len);
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(
state => {
    wasm.__wbindgen_export_6.get(state.dtor)(state.a, state.b);
}
);

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {

        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_6.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
/**
 * @returns {Promise<void>}
 */
export function start() {
    wasm.start();
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    for (let i = 0; i < array.length; i++) {
        const add = addToExternrefTable0(array[i]);
        getDataViewMemory0().setUint32(ptr + 4 * i, add, true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_2.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i = ptr; i < ptr + 4 * len; i += 4) {
        result.push(wasm.__wbindgen_export_2.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
 * Test helper: Convert a JsValue to a JSON-compatible JsValue.
 *
 * This function is exposed for testing purposes to validate the Map normalization
 * and BigInt handling logic in unit tests. It calls `js_value_to_json` internally
 * and converts the result back to a JsValue.
 *
 * # Example (JavaScript)
 * ```javascript
 * const map = new Map([['key', 'value']]);
 * const json = testJsValueToJson(map);
 * console.log(json); // { key: 'value' }
 * ```
 * @param {any} value
 * @returns {any}
 */
export function testJsValueToJson(value) {
    const ret = wasm.testJsValueToJson(value);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

let cachedUint32ArrayMemory0 = null;

function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
}

function getArrayU32FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}

function passArray32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4, 4) >>> 0;
    getUint32ArrayMemory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
function __wbg_adapter_6(arg0, arg1, arg2) {
    wasm.closure5628_externref_shim(arg0, arg1, arg2);
}

function __wbg_adapter_9(arg0, arg1) {
    wasm.wasm_bindgen__convert__closures_____invoke__ha4f9c44e82234eeb(arg0, arg1);
}

function __wbg_adapter_16(arg0, arg1) {
    wasm.wasm_bindgen__convert__closures_____invoke__ha0ee3ea747dfe47c(arg0, arg1);
}

function __wbg_adapter_27(arg0, arg1) {
    wasm.wasm_bindgen__convert__closures_____invoke__h9024c8d53c81da33(arg0, arg1);
}

function __wbg_adapter_2496(arg0, arg1, arg2, arg3) {
    wasm.closure9857_externref_shim(arg0, arg1, arg2, arg3);
}

/**
 * @enum {0 | 1}
 */
export const ActionGoal = Object.freeze({
    ActionCompletion: 0, "0": "ActionCompletion",
    ActionParticipation: 1, "1": "ActionParticipation",
});
/**
 * @enum {0 | 1}
 */
export const AssetLockProofType = Object.freeze({
    Instant: 0, "0": "Instant",
    Chain: 1, "1": "Chain",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
export const BatchType = Object.freeze({
    Create: 0, "0": "Create",
    Replace: 1, "1": "Replace",
    Delete: 2, "2": "Delete",
    Transfer: 3, "3": "Transfer",
    Purchase: 4, "4": "Purchase",
    UpdatePrice: 5, "5": "UpdatePrice",
    IgnoreWhileBumpingRevision: 6, "6": "IgnoreWhileBumpingRevision",
});
/**
 * @enum {0 | 1 | 2}
 */
export const GasFeesPaidBy = Object.freeze({
    DocumentOwner: 0, "0": "DocumentOwner",
    ContractOwner: 1, "1": "ContractOwner",
    PreferContractOwner: 2, "2": "PreferContractOwner",
});
/**
 * TypeScript enum for GroupActionEvent variants
 * @enum {0}
 */
export const GroupActionEventVariant = Object.freeze({
    TokenEvent: 0, "0": "TokenEvent",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const KeyType = Object.freeze({
    ECDSA_SECP256K1: 0, "0": "ECDSA_SECP256K1",
    BLS12_381: 1, "1": "BLS12_381",
    ECDSA_HASH160: 2, "2": "ECDSA_HASH160",
    BIP13_SCRIPT_HASH: 3, "3": "BIP13_SCRIPT_HASH",
    EDDSA_25519_HASH160: 4, "4": "EDDSA_25519_HASH160",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
export const Network = Object.freeze({
    Mainnet: 0, "0": "Mainnet",
    Testnet: 1, "1": "Testnet",
    Devnet: 2, "2": "Devnet",
    Regtest: 3, "3": "Regtest",
});
/**
 * @enum {1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}
 */
export const PlatformVersion = Object.freeze({
    PLATFORM_V1: 1, "1": "PLATFORM_V1",
    PLATFORM_V2: 2, "2": "PLATFORM_V2",
    PLATFORM_V3: 3, "3": "PLATFORM_V3",
    PLATFORM_V4: 4, "4": "PLATFORM_V4",
    PLATFORM_V5: 5, "5": "PLATFORM_V5",
    PLATFORM_V6: 6, "6": "PLATFORM_V6",
    PLATFORM_V7: 7, "7": "PLATFORM_V7",
    PLATFORM_V8: 8, "8": "PLATFORM_V8",
    PLATFORM_V9: 9, "9": "PLATFORM_V9",
    PLATFORM_V10: 10, "10": "PLATFORM_V10",
});
/**
 * @enum {0 | 1 | 2}
 */
export const PoolingWasm = Object.freeze({
    Never: 0, "0": "Never",
    IfAvailable: 1, "1": "IfAvailable",
    Standard: 2, "2": "Standard",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
export const Purpose = Object.freeze({
    AUTHENTICATION: 0, "0": "AUTHENTICATION",
    ENCRYPTION: 1, "1": "ENCRYPTION",
    DECRYPTION: 2, "2": "DECRYPTION",
    TRANSFER: 3, "3": "TRANSFER",
    SYSTEM: 4, "4": "SYSTEM",
    VOTING: 5, "5": "VOTING",
    OWNER: 6, "6": "OWNER",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
export const SecurityLevel = Object.freeze({
    MASTER: 0, "0": "MASTER",
    CRITICAL: 1, "1": "CRITICAL",
    HIGH: 2, "2": "HIGH",
    MEDIUM: 3, "3": "MEDIUM",
});
/**
 * @enum {0 | 1}
 */
export const TokenDistributionType = Object.freeze({
    PreProgrammed: 0, "0": "PreProgrammed",
    Perpetual: 1, "1": "Perpetual",
});
/**
 * @enum {0 | 1}
 */
export const TokenEmergencyAction = Object.freeze({
    Pause: 0, "0": "Pause",
    Resume: 1, "1": "Resume",
});
/**
 * TypeScript enum for TokenEvent variants
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}
 */
export const TokenEventVariant = Object.freeze({
    Mint: 0, "0": "Mint",
    Burn: 1, "1": "Burn",
    Freeze: 2, "2": "Freeze",
    Unfreeze: 3, "3": "Unfreeze",
    DestroyFrozenFunds: 4, "4": "DestroyFrozenFunds",
    Transfer: 5, "5": "Transfer",
    Claim: 6, "6": "Claim",
    EmergencyAction: 7, "7": "EmergencyAction",
    ConfigUpdate: 8, "8": "ConfigUpdate",
    ChangePriceForDirectPurchase: 9, "9": "ChangePriceForDirectPurchase",
    DirectPurchase: 10, "10": "DirectPurchase",
});
/**
 * @enum {0 | 1 | 2}
 */
export const VoteStateResultType = Object.freeze({
    Documents: 0, "0": "Documents",
    VoteTally: 1, "1": "VoteTally",
    DocumentsAndVoteTally: 2, "2": "DocumentsAndVoteTally",
});
/**
 * Structured error returned by wasm-dpp2 APIs.
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const WasmDppErrorKind = Object.freeze({
    /**
     * Error raised by Dash Platform Protocol.
     */
    Protocol: 0, "0": "Protocol",
    /**
     * Invalid argument provided by the caller.
     */
    InvalidArgument: 1, "1": "InvalidArgument",
    /**
     * Serialization or deserialization failure.
     */
    Serialization: 2, "2": "Serialization",
    /**
     * Type conversion failure.
     */
    Conversion: 3, "3": "Conversion",
    /**
     * Catch-all for other failure modes.
     */
    Generic: 4, "4": "Generic",
});
/**
 * Structured error surfaced to JS consumers
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24}
 */
export const WasmSdkErrorKind = Object.freeze({
    Config: 0, "0": "Config",
    Drive: 1, "1": "Drive",
    DriveProofError: 2, "2": "DriveProofError",
    Protocol: 3, "3": "Protocol",
    Proof: 4, "4": "Proof",
    InvalidProvedResponse: 5, "5": "InvalidProvedResponse",
    DapiClientError: 6, "6": "DapiClientError",
    DapiMocksError: 7, "7": "DapiMocksError",
    CoreError: 8, "8": "CoreError",
    MerkleBlockError: 9, "9": "MerkleBlockError",
    CoreClientError: 10, "10": "CoreClientError",
    MissingDependency: 11, "11": "MissingDependency",
    TotalCreditsNotFound: 12, "12": "TotalCreditsNotFound",
    EpochNotFound: 13, "13": "EpochNotFound",
    TimeoutReached: 14, "14": "TimeoutReached",
    AlreadyExists: 15, "15": "AlreadyExists",
    InvalidCreditTransfer: 16, "16": "InvalidCreditTransfer",
    Generic: 17, "17": "Generic",
    ContextProviderError: 18, "18": "ContextProviderError",
    Cancelled: 19, "19": "Cancelled",
    StaleNode: 20, "20": "StaleNode",
    StateTransitionBroadcastError: 21, "21": "StateTransitionBroadcastError",
    InvalidArgument: 22, "22": "InvalidArgument",
    SerializationError: 23, "23": "SerializationError",
    NotFound: 24, "24": "NotFound",
});

const __wbindgen_enum_ReadableStreamType = ["bytes"];

const __wbindgen_enum_ReferrerPolicy = ["", "no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "unsafe-url", "same-origin", "strict-origin", "strict-origin-when-cross-origin"];

const __wbindgen_enum_RequestCache = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"];

const __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];

const __wbindgen_enum_RequestMode = ["same-origin", "no-cors", "cors", "navigate"];

const __wbindgen_enum_RequestRedirect = ["follow", "error", "manual"];

const ActionTakerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_actiontaker_free(ptr >>> 0, 1));

export class ActionTaker {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ActionTakerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_actiontaker_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.actiontaker_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} value
     */
    constructor(value) {
        const ret = wasm.actiontaker_new(value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        ActionTakerFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    getType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.actiontaker_getType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    get value() {
        const ret = wasm.actiontaker_get_value(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} value
     */
    set value(value) {
        const ret = wasm.actiontaker_set_value(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.actiontaker_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const AssetLockProofFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_assetlockproof_free(ptr >>> 0, 1));

export class AssetLockProof {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AssetLockProof.prototype);
        obj.__wbg_ptr = ptr;
        AssetLockProofFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AssetLockProofFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assetlockproof_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {AssetLockProof}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetlockproof_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @param {any} js_value
     * @returns {AssetLockProof}
     */
    static fromObject(js_value) {
        const ret = wasm.assetlockproof_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetlockproof_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    getLockType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetlockproof_getLockType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {OutPoint | undefined}
     */
    getOutPoint() {
        const ret = wasm.assetlockproof_getOutPoint(this.__wbg_ptr);
        return ret === 0 ? undefined : OutPoint.__wrap(ret);
    }
    /**
     * @returns {ChainAssetLockProof}
     */
    getChainLockProof() {
        const ret = wasm.assetlockproof_getChainLockProof(this.__wbg_ptr);
        return ChainAssetLockProof.__wrap(ret);
    }
    /**
     * @returns {InstantAssetLockProof}
     */
    getInstantLockProof() {
        const ret = wasm.assetlockproof_getInstantLockProof(this.__wbg_ptr);
        return InstantAssetLockProof.__wrap(ret);
    }
    /**
     * @returns {Identifier}
     */
    createIdentityId() {
        const ret = wasm.assetlockproof_createIdentityId(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @param {number} core_chain_locked_height
     * @param {OutPoint} out_point
     * @returns {AssetLockProof}
     */
    static createChainAssetLockProof(core_chain_locked_height, out_point) {
        _assertClass(out_point, OutPoint);
        const ret = wasm.assetlockproof_createChainAssetLockProof(core_chain_locked_height, out_point.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} instant_lock
     * @param {Uint8Array} transaction
     * @param {number} output_index
     * @returns {AssetLockProof}
     */
    static createInstantAssetLockProof(instant_lock, transaction, output_index) {
        const ptr0 = passArray8ToWasm0(instant_lock, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(transaction, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.assetlockproof_createInstantAssetLockProof(ptr0, len0, ptr1, len1, output_index);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @param {any} js_asset_lock_proof
     */
    constructor(js_asset_lock_proof) {
        const ret = wasm.assetlockproof_new(js_asset_lock_proof);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        AssetLockProofFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.assetlockproof_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.assetlockproof_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} asset_lock_proof
     * @returns {AssetLockProof}
     */
    static fromHex(asset_lock_proof) {
        const ptr0 = passStringToWasm0(asset_lock_proof, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetlockproof_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.assetlockproof_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js_value
     * @returns {AssetLockProof}
     */
    static fromJSON(js_value) {
        const ret = wasm.assetlockproof_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.assetlockproof_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetlockproof_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const AuthorizedActionTakersFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_authorizedactiontakers_free(ptr >>> 0, 1));

export class AuthorizedActionTakers {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AuthorizedActionTakers.prototype);
        obj.__wbg_ptr = ptr;
        AuthorizedActionTakersFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AuthorizedActionTakersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_authorizedactiontakers_free(ptr, 0);
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    static MainGroup() {
        const ret = wasm.authorizedactiontakers_MainGroup();
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getTakerType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.authorizedactiontakers_getTakerType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.authorizedactiontakers_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    static ContractOwner() {
        const ret = wasm.authorizedactiontakers_ContractOwner();
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @param {number} group_contract_position
     * @returns {AuthorizedActionTakers}
     */
    static Group(group_contract_position) {
        const ret = wasm.authorizedactiontakers_Group(group_contract_position);
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    static NoOne() {
        const ret = wasm.authorizedactiontakers_NoOne();
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @returns {AuthorizedActionTakers}
     */
    static Identity(js_identity_id) {
        const ret = wasm.authorizedactiontakers_Identity(js_identity_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuthorizedActionTakers.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    getValue() {
        const ret = wasm.authorizedactiontakers_getValue(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.authorizedactiontakers_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const BatchTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_batchtransition_free(ptr >>> 0, 1));

export class BatchTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BatchTransition.prototype);
        obj.__wbg_ptr = ptr;
        BatchTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BatchTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_batchtransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {BatchTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.batchtransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {BatchTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.batchtransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} js_value
     * @returns {BatchTransition}
     */
    static fromObject(js_value) {
        const ret = wasm.batchtransition_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.batchtransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get ownerId() {
        const ret = wasm.batchtransition_get_owner_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.batchtransition_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} js_signature
     */
    set signature(js_signature) {
        const ptr0 = passArray8ToWasm0(js_signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.batchtransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Array<any>} js_batched_transitions
     */
    set transitions(js_batched_transitions) {
        const ret = wasm.batchtransition_set_transitions(this.__wbg_ptr, js_batched_transitions);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.batchtransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} state_transition
     * @returns {BatchTransition}
     */
    static fromStateTransition(state_transition) {
        _assertClass(state_transition, StateTransition);
        const ret = wasm.batchtransition_fromStateTransition(state_transition.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier[]}
     */
    get modifiedDataIds() {
        const ret = wasm.batchtransition_get_modified_data_ids(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {BatchedTransition[]}
     */
    get transitions() {
        const ret = wasm.batchtransition_get_batched_transitions(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Array<any>} js_batched_transitions
     * @param {Identifier | Uint8Array | string} owner_id
     * @param {number} user_fee_increase
     * @returns {BatchTransition}
     */
    static fromBatchedTransitions(js_batched_transitions, owner_id, user_fee_increase) {
        const ret = wasm.batchtransition_fromBatchedTransitions(js_batched_transitions, owner_id, user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get allPurchasesAmount() {
        const ret = wasm.batchtransition_get_all_purchases_amount(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {number}
     */
    get signaturePublicKeyId() {
        const ret = wasm.batchtransition_get_signature_public_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {bigint} nonce
     */
    setIdentityContractNonce(nonce) {
        wasm.batchtransition_setIdentityContractNonce(this.__wbg_ptr, nonce);
    }
    /**
     * @param {number} key_id
     */
    set signaturePublicKeyId(key_id) {
        wasm.batchtransition_set_signature_public_key_id(this.__wbg_ptr, key_id);
    }
    /**
     * @returns {bigint | undefined}
     */
    get allConflictingIndexCollateralVotingFunds() {
        const ret = wasm.batchtransition_get_all_conflicting_index_collateral_voting_funds(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.batchtransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.batchtransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {BatchTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.batchtransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.batchtransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js_value
     * @returns {BatchTransition}
     */
    static fromJSON(js_value) {
        const ret = wasm.batchtransition_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BatchTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.batchtransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.batchtransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.batchtransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const BatchedTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_batchedtransition_free(ptr >>> 0, 1));

export class BatchedTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BatchedTransition.prototype);
        obj.__wbg_ptr = ptr;
        BatchedTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BatchedTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_batchedtransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.batchedtransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toTransition() {
        const ret = wasm.batchedtransition_toTransition(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Identifier}
     */
    get dataContractId() {
        const ret = wasm.batchedtransition_data_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     */
    set dataContractId(js_contract_id) {
        const ret = wasm.batchedtransition_set_data_contract_id(this.__wbg_ptr, js_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_transition
     */
    constructor(js_transition) {
        const ret = wasm.batchedtransition_new(js_transition);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        BatchedTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.batchedtransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const BlockBasedDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_blockbaseddistribution_free(ptr >>> 0, 1));

export class BlockBasedDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BlockBasedDistribution.prototype);
        obj.__wbg_ptr = ptr;
        BlockBasedDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BlockBasedDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockbaseddistribution_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get interval() {
        const ret = wasm.__wbg_get_blockbaseddistribution_interval(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set interval(arg0) {
        wasm.__wbg_set_blockbaseddistribution_interval(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.blockbaseddistribution_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DistributionFunction}
     */
    get function() {
        const ret = wasm.blockbaseddistribution_get_function(this.__wbg_ptr);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {DistributionFunction} _function
     */
    set function(_function) {
        _assertClass(_function, DistributionFunction);
        wasm.blockbaseddistribution_set_function(this.__wbg_ptr, _function.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.blockbaseddistribution_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const BlockInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_blockinfo_free(ptr >>> 0, 1));

export class BlockInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BlockInfo.prototype);
        obj.__wbg_ptr = ptr;
        BlockInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BlockInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockinfo_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get coreHeight() {
        const ret = wasm.blockinfo_core_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    get epochIndex() {
        const ret = wasm.blockinfo_epoch_index(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} obj
     * @returns {BlockInfo}
     */
    static fromObject(obj) {
        const ret = wasm.blockinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockInfo.__wrap(ret[0]);
    }
    /**
     * @param {bigint} time_ms
     * @param {bigint} height
     * @param {number} core_height
     * @param {number} epoch_index
     */
    constructor(time_ms, height, core_height, epoch_index) {
        const ret = wasm.blockinfo_new(time_ms, height, core_height, epoch_index);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        BlockInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {bigint}
     */
    get height() {
        const ret = wasm.blockinfo_height(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    get timeMs() {
        const ret = wasm.blockinfo_time_ms(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.blockinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {BlockInfo}
     */
    static fromJSON(js) {
        const ret = wasm.blockinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.blockinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ChainAssetLockProofFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_chainassetlockproof_free(ptr >>> 0, 1));

export class ChainAssetLockProof {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ChainAssetLockProof.prototype);
        obj.__wbg_ptr = ptr;
        ChainAssetLockProofFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ChainAssetLockProofFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_chainassetlockproof_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {ChainAssetLockProof}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.chainassetlockproof_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ChainAssetLockProof.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {ChainAssetLockProof}
     */
    static fromObject(obj) {
        const ret = wasm.chainassetlockproof_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ChainAssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.chainassetlockproof_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {OutPoint}
     */
    get outPoint() {
        const ret = wasm.chainassetlockproof_get_out_point(this.__wbg_ptr);
        return OutPoint.__wrap(ret);
    }
    /**
     * @param {OutPoint} outpoint
     */
    set outPoint(outpoint) {
        _assertClass(outpoint, OutPoint);
        wasm.chainassetlockproof_set_out_point(this.__wbg_ptr, outpoint.__wbg_ptr);
    }
    /**
     * @returns {Identifier}
     */
    createIdentityId() {
        const ret = wasm.chainassetlockproof_createIdentityId(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    get coreChainLockedHeight() {
        const ret = wasm.chainassetlockproof_get_core_chain_locked_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} core_chain_locked_height
     */
    set coreChainLockedHeight(core_chain_locked_height) {
        wasm.chainassetlockproof_set_core_chain_locked_height(this.__wbg_ptr, core_chain_locked_height);
    }
    /**
     * @param {number} core_chain_locked_height
     * @param {OutPoint} out_point
     */
    constructor(core_chain_locked_height, out_point) {
        _assertClass(out_point, OutPoint);
        const ret = wasm.chainassetlockproof_new(core_chain_locked_height, out_point.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        ChainAssetLockProofFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.chainassetlockproof_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.chainassetlockproof_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {ChainAssetLockProof}
     */
    static fromJSON(js) {
        const ret = wasm.chainassetlockproof_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ChainAssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.chainassetlockproof_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.chainassetlockproof_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ChangeControlRulesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_changecontrolrules_free(ptr >>> 0, 1));

export class ChangeControlRules {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ChangeControlRules.prototype);
        obj.__wbg_ptr = ptr;
        ChangeControlRulesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ChangeControlRulesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_changecontrolrules_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.changecontrolrules_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    get adminActionTakers() {
        const ret = wasm.changecontrolrules_get_admin_action_takers(this.__wbg_ptr);
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} admin_action_takers
     */
    set adminActionTakers(admin_action_takers) {
        _assertClass(admin_action_takers, AuthorizedActionTakers);
        wasm.changecontrolrules_set_admin_action_takers(this.__wbg_ptr, admin_action_takers.__wbg_ptr);
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    get authorizedToMakeChange() {
        const ret = wasm.changecontrolrules_get_authorized_to_make_change(this.__wbg_ptr);
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} authorized_to_make_change
     */
    set authorizedToMakeChange(authorized_to_make_change) {
        _assertClass(authorized_to_make_change, AuthorizedActionTakers);
        wasm.changecontrolrules_set_authorized_to_make_change(this.__wbg_ptr, authorized_to_make_change.__wbg_ptr);
    }
    /**
     * @param {AuthorizedActionTakers} admin_action_takers
     * @param {Identifier | Uint8Array | string} js_contract_owner_id
     * @param {number | null | undefined} main_group
     * @param {any} js_groups
     * @param {ActionTaker} action_taker
     * @param {any} js_goal
     * @returns {boolean}
     */
    canChangeAdminActionTakers(admin_action_takers, js_contract_owner_id, main_group, js_groups, action_taker, js_goal) {
        _assertClass(admin_action_takers, AuthorizedActionTakers);
        _assertClass(action_taker, ActionTaker);
        const ret = wasm.changecontrolrules_canChangeAdminActionTakers(this.__wbg_ptr, admin_action_takers.__wbg_ptr, js_contract_owner_id, isLikeNone(main_group) ? 0xFFFFFF : main_group, js_groups, action_taker.__wbg_ptr, js_goal);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * @param {AuthorizedActionTakers} authorized_to_make_change
     * @param {AuthorizedActionTakers} admin_action_takers
     * @param {boolean} changing_authorized_action_takers_to_no_one_allowed
     * @param {boolean} changing_admin_action_takers_to_no_one_allowed
     * @param {boolean} self_changing_admin_action_takers_allowed
     */
    constructor(authorized_to_make_change, admin_action_takers, changing_authorized_action_takers_to_no_one_allowed, changing_admin_action_takers_to_no_one_allowed, self_changing_admin_action_takers_allowed) {
        _assertClass(authorized_to_make_change, AuthorizedActionTakers);
        _assertClass(admin_action_takers, AuthorizedActionTakers);
        const ret = wasm.changecontrolrules_new(authorized_to_make_change.__wbg_ptr, admin_action_takers.__wbg_ptr, changing_authorized_action_takers_to_no_one_allowed, changing_admin_action_takers_to_no_one_allowed, self_changing_admin_action_takers_allowed);
        this.__wbg_ptr = ret >>> 0;
        ChangeControlRulesFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {boolean}
     */
    get selfChangingAdminActionTakersAllowed() {
        const ret = wasm.changecontrolrules_get_self_changing_admin_action_takers_allowed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} self_changing_admin_action_takers_allowed
     */
    set selfChangingAdminActionTakersAllowed(self_changing_admin_action_takers_allowed) {
        wasm.changecontrolrules_set_self_changing_admin_action_takers_allowed(this.__wbg_ptr, self_changing_admin_action_takers_allowed);
    }
    /**
     * @returns {boolean}
     */
    get changingAdminActionTakersToNoOneAllowed() {
        const ret = wasm.changecontrolrules_get_changing_admin_action_takers_to_no_one_allowed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} changing_admin_action_takers_to_no_one_allowed
     */
    set changingAdminActionTakersToNoOneAllowed(changing_admin_action_takers_to_no_one_allowed) {
        wasm.changecontrolrules_set_changing_admin_action_takers_to_no_one_allowed(this.__wbg_ptr, changing_admin_action_takers_to_no_one_allowed);
    }
    /**
     * @returns {boolean}
     */
    get changingAuthorizedActionTakersToNoOneAllowed() {
        const ret = wasm.changecontrolrules_get_changing_authorized_action_takers_to_no_one_allowed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} changing_authorized_action_takers_to_no_one_allowed
     */
    set changingAuthorizedActionTakersToNoOneAllowed(changing_authorized_action_takers_to_no_one_allowed) {
        wasm.changecontrolrules_set_changing_authorized_action_takers_to_no_one_allowed(this.__wbg_ptr, changing_authorized_action_takers_to_no_one_allowed);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.changecontrolrules_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ConsensusErrorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_consensuserror_free(ptr >>> 0, 1));

export class ConsensusError {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ConsensusError.prototype);
        obj.__wbg_ptr = ptr;
        ConsensusErrorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConsensusErrorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_consensuserror_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} error
     * @returns {ConsensusError}
     */
    static deserialize(error) {
        const ptr0 = passArray8ToWasm0(error, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.consensuserror_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConsensusError.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get message() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.consensuserror_message(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ContenderWithSerializedDocumentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contenderwithserializeddocument_free(ptr >>> 0, 1));

export class ContenderWithSerializedDocument {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContenderWithSerializedDocument.prototype);
        obj.__wbg_ptr = ptr;
        ContenderWithSerializedDocumentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContenderWithSerializedDocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contenderwithserializeddocument_free(ptr, 0);
    }
    /**
     * @returns {number | undefined}
     */
    get voteTally() {
        const ret = wasm.contenderwithserializeddocument_vote_tally(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {any} obj
     * @returns {ContenderWithSerializedDocument}
     */
    static fromObject(obj) {
        const ret = wasm.contenderwithserializeddocument_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContenderWithSerializedDocument.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.contenderwithserializeddocument_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    get serializedDocument() {
        const ret = wasm.contenderwithserializeddocument_serialized_document(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identity_id
     * @param {Uint8Array | null} [serialized_document]
     * @param {number | null} [vote_tally]
     */
    constructor(identity_id, serialized_document, vote_tally) {
        var ptr0 = isLikeNone(serialized_document) ? 0 : passArray8ToWasm0(serialized_document, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.contenderwithserializeddocument_new(identity_id, ptr0, len0, isLikeNone(vote_tally) ? 0x100000001 : (vote_tally) >>> 0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        ContenderWithSerializedDocumentFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.contenderwithserializeddocument_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ContenderWithSerializedDocument}
     */
    static fromJSON(js) {
        const ret = wasm.contenderwithserializeddocument_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContenderWithSerializedDocument.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.contenderwithserializeddocument_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ContestedDocumentVotePollWinnerInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contesteddocumentvotepollwinnerinfo_free(ptr >>> 0, 1));

export class ContestedDocumentVotePollWinnerInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContestedDocumentVotePollWinnerInfo.prototype);
        obj.__wbg_ptr = ptr;
        ContestedDocumentVotePollWinnerInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContestedDocumentVotePollWinnerInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contesteddocumentvotepollwinnerinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ContestedDocumentVotePollWinnerInfo}
     */
    static fromObject(obj) {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContestedDocumentVotePollWinnerInfo.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier | undefined}
     */
    get identityId() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_identity_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    isNoWinner() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_isNoWinner(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    isWonByIdentity() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_isWonByIdentity(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {string} kind
     * @param {Identifier | null} [identity_id]
     */
    constructor(kind, identity_id) {
        const ptr0 = passStringToWasm0(kind, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(identity_id)) {
            _assertClass(identity_id, Identifier);
            ptr1 = identity_id.__destroy_into_raw();
        }
        const ret = wasm.contesteddocumentvotepollwinnerinfo_new(ptr0, len0, ptr1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        ContestedDocumentVotePollWinnerInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get kind() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.contesteddocumentvotepollwinnerinfo_kind(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ContestedDocumentVotePollWinnerInfo}
     */
    static fromJSON(js) {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContestedDocumentVotePollWinnerInfo.__wrap(ret[0]);
    }
    /**
     * @returns {boolean}
     */
    isLocked() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_isLocked(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.contesteddocumentvotepollwinnerinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ContestedResourceContenderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contestedresourcecontender_free(ptr >>> 0, 1));

export class ContestedResourceContender {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContestedResourceContender.prototype);
        obj.__wbg_ptr = ptr;
        ContestedResourceContenderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContestedResourceContenderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contestedresourcecontender_free(ptr, 0);
    }
    /**
     * @returns {number | undefined}
     */
    get voteTally() {
        const ret = wasm.contestedresourcecontender_vote_tally(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.contestedresourcecontender_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    get serializedDocument() {
        const ret = wasm.contestedresourcecontender_serialized_document(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ContenderWithSerializedDocument}
     */
    get contender() {
        const ret = wasm.contestedresourcecontender_contender(this.__wbg_ptr);
        return ContenderWithSerializedDocument.__wrap(ret);
    }
}

const ContestedResourceVoteStateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contestedresourcevotestate_free(ptr >>> 0, 1));

export class ContestedResourceVoteState {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContestedResourceVoteState.prototype);
        obj.__wbg_ptr = ptr;
        ContestedResourceVoteStateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContestedResourceVoteStateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contestedresourcevotestate_free(ptr, 0);
    }
    /**
     * @returns {Array<any>}
     */
    get contenders() {
        const ret = wasm.__wbg_get_contestedresourcevotestate_contenders(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Array<any>} arg0
     */
    set contenders(arg0) {
        wasm.__wbg_set_contestedresourcevotestate_contenders(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number | undefined}
     */
    get lockVoteTally() {
        const ret = wasm.__wbg_get_contestedresourcevotestate_lockVoteTally(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set lockVoteTally(arg0) {
        wasm.__wbg_set_contestedresourcevotestate_lockVoteTally(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : (arg0) >>> 0);
    }
    /**
     * @returns {number | undefined}
     */
    get abstainVoteTally() {
        const ret = wasm.__wbg_get_contestedresourcevotestate_abstainVoteTally(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set abstainVoteTally(arg0) {
        wasm.__wbg_set_contestedresourcevotestate_abstainVoteTally(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : (arg0) >>> 0);
    }
    /**
     * @returns {ContestedResourceVoteWinner | undefined}
     */
    get winner() {
        const ret = wasm.__wbg_get_contestedresourcevotestate_winner(this.__wbg_ptr);
        return ret === 0 ? undefined : ContestedResourceVoteWinner.__wrap(ret);
    }
    /**
     * @param {ContestedResourceVoteWinner | null} [arg0]
     */
    set winner(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ContestedResourceVoteWinner);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_contestedresourcevotestate_winner(this.__wbg_ptr, ptr0);
    }
}

const ContestedResourceVoteWinnerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contestedresourcevotewinner_free(ptr >>> 0, 1));

export class ContestedResourceVoteWinner {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContestedResourceVoteWinner.prototype);
        obj.__wbg_ptr = ptr;
        ContestedResourceVoteWinnerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContestedResourceVoteWinnerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contestedresourcevotewinner_free(ptr, 0);
    }
    /**
     * @returns {Identifier | undefined}
     */
    get identityId() {
        const ret = wasm.contestedresourcevotewinner_identity_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @returns {ContestedDocumentVotePollWinnerInfo}
     */
    get info() {
        const ret = wasm.contestedresourcevotewinner_info(this.__wbg_ptr);
        return ContestedDocumentVotePollWinnerInfo.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get kind() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.contestedresourcevotewinner_kind(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {BlockInfo}
     */
    get block() {
        const ret = wasm.contestedresourcevotewinner_block(this.__wbg_ptr);
        return BlockInfo.__wrap(ret);
    }
}

const ContractBoundsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contractbounds_free(ptr >>> 0, 1));

export class ContractBounds {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ContractBounds.prototype);
        obj.__wbg_ptr = ptr;
        ContractBoundsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContractBoundsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contractbounds_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ContractBounds}
     */
    static fromObject(obj) {
        const ret = wasm.contractbounds_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContractBounds.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.contractbounds_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     * @returns {ContractBounds}
     */
    static SingleContract(js_contract_id) {
        const ret = wasm.contractbounds_SingleContract(js_contract_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContractBounds.__wrap(ret[0]);
    }
    /**
     * @returns {string | undefined}
     */
    get documentTypeName() {
        const ret = wasm.contractbounds_document_type_name(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {string}
     */
    get contractBoundsType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.contractbounds_contract_bounds_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} document_type_name
     */
    set documentTypeName(document_type_name) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.contractbounds_set_document_type_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get contractBoundsTypeNumber() {
        const ret = wasm.contractbounds_contract_bounds_type_number(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Identifier}
     */
    get identifier() {
        const ret = wasm.contractbounds_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     * @param {string} document_type_name
     * @returns {ContractBounds}
     */
    static SingleContractDocumentType(js_contract_id, document_type_name) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.contractbounds_SingleContractDocumentType(js_contract_id, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContractBounds.__wrap(ret[0]);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     * @param {string | null} [document_type_name]
     */
    constructor(js_contract_id, document_type_name) {
        var ptr0 = isLikeNone(document_type_name) ? 0 : passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.contractbounds_new(js_contract_id, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        ContractBoundsFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     */
    set identifier(js_contract_id) {
        const ret = wasm.contractbounds_set_id(this.__wbg_ptr, js_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.contractbounds_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ContractBounds}
     */
    static fromJSON(js) {
        const ret = wasm.contractbounds_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ContractBounds.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.contractbounds_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.contractbounds_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const CoreScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_corescript_free(ptr >>> 0, 1));

export class CoreScript {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CoreScript.prototype);
        obj.__wbg_ptr = ptr;
        CoreScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CoreScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_corescript_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {CoreScript}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.corescript_fromBytes(ptr0, len0);
        return CoreScript.__wrap(ret);
    }
    /**
     * @param {Network | string} network
     * @returns {string}
     */
    toAddress(network) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.corescript_toAddress(this.__wbg_ptr, network);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toASMString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_toASMString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_toHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Uint8Array} script_hash
     * @returns {CoreScript}
     */
    static newP2SH(script_hash) {
        const ptr0 = passArray8ToWasm0(script_hash, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.corescript_newP2SH(ptr0, len0);
        return CoreScript.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.corescript_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} key_hash
     * @returns {CoreScript}
     */
    static newP2PKH(key_hash) {
        const ptr0 = passArray8ToWasm0(key_hash, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.corescript_newP2PKH(ptr0, len0);
        return CoreScript.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_toBase64(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.corescript_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const CurrentQuorumsInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_currentquorumsinfo_free(ptr >>> 0, 1));

export class CurrentQuorumsInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CurrentQuorumsInfo.prototype);
        obj.__wbg_ptr = ptr;
        CurrentQuorumsInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CurrentQuorumsInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_currentquorumsinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {CurrentQuorumsInfo}
     */
    static fromObject(obj) {
        const ret = wasm.currentquorumsinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CurrentQuorumsInfo.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get height() {
        const ret = wasm.currentquorumsinfo_height(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {Array<any>}
     */
    get quorums() {
        const ret = wasm.currentquorumsinfo_quorums(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.currentquorumsinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {CurrentQuorumsInfo}
     */
    static fromJSON(js) {
        const ret = wasm.currentquorumsinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CurrentQuorumsInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.currentquorumsinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const DashpayContactKeyInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_dashpaycontactkeyinfo_free(ptr >>> 0, 1));

export class DashpayContactKeyInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DashpayContactKeyInfo.prototype);
        obj.__wbg_ptr = ptr;
        DashpayContactKeyInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DashpayContactKeyInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_dashpaycontactkeyinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get path() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_path(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set path(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyWif() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyWif(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_privateKeyHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyHex(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_publicKey(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set publicKey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_network(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get xprv() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_xprv(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set xprv(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_xprv(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get xpub() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_xpub(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set xpub(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_xpub(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get dipStandard() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_dipStandard(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set dipStandard(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_dipStandard(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get purpose() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_purpose(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set purpose(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_purpose(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get senderIdentity() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_senderIdentity(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set senderIdentity(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_senderIdentity(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get receiverIdentity() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dashpaycontactkeyinfo_receiverIdentity(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set receiverIdentity(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_receiverIdentity(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get account() {
        const ret = wasm.__wbg_get_dashpaycontactkeyinfo_account(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set account(arg0) {
        wasm.__wbg_set_dashpaycontactkeyinfo_account(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get addressIndex() {
        const ret = wasm.__wbg_get_dashpaycontactkeyinfo_addressIndex(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set addressIndex(arg0) {
        wasm.__wbg_set_dashpaycontactkeyinfo_addressIndex(this.__wbg_ptr, arg0);
    }
    /**
     * @param {any} obj
     * @returns {DashpayContactKeyInfo}
     */
    static fromObject(obj) {
        const ret = wasm.dashpaycontactkeyinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DashpayContactKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.dashpaycontactkeyinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {DashpayContactKeyInfo}
     */
    static fromJSON(js) {
        const ret = wasm.dashpaycontactkeyinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DashpayContactKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.dashpaycontactkeyinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const DataContractFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_datacontract_free(ptr >>> 0, 1));

export class DataContract {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DataContract.prototype);
        obj.__wbg_ptr = ptr;
        DataContractFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DataContractFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datacontract_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    static fromBytes(bytes, full_validation, js_platform_version) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontract_fromBytes(ptr0, len0, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    getConfig() {
        const ret = wasm.datacontract_getConfig(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {any}
     */
    get groups() {
        const ret = wasm.datacontract_get_groups(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {object}
     */
    get tokens() {
        const ret = wasm.datacontract_get_tokens(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_config
     * @param {any} js_platform_version
     */
    setConfig(js_config, js_platform_version) {
        const ret = wasm.datacontract_setConfig(this.__wbg_ptr, js_config, js_platform_version);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_groups
     */
    set groups(js_groups) {
        const ret = wasm.datacontract_set_groups(this.__wbg_ptr, js_groups);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_tokens
     */
    set tokens(js_tokens) {
        const ret = wasm.datacontract_set_tokens(this.__wbg_ptr, js_tokens);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {string} base64
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    static fromBase64(base64, full_validation, js_platform_version) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontract_fromBase64(ptr0, len0, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {any} js_value
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    static fromObject(js_value, full_validation, js_platform_version) {
        const ret = wasm.datacontract_fromObject(js_value, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_owner_id
     * @param {bigint} identity_nonce
     * @returns {Identifier}
     */
    static generateId(js_owner_id, identity_nonce) {
        const ret = wasm.datacontract_generateId(js_owner_id, identity_nonce);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    getSchemas() {
        const ret = wasm.datacontract_getSchemas(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {number}
     */
    get version() {
        const ret = wasm.datacontract_get_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {any} js_schema
     * @param {object | null | undefined} js_definitions
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     */
    setSchemas(js_schema, js_definitions, full_validation, js_platform_version) {
        const ret = wasm.datacontract_setSchemas(this.__wbg_ptr, js_schema, isLikeNone(js_definitions) ? 0 : addToExternrefTable0(js_definitions), full_validation, js_platform_version);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {number} version
     */
    set version(version) {
        wasm.datacontract_set_version(this.__wbg_ptr, version);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontract_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get ownerId() {
        const ret = wasm.datacontract_get_owner_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_owner_id
     */
    set ownerId(js_owner_id) {
        const ret = wasm.datacontract_set_owner_id(this.__wbg_ptr, js_owner_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_owner_id
     * @param {bigint} identity_nonce
     * @param {any} js_schema
     * @param {object | null | undefined} js_definitions
     * @param {any} js_tokens
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     */
    constructor(js_owner_id, identity_nonce, js_schema, js_definitions, js_tokens, full_validation, js_platform_version) {
        const ret = wasm.datacontract_from_js_values(js_owner_id, identity_nonce, js_schema, isLikeNone(js_definitions) ? 0 : addToExternrefTable0(js_definitions), js_tokens, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DataContractFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.datacontract_get_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     */
    set id(js_data_contract_id) {
        const ret = wasm.datacontract_set_id(this.__wbg_ptr, js_data_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_platform_version
     * @returns {string}
     */
    toHex(js_platform_version) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontract_toHex(this.__wbg_ptr, js_platform_version);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {any} js_platform_version
     * @returns {any}
     */
    toJSON(js_platform_version) {
        const ret = wasm.datacontract_toJSON(this.__wbg_ptr, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    static fromHex(hex, full_validation, js_platform_version) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontract_fromHex(ptr0, len0, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {any} js_platform_version
     * @returns {Uint8Array}
     */
    toBytes(js_platform_version) {
        const ret = wasm.datacontract_toBytes(this.__wbg_ptr, js_platform_version);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js_value
     * @param {boolean} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    static fromJSON(js_value, full_validation, js_platform_version) {
        const ret = wasm.datacontract_fromJSON(js_value, full_validation, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {any} js_platform_version
     * @returns {string}
     */
    toBase64(js_platform_version) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontract_toBase64(this.__wbg_ptr, js_platform_version);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {any} js_platform_version
     * @returns {any}
     */
    toObject(js_platform_version) {
        const ret = wasm.datacontract_toObject(this.__wbg_ptr, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontract_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DataContractCreateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_datacontractcreatetransition_free(ptr >>> 0, 1));

export class DataContractCreateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DataContractCreateTransition.prototype);
        obj.__wbg_ptr = ptr;
        DataContractCreateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DataContractCreateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datacontractcreatetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {DataContractCreateTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractcreatetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {DataContractCreateTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractcreatetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {DataContractCreateTransition}
     */
    static fromObject(obj) {
        const ret = wasm.datacontractcreatetransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontractcreatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_platform_version
     * @param {boolean | null} [full_validation]
     * @returns {DataContract}
     */
    getDataContract(js_platform_version, full_validation) {
        const ret = wasm.datacontractcreatetransition_getDataContract(this.__wbg_ptr, js_platform_version, isLikeNone(full_validation) ? 0xFFFFFF : full_validation ? 1 : 0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {DataContract} data_contract
     * @param {any} js_platform_version
     */
    setDataContract(data_contract, js_platform_version) {
        _assertClass(data_contract, DataContract);
        const ret = wasm.datacontractcreatetransition_setDataContract(this.__wbg_ptr, data_contract.__wbg_ptr, js_platform_version);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint}
     */
    get identityNonce() {
        const ret = wasm.datacontractcreatetransition_get_identity_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {number}
     */
    get featureVersion() {
        const ret = wasm.datacontractcreatetransition_get_feature_version(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.datacontractcreatetransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} state_transition
     * @returns {DataContractCreateTransition}
     */
    static fromStateTransition(state_transition) {
        _assertClass(state_transition, StateTransition);
        const ret = wasm.datacontractcreatetransition_fromStateTransition(state_transition.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @param {number} protocol_version
     * @returns {boolean}
     */
    verifyProtocolVersion(protocol_version) {
        const ret = wasm.datacontractcreatetransition_verifyProtocolVersion(this.__wbg_ptr, protocol_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * @param {DataContract} data_contract
     * @param {bigint} identity_nonce
     * @param {any} js_platform_version
     */
    constructor(data_contract, identity_nonce, js_platform_version) {
        _assertClass(data_contract, DataContract);
        const ret = wasm.datacontractcreatetransition_new(data_contract.__wbg_ptr, identity_nonce, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DataContractCreateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontractcreatetransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.datacontractcreatetransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {DataContractCreateTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractcreatetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.datacontractcreatetransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {DataContractCreateTransition}
     */
    static fromJSON(js) {
        const ret = wasm.datacontractcreatetransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontractcreatetransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.datacontractcreatetransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontractcreatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DataContractUpdateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_datacontractupdatetransition_free(ptr >>> 0, 1));

export class DataContractUpdateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DataContractUpdateTransition.prototype);
        obj.__wbg_ptr = ptr;
        DataContractUpdateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DataContractUpdateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datacontractupdatetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {DataContractUpdateTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractupdatetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {DataContractUpdateTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractupdatetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {DataContractUpdateTransition}
     */
    static fromObject(obj) {
        const ret = wasm.datacontractupdatetransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontractupdatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {boolean | null | undefined} full_validation
     * @param {any} js_platform_version
     * @returns {DataContract}
     */
    getDataContract(full_validation, js_platform_version) {
        const ret = wasm.datacontractupdatetransition_getDataContract(this.__wbg_ptr, isLikeNone(full_validation) ? 0xFFFFFF : full_validation ? 1 : 0, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContract.__wrap(ret[0]);
    }
    /**
     * @param {DataContract} data_contract
     * @param {any} js_platform_version
     */
    setDataContract(data_contract, js_platform_version) {
        _assertClass(data_contract, DataContract);
        const ret = wasm.datacontractupdatetransition_setDataContract(this.__wbg_ptr, data_contract.__wbg_ptr, js_platform_version);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint}
     */
    get identityContractNonce() {
        const ret = wasm.datacontractupdatetransition_get_identity_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {number}
     */
    get featureVersion() {
        const ret = wasm.datacontractupdatetransition_get_feature_version(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.datacontractupdatetransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} state_transition
     * @returns {DataContractUpdateTransition}
     */
    static fromStateTransition(state_transition) {
        _assertClass(state_transition, StateTransition);
        const ret = wasm.datacontractupdatetransition_fromStateTransition(state_transition.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @param {number} protocol_version
     * @returns {boolean}
     */
    verifyProtocolVersion(protocol_version) {
        const ret = wasm.datacontractupdatetransition_verifyProtocolVersion(this.__wbg_ptr, protocol_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * @param {DataContract} data_contract
     * @param {bigint} identity_nonce
     * @param {any} js_platform_version
     */
    constructor(data_contract, identity_nonce, js_platform_version) {
        _assertClass(data_contract, DataContract);
        const ret = wasm.datacontractupdatetransition_new(data_contract.__wbg_ptr, identity_nonce, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DataContractUpdateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontractupdatetransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.datacontractupdatetransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {DataContractUpdateTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datacontractupdatetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.datacontractupdatetransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {DataContractUpdateTransition}
     */
    static fromJSON(js) {
        const ret = wasm.datacontractupdatetransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DataContractUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datacontractupdatetransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.datacontractupdatetransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datacontractupdatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DerivationPathInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_derivationpathinfo_free(ptr >>> 0, 1));

export class DerivationPathInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DerivationPathInfo.prototype);
        obj.__wbg_ptr = ptr;
        DerivationPathInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DerivationPathInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_derivationpathinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {DerivationPathInfo}
     */
    static fromObject(obj) {
        const ret = wasm.derivationpathinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DerivationPathInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.derivationpathinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {DerivationPathInfo}
     */
    static fromJSON(js) {
        const ret = wasm.derivationpathinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DerivationPathInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.derivationpathinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get path() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivationpathinfo_path(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set path(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_derivationpathinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get purpose() {
        const ret = wasm.__wbg_get_derivationpathinfo_purpose(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set purpose(arg0) {
        wasm.__wbg_set_derivationpathinfo_purpose(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get coinType() {
        const ret = wasm.__wbg_get_derivationpathinfo_coinType(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set coinType(arg0) {
        wasm.__wbg_set_derivationpathinfo_coinType(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get account() {
        const ret = wasm.__wbg_get_derivationpathinfo_account(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set account(arg0) {
        wasm.__wbg_set_derivationpathinfo_account(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get change() {
        const ret = wasm.__wbg_get_derivationpathinfo_change(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set change(arg0) {
        wasm.__wbg_set_derivationpathinfo_change(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get index() {
        const ret = wasm.__wbg_get_derivationpathinfo_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set index(arg0) {
        wasm.__wbg_set_derivationpathinfo_index(this.__wbg_ptr, arg0);
    }
}

const DerivedKeyInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_derivedkeyinfo_free(ptr >>> 0, 1));

export class DerivedKeyInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DerivedKeyInfo.prototype);
        obj.__wbg_ptr = ptr;
        DerivedKeyInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DerivedKeyInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_derivedkeyinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {DerivedKeyInfo}
     */
    static fromObject(obj) {
        const ret = wasm.derivedkeyinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.derivedkeyinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {DerivedKeyInfo}
     */
    static fromJSON(js) {
        const ret = wasm.derivedkeyinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.derivedkeyinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get path() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_path(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set path(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyWif() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_privateKeyWif(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyWif(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_privateKeyHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyHex(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_publicKey(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set publicKey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_network(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get xprv() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_xprv(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set xprv(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_xprv(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get xpub() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_derivedkeyinfo_xpub(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set xpub(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_xpub(this.__wbg_ptr, ptr0, len0);
    }
}

const Dip13DerivationPathInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_dip13derivationpathinfo_free(ptr >>> 0, 1));

export class Dip13DerivationPathInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Dip13DerivationPathInfo.prototype);
        obj.__wbg_ptr = ptr;
        Dip13DerivationPathInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Dip13DerivationPathInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_dip13derivationpathinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get path() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dip13derivationpathinfo_path(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set path(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_derivationpathinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get purpose() {
        const ret = wasm.__wbg_get_dip13derivationpathinfo_purpose(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set purpose(arg0) {
        wasm.__wbg_set_derivationpathinfo_change(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get coinType() {
        const ret = wasm.__wbg_get_dip13derivationpathinfo_coinType(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set coinType(arg0) {
        wasm.__wbg_set_derivationpathinfo_index(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get account() {
        const ret = wasm.__wbg_get_dip13derivationpathinfo_account(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set account(arg0) {
        wasm.__wbg_set_dip13derivationpathinfo_account(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get description() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dip13derivationpathinfo_description(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set description(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dip13derivationpathinfo_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} obj
     * @returns {Dip13DerivationPathInfo}
     */
    static fromObject(obj) {
        const ret = wasm.dip13derivationpathinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Dip13DerivationPathInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.dip13derivationpathinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {Dip13DerivationPathInfo}
     */
    static fromJSON(js) {
        const ret = wasm.dip13derivationpathinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Dip13DerivationPathInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.dip13derivationpathinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const DistributionExponentialFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionexponential_free(ptr >>> 0, 1));

export class DistributionExponential {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionExponential.prototype);
        obj.__wbg_ptr = ptr;
        DistributionExponentialFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionExponentialFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionexponential_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get a() {
        const ret = wasm.__wbg_get_distributionexponential_a(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_distributionexponential_a(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get d() {
        const ret = wasm.__wbg_get_distributionexponential_d(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_distributionexponential_d(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get m() {
        const ret = wasm.__wbg_get_distributionexponential_m(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set m(arg0) {
        wasm.__wbg_set_distributionexponential_m(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get n() {
        const ret = wasm.__wbg_get_distributionexponential_n(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set n(arg0) {
        wasm.__wbg_set_distributionexponential_n(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get o() {
        const ret = wasm.__wbg_get_distributionexponential_o(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set o(arg0) {
        wasm.__wbg_set_distributionexponential_o(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startMoment() {
        const ret = wasm.__wbg_get_distributionexponential_startMoment(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startMoment(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint}
     */
    get b() {
        const ret = wasm.__wbg_get_distributionexponential_b(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set b(arg0) {
        wasm.__wbg_set_distributionexponential_b(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributionexponential_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxValue() {
        const ret = wasm.__wbg_get_distributionexponential_maxValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set maxValue(arg0) {
        wasm.__wbg_set_distributionexponential_maxValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DistributionFixedAmountFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionfixedamount_free(ptr >>> 0, 1));

export class DistributionFixedAmount {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionFixedAmount.prototype);
        obj.__wbg_ptr = ptr;
        DistributionFixedAmountFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionFixedAmountFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionfixedamount_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.__wbg_get_distributionfixedamount_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set amount(arg0) {
        wasm.__wbg_set_distributionfixedamount_amount(this.__wbg_ptr, arg0);
    }
}

const DistributionFunctionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionfunction_free(ptr >>> 0, 1));

export class DistributionFunction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionFunction.prototype);
        obj.__wbg_ptr = ptr;
        DistributionFunctionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionFunctionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionfunction_free(ptr, 0);
    }
    /**
     * @param {bigint} a
     * @param {bigint} d
     * @param {bigint} m
     * @param {bigint} n
     * @param {bigint} o
     * @param {bigint | null | undefined} start_moment
     * @param {bigint} b
     * @param {bigint | null} [min_value]
     * @param {bigint | null} [max_value]
     * @returns {DistributionFunction}
     */
    static Polynomial(a, d, m, n, o, start_moment, b, min_value, max_value) {
        const ret = wasm.distributionfunction_Polynomial(a, d, m, n, o, !isLikeNone(start_moment), isLikeNone(start_moment) ? BigInt(0) : start_moment, b, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value, !isLikeNone(max_value), isLikeNone(max_value) ? BigInt(0) : max_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {bigint} a
     * @param {bigint} d
     * @param {bigint} m
     * @param {bigint} n
     * @param {bigint} o
     * @param {bigint | null | undefined} start_moment
     * @param {bigint} b
     * @param {bigint | null} [min_value]
     * @param {bigint | null} [max_value]
     * @returns {DistributionFunction}
     */
    static Exponential(a, d, m, n, o, start_moment, b, min_value, max_value) {
        const ret = wasm.distributionfunction_Exponential(a, d, m, n, o, !isLikeNone(start_moment), isLikeNone(start_moment) ? BigInt(0) : start_moment, b, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value, !isLikeNone(max_value), isLikeNone(max_value) ? BigInt(0) : max_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {bigint} a
     * @param {bigint} d
     * @param {bigint} m
     * @param {bigint} n
     * @param {bigint} o
     * @param {bigint | null | undefined} start_moment
     * @param {bigint} b
     * @param {bigint | null} [min_value]
     * @param {bigint | null} [max_value]
     * @returns {DistributionFunction}
     */
    static Logarithmic(a, d, m, n, o, start_moment, b, min_value, max_value) {
        const ret = wasm.distributionfunction_Logarithmic(a, d, m, n, o, !isLikeNone(start_moment), isLikeNone(start_moment) ? BigInt(0) : start_moment, b, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value, !isLikeNone(max_value), isLikeNone(max_value) ? BigInt(0) : max_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.distributionfunction_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    getFunctionName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.distributionfunction_getFunctionName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    getFunctionValue() {
        const ret = wasm.distributionfunction_getFunctionValue(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {bigint} a
     * @param {bigint} d
     * @param {bigint} m
     * @param {bigint} n
     * @param {bigint} o
     * @param {bigint | null | undefined} start_moment
     * @param {bigint} b
     * @param {bigint | null} [min_value]
     * @param {bigint | null} [max_value]
     * @returns {DistributionFunction}
     */
    static InvertedLogarithmic(a, d, m, n, o, start_moment, b, min_value, max_value) {
        const ret = wasm.distributionfunction_InvertedLogarithmic(a, d, m, n, o, !isLikeNone(start_moment), isLikeNone(start_moment) ? BigInt(0) : start_moment, b, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value, !isLikeNone(max_value), isLikeNone(max_value) ? BigInt(0) : max_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {number} step_count
     * @param {number} decrease_per_interval_numerator
     * @param {number} decrease_per_interval_denominator
     * @param {bigint | null | undefined} start_decreasing_offset
     * @param {number | null | undefined} max_interval_count
     * @param {bigint} distribution_start_amount
     * @param {bigint} trailing_distribution_interval_amount
     * @param {bigint | null} [min_value]
     * @returns {DistributionFunction}
     */
    static StepDecreasingAmount(step_count, decrease_per_interval_numerator, decrease_per_interval_denominator, start_decreasing_offset, max_interval_count, distribution_start_amount, trailing_distribution_interval_amount, min_value) {
        const ret = wasm.distributionfunction_StepDecreasingAmount(step_count, decrease_per_interval_numerator, decrease_per_interval_denominator, !isLikeNone(start_decreasing_offset), isLikeNone(start_decreasing_offset) ? BigInt(0) : start_decreasing_offset, isLikeNone(max_interval_count) ? 0xFFFFFF : max_interval_count, distribution_start_amount, trailing_distribution_interval_amount, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {bigint} amount
     * @returns {DistributionFunction}
     */
    static FixedAmountDistribution(amount) {
        const ret = wasm.distributionfunction_FixedAmountDistribution(amount);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {bigint} a
     * @param {bigint} d
     * @param {bigint | null | undefined} start_step
     * @param {bigint} starting_amount
     * @param {bigint | null} [min_value]
     * @param {bigint | null} [max_value]
     * @returns {DistributionFunction}
     */
    static Linear(a, d, start_step, starting_amount, min_value, max_value) {
        const ret = wasm.distributionfunction_Linear(a, d, !isLikeNone(start_step), isLikeNone(start_step) ? BigInt(0) : start_step, starting_amount, !isLikeNone(min_value), isLikeNone(min_value) ? BigInt(0) : min_value, !isLikeNone(max_value), isLikeNone(max_value) ? BigInt(0) : max_value);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {bigint} min
     * @param {bigint} max
     * @returns {DistributionFunction}
     */
    static Random(min, max) {
        const ret = wasm.distributionfunction_Random(min, max);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {any} js_steps_with_amount
     * @returns {DistributionFunction}
     */
    static Stepwise(js_steps_with_amount) {
        const ret = wasm.distributionfunction_Stepwise(js_steps_with_amount);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DistributionFunction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.distributionfunction_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DistributionInvertedLogarithmicFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributioninvertedlogarithmic_free(ptr >>> 0, 1));

export class DistributionInvertedLogarithmic {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionInvertedLogarithmic.prototype);
        obj.__wbg_ptr = ptr;
        DistributionInvertedLogarithmicFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionInvertedLogarithmicFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributioninvertedlogarithmic_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get a() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_a(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_distributionexponential_a(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get d() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_d(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_distributionexponential_d(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get m() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_m(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set m(arg0) {
        wasm.__wbg_set_distributionexponential_m(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get n() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_n(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set n(arg0) {
        wasm.__wbg_set_distributionexponential_n(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get o() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_o(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set o(arg0) {
        wasm.__wbg_set_distributionexponential_o(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startMoment() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_startMoment(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startMoment(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint}
     */
    get b() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_b(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set b(arg0) {
        wasm.__wbg_set_distributionexponential_b(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxValue() {
        const ret = wasm.__wbg_get_distributioninvertedlogarithmic_maxValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set maxValue(arg0) {
        wasm.__wbg_set_distributionexponential_maxValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DistributionLinearFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionlinear_free(ptr >>> 0, 1));

export class DistributionLinear {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionLinear.prototype);
        obj.__wbg_ptr = ptr;
        DistributionLinearFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionLinearFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionlinear_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get a() {
        const ret = wasm.__wbg_get_distributionlinear_a(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_distributionexponential_a(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get d() {
        const ret = wasm.__wbg_get_distributionlinear_d(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_distributionexponential_d(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startStep() {
        const ret = wasm.__wbg_get_distributionlinear_startStep(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startStep(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint}
     */
    get startingAmount() {
        const ret = wasm.__wbg_get_distributionlinear_startingAmount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set startingAmount(arg0) {
        wasm.__wbg_set_distributionexponential_m(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributionlinear_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxValue() {
        const ret = wasm.__wbg_get_distributionlinear_maxValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set maxValue(arg0) {
        wasm.__wbg_set_distributionexponential_maxValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DistributionLogarithmicFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionlogarithmic_free(ptr >>> 0, 1));

export class DistributionLogarithmic {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionLogarithmic.prototype);
        obj.__wbg_ptr = ptr;
        DistributionLogarithmicFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionLogarithmicFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionlogarithmic_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get a() {
        const ret = wasm.__wbg_get_distributionlogarithmic_a(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_distributionexponential_a(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get d() {
        const ret = wasm.__wbg_get_distributionlogarithmic_d(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_distributionexponential_d(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get m() {
        const ret = wasm.__wbg_get_distributionlogarithmic_m(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set m(arg0) {
        wasm.__wbg_set_distributionexponential_m(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get n() {
        const ret = wasm.__wbg_get_distributionlogarithmic_n(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set n(arg0) {
        wasm.__wbg_set_distributionexponential_n(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get o() {
        const ret = wasm.__wbg_get_distributionlogarithmic_o(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set o(arg0) {
        wasm.__wbg_set_distributionexponential_o(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startMoment() {
        const ret = wasm.__wbg_get_distributionlogarithmic_startMoment(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startMoment(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint}
     */
    get b() {
        const ret = wasm.__wbg_get_distributionlogarithmic_b(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set b(arg0) {
        wasm.__wbg_set_distributionexponential_b(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributionlogarithmic_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxValue() {
        const ret = wasm.__wbg_get_distributionlogarithmic_maxValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set maxValue(arg0) {
        wasm.__wbg_set_distributionexponential_maxValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DistributionPolynomialFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionpolynomial_free(ptr >>> 0, 1));

export class DistributionPolynomial {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionPolynomial.prototype);
        obj.__wbg_ptr = ptr;
        DistributionPolynomialFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionPolynomialFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionpolynomial_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get a() {
        const ret = wasm.__wbg_get_distributionpolynomial_a(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_distributionexponential_a(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get d() {
        const ret = wasm.__wbg_get_distributionpolynomial_d(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_distributionexponential_d(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get m() {
        const ret = wasm.__wbg_get_distributionpolynomial_m(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set m(arg0) {
        wasm.__wbg_set_distributionexponential_m(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get n() {
        const ret = wasm.__wbg_get_distributionpolynomial_n(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set n(arg0) {
        wasm.__wbg_set_distributionexponential_n(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get o() {
        const ret = wasm.__wbg_get_distributionpolynomial_o(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} arg0
     */
    set o(arg0) {
        wasm.__wbg_set_distributionexponential_o(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startMoment() {
        const ret = wasm.__wbg_get_distributionpolynomial_startMoment(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startMoment(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint}
     */
    get b() {
        const ret = wasm.__wbg_get_distributionpolynomial_b(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set b(arg0) {
        wasm.__wbg_set_distributionexponential_b(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributionpolynomial_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxValue() {
        const ret = wasm.__wbg_get_distributionpolynomial_maxValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set maxValue(arg0) {
        wasm.__wbg_set_distributionexponential_maxValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DistributionRandomFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionrandom_free(ptr >>> 0, 1));

export class DistributionRandom {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionRandom.prototype);
        obj.__wbg_ptr = ptr;
        DistributionRandomFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionRandomFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionrandom_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get min() {
        const ret = wasm.__wbg_get_distributionrandom_min(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set min(arg0) {
        wasm.__wbg_set_distributionfixedamount_amount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get max() {
        const ret = wasm.__wbg_get_distributionrandom_max(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set max(arg0) {
        wasm.__wbg_set_distributionrandom_max(this.__wbg_ptr, arg0);
    }
}

const DistributionStepDecreasingAmountFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_distributionstepdecreasingamount_free(ptr >>> 0, 1));

export class DistributionStepDecreasingAmount {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DistributionStepDecreasingAmount.prototype);
        obj.__wbg_ptr = ptr;
        DistributionStepDecreasingAmountFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DistributionStepDecreasingAmountFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_distributionstepdecreasingamount_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get stepCount() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_stepCount(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set stepCount(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_stepCount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get decreasePerIntervalNumerator() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_decreasePerIntervalNumerator(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set decreasePerIntervalNumerator(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_decreasePerIntervalNumerator(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get decreasePerIntervalDenominator() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_decreasePerIntervalDenominator(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set decreasePerIntervalDenominator(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_decreasePerIntervalDenominator(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get startDecreasingOffset() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_startDecreasingOffset(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set startDecreasingOffset(arg0) {
        wasm.__wbg_set_distributionexponential_startMoment(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {number | undefined}
     */
    get maxIntervalCount() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_maxIntervalCount(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set maxIntervalCount(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_maxIntervalCount(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0);
    }
    /**
     * @returns {bigint}
     */
    get distributionStartAmount() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_distributionStartAmount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set distributionStartAmount(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_distributionStartAmount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint}
     */
    get trailingDistributionIntervalAmount() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_trailingDistributionIntervalAmount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set trailingDistributionIntervalAmount(arg0) {
        wasm.__wbg_set_distributionstepdecreasingamount_trailingDistributionIntervalAmount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minValue() {
        const ret = wasm.__wbg_get_distributionstepdecreasingamount_minValue(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set minValue(arg0) {
        wasm.__wbg_set_distributionexponential_minValue(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}

const DocumentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_document_free(ptr >>> 0, 1));
/**
 * DocumentWasm wraps a Document and adds metadata fields that are not part of the core Document.
 */
export class Document {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Document.prototype);
        obj.__wbg_ptr = ptr;
        DocumentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_document_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @param {DataContract} data_contract
     * @param {string} type_name
     * @param {any} js_platform_version
     * @returns {Document}
     */
    static fromBytes(bytes, data_contract, type_name, js_platform_version) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(data_contract, DataContract);
        const ptr1 = passStringToWasm0(type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.document_fromBytes(ptr0, len0, data_contract.__wbg_ptr, ptr1, len1, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Document.__wrap(ret[0]);
    }
    /**
     * @param {any} js_raw_document
     * @param {string} js_document_type_name
     * @param {bigint} js_revision
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     * @param {Identifier | Uint8Array | string} js_owner_id
     * @param {Identifier | Uint8Array | string} js_document_id
     */
    constructor(js_raw_document, js_document_type_name, js_revision, js_data_contract_id, js_owner_id, js_document_id) {
        const ptr0 = passStringToWasm0(js_document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.document_constructor(js_raw_document, ptr0, len0, js_revision, js_data_contract_id, js_owner_id, js_document_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @param {string} base64
     * @param {DataContract} data_contract
     * @param {string} type_name
     * @param {any} js_platform_version
     * @returns {Document}
     */
    static fromBase64(base64, data_contract, type_name, js_platform_version) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(data_contract, DataContract);
        const ptr1 = passStringToWasm0(type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.document_fromBase64(ptr0, len0, data_contract.__wbg_ptr, ptr1, len1, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Document.__wrap(ret[0]);
    }
    /**
     * Create a Document from a JS object.
     * @param {any} js_value
     * @returns {Document}
     */
    static fromObject(js_value) {
        const ret = wasm.document_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Document.__wrap(ret[0]);
    }
    /**
     * @param {string} js_document_type_name
     * @param {Identifier | Uint8Array | string} js_owner_id
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     * @param {Uint8Array | null} [opt_entropy]
     * @returns {Uint8Array}
     */
    static generateId(js_document_type_name, js_owner_id, js_data_contract_id, opt_entropy) {
        const ptr0 = passStringToWasm0(js_document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(opt_entropy) ? 0 : passArray8ToWasm0(opt_entropy, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.document_generateId(ptr0, len0, js_owner_id, js_data_contract_id, ptr1, len1);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v3 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v3;
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    get entropy() {
        const ret = wasm.document_get_entropy(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {any} entropy
     */
    set entropy(entropy) {
        const ret = wasm.document_set_entropy(this.__wbg_ptr, entropy);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.document_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get ownerId() {
        const ret = wasm.document_get_owner_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {bigint | undefined}
     */
    get revision() {
        const ret = wasm.document_get_revision(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {Identifier | Uint8Array | string} id
     */
    set ownerId(id) {
        const ret = wasm.document_set_owner_id(this.__wbg_ptr, id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {bigint | null} [revision]
     */
    set revision(revision) {
        wasm.document_set_revision(this.__wbg_ptr, !isLikeNone(revision), isLikeNone(revision) ? BigInt(0) : revision);
    }
    /**
     * @returns {bigint | undefined}
     */
    get createdAt() {
        const ret = wasm.document_get_created_at(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {any}
     */
    get properties() {
        const ret = wasm.document_get_properties(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get updatedAt() {
        const ret = wasm.document_get_updated_at(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [created_at]
     */
    set createdAt(created_at) {
        wasm.document_set_created_at(this.__wbg_ptr, !isLikeNone(created_at), isLikeNone(created_at) ? BigInt(0) : created_at);
    }
    /**
     * @param {any} properties
     */
    set properties(properties) {
        const ret = wasm.document_set_properties(this.__wbg_ptr, properties);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {bigint | null} [updated_at]
     */
    set updatedAt(updated_at) {
        wasm.document_set_updated_at(this.__wbg_ptr, !isLikeNone(updated_at), isLikeNone(updated_at) ? BigInt(0) : updated_at);
    }
    /**
     * @returns {bigint | undefined}
     */
    get transferredAt() {
        const ret = wasm.document_get_transferred_at(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [transferred_at]
     */
    set transferredAt(transferred_at) {
        wasm.document_set_transferred_at(this.__wbg_ptr, !isLikeNone(transferred_at), isLikeNone(transferred_at) ? BigInt(0) : transferred_at);
    }
    /**
     * @returns {Identifier}
     */
    get dataContractId() {
        const ret = wasm.document_get_data_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get documentTypeName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.document_get_document_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} document_type_name
     */
    set documentTypeName(document_type_name) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.document_set_document_type_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     */
    set dataContractId(js_contract_id) {
        const ret = wasm.document_set_js_data_contract_id(this.__wbg_ptr, js_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get createdAtBlockHeight() {
        const ret = wasm.document_get_created_at_block_height(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get updatedAtBlockHeight() {
        const ret = wasm.document_get_updated_at_block_height(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [created_at_block_height]
     */
    set createdAtBlockHeight(created_at_block_height) {
        wasm.document_set_created_at_block_height(this.__wbg_ptr, !isLikeNone(created_at_block_height), isLikeNone(created_at_block_height) ? BigInt(0) : created_at_block_height);
    }
    /**
     * @param {bigint | null} [updated_at_block_height]
     */
    set updatedAtBlockHeight(updated_at_block_height) {
        wasm.document_set_updated_at_block_height(this.__wbg_ptr, !isLikeNone(updated_at_block_height), isLikeNone(updated_at_block_height) ? BigInt(0) : updated_at_block_height);
    }
    /**
     * @returns {bigint | undefined}
     */
    get transferredAtBlockHeight() {
        const ret = wasm.document_get_transferred_at_block_height(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [transferred_at_block_height]
     */
    set transferredAtBlockHeight(transferred_at_block_height) {
        wasm.document_set_transferred_at_block_height(this.__wbg_ptr, !isLikeNone(transferred_at_block_height), isLikeNone(transferred_at_block_height) ? BigInt(0) : transferred_at_block_height);
    }
    /**
     * @returns {number | undefined}
     */
    get createdAtCoreBlockHeight() {
        const ret = wasm.document_get_created_at_core_block_height(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @returns {number | undefined}
     */
    get updatedAtCoreBlockHeight() {
        const ret = wasm.document_get_updated_at_core_block_height(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [created_at_core_block_height]
     */
    set createdAtCoreBlockHeight(created_at_core_block_height) {
        wasm.document_set_created_at_core_block_height(this.__wbg_ptr, isLikeNone(created_at_core_block_height) ? 0x100000001 : (created_at_core_block_height) >>> 0);
    }
    /**
     * @param {number | null} [updated_at_core_block_height]
     */
    set updatedAtCoreBlockHeight(updated_at_core_block_height) {
        wasm.document_set_updated_at_core_block_height(this.__wbg_ptr, isLikeNone(updated_at_core_block_height) ? 0x100000001 : (updated_at_core_block_height) >>> 0);
    }
    /**
     * @returns {number | undefined}
     */
    get transferredAtCoreBlockHeight() {
        const ret = wasm.document_get_transferred_at_core_block_height(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [transferred_at_core_block_height]
     */
    set transferredAtCoreBlockHeight(transferred_at_core_block_height) {
        wasm.document_set_transferred_at_core_block_height(this.__wbg_ptr, isLikeNone(transferred_at_core_block_height) ? 0x100000001 : (transferred_at_core_block_height) >>> 0);
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.document_get_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} id
     */
    set id(id) {
        const ret = wasm.document_set_id(this.__wbg_ptr, id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {DataContract} data_contract
     * @param {any} js_platform_version
     * @returns {string}
     */
    toHex(data_contract, js_platform_version) {
        let deferred2_0;
        let deferred2_1;
        try {
            _assertClass(data_contract, DataContract);
            const ret = wasm.document_toHex(this.__wbg_ptr, data_contract.__wbg_ptr, js_platform_version);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Convert to a JSON-compatible JS object with binary fields as strings.
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.document_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @param {DataContract} data_contract
     * @param {string} type_name
     * @param {any} js_platform_version
     * @returns {Document}
     */
    static fromHex(hex, data_contract, type_name, js_platform_version) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(data_contract, DataContract);
        const ptr1 = passStringToWasm0(type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.document_fromHex(ptr0, len0, data_contract.__wbg_ptr, ptr1, len1, js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Document.__wrap(ret[0]);
    }
    /**
     * @param {DataContract} data_contract
     * @param {any} js_platform_version
     * @returns {Uint8Array}
     */
    toBytes(data_contract, js_platform_version) {
        _assertClass(data_contract, DataContract);
        const ret = wasm.document_toBytes(this.__wbg_ptr, data_contract.__wbg_ptr, js_platform_version);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * Create a Document from a JSON object.
     * JSON format has identifiers as base58 strings.
     * @param {any} js_value
     * @returns {Document}
     */
    static fromJSON(js_value) {
        const ret = wasm.document_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Document.__wrap(ret[0]);
    }
    /**
     * @param {DataContract} data_contract
     * @param {any} js_platform_version
     * @returns {string}
     */
    toBase64(data_contract, js_platform_version) {
        let deferred2_0;
        let deferred2_1;
        try {
            _assertClass(data_contract, DataContract);
            const ret = wasm.document_toBase64(this.__wbg_ptr, data_contract.__wbg_ptr, js_platform_version);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Convert to a JS object with binary fields as Uint8Array.
     * @returns {any}
     */
    toObject() {
        const ret = wasm.document_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.document_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentBaseTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentbasetransition_free(ptr >>> 0, 1));

export class DocumentBaseTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentBaseTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentBaseTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentBaseTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentbasetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentbasetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get dataContractId() {
        const ret = wasm.documentbasetransition_get_data_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     */
    set dataContractId(js_data_contract_id) {
        const ret = wasm.documentbasetransition_set_data_contract_id(this.__wbg_ptr, js_data_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get documentTypeName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentbasetransition_get_document_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {TokenPaymentInfo | undefined}
     */
    get tokenPaymentInfo() {
        const ret = wasm.documentbasetransition_get_token_payment_info(this.__wbg_ptr);
        return ret === 0 ? undefined : TokenPaymentInfo.__wrap(ret);
    }
    /**
     * @param {string} document_type_name
     */
    set documentTypeName(document_type_name) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.documentbasetransition_set_document_type_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {TokenPaymentInfo} token_payment_info
     */
    set tokenPaymentInfo(token_payment_info) {
        _assertClass(token_payment_info, TokenPaymentInfo);
        wasm.documentbasetransition_set_token_payment_info(this.__wbg_ptr, token_payment_info.__wbg_ptr);
    }
    /**
     * @returns {bigint}
     */
    get identityContractNonce() {
        const ret = wasm.documentbasetransition_get_identity_contract_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} nonce
     */
    set identityContractNonce(nonce) {
        wasm.documentbasetransition_set_identity_contract_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_document_id
     * @param {bigint} identity_contract_nonce
     * @param {string} document_type_name
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     * @param {any} js_token_payment_info
     */
    constructor(js_document_id, identity_contract_nonce, document_type_name, js_data_contract_id, js_token_payment_info) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.documentbasetransition_new(js_document_id, identity_contract_nonce, ptr0, len0, js_data_contract_id, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentBaseTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.documentbasetransition_get_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     */
    set id(js_id) {
        const ret = wasm.documentbasetransition_set_id(this.__wbg_ptr, js_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentbasetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentCreateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentcreatetransition_free(ptr >>> 0, 1));

export class DocumentCreateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentCreateTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentCreateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentCreateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentcreatetransition_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array}
     */
    get entropy() {
        const ret = wasm.documentcreatetransition_get_entropy(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} js_entropy
     */
    set entropy(js_entropy) {
        const ptr0 = passArray8ToWasm0(js_entropy, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.documentcreatetransition_set_entropy(this.__wbg_ptr, ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentcreatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documentcreatetransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentCreateTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documentcreatetransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {PrefundedVotingBalance | undefined}
     */
    get prefundedVotingBalance() {
        const ret = wasm.documentcreatetransition_get_prefunded_voting_balance(this.__wbg_ptr);
        return ret === 0 ? undefined : PrefundedVotingBalance.__wrap(ret);
    }
    /**
     * @param {PrefundedVotingBalance} prefunded_voting_balance
     */
    set prefundedVotingBalance(prefunded_voting_balance) {
        _assertClass(prefunded_voting_balance, PrefundedVotingBalance);
        wasm.documentcreatetransition_set_prefunded_voting_balance(this.__wbg_ptr, prefunded_voting_balance.__wbg_ptr);
    }
    clearPrefundedVotingBalance() {
        wasm.documentcreatetransition_clearPrefundedVotingBalance(this.__wbg_ptr);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {any} js_prefunded_voting_balance
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, js_prefunded_voting_balance, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documentcreatetransition_new(document.__wbg_ptr, identity_contract_nonce, js_prefunded_voting_balance, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentCreateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documentcreatetransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    get data() {
        const ret = wasm.documentcreatetransition_get_data(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documentcreatetransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @param {any} js_data
     */
    set data(js_data) {
        const ret = wasm.documentcreatetransition_set_data(this.__wbg_ptr, js_data);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentcreatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentDeleteTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentdeletetransition_free(ptr >>> 0, 1));

export class DocumentDeleteTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentDeleteTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentDeleteTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentDeleteTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentdeletetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentdeletetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documentdeletetransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentDeleteTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documentdeletetransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentDeleteTransition.__wrap(ret[0]);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documentdeletetransition_new(document.__wbg_ptr, identity_contract_nonce, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentDeleteTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documentdeletetransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documentdeletetransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentdeletetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentPurchaseTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentpurchasetransition_free(ptr >>> 0, 1));

export class DocumentPurchaseTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentPurchaseTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentPurchaseTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentPurchaseTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentpurchasetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentpurchasetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get revision() {
        const ret = wasm.documentpurchasetransition_get_revision(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} revision
     */
    set revision(revision) {
        wasm.documentpurchasetransition_set_revision(this.__wbg_ptr, revision);
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documentpurchasetransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentPurchaseTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documentpurchasetransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentPurchaseTransition.__wrap(ret[0]);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {bigint} amount
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, amount, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documentpurchasetransition_new(document.__wbg_ptr, identity_contract_nonce, amount, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentPurchaseTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documentpurchasetransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documentpurchasetransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @returns {bigint}
     */
    get price() {
        const ret = wasm.documentpurchasetransition_get_price(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} price
     */
    set price(price) {
        wasm.documentpurchasetransition_set_price(this.__wbg_ptr, price);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentpurchasetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentReplaceTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentreplacetransition_free(ptr >>> 0, 1));

export class DocumentReplaceTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentReplaceTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentReplaceTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentReplaceTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentreplacetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentreplacetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get revision() {
        const ret = wasm.documentreplacetransition_get_revision(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} revision
     */
    set revision(revision) {
        wasm.documentreplacetransition_set_revision(this.__wbg_ptr, revision);
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documentreplacetransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentReplaceTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documentreplacetransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentReplaceTransition.__wrap(ret[0]);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documentreplacetransition_new(document.__wbg_ptr, identity_contract_nonce, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentReplaceTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documentreplacetransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    get data() {
        const ret = wasm.documentreplacetransition_get_data(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documentreplacetransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @param {any} js_data
     */
    set data(js_data) {
        const ret = wasm.documentreplacetransition_set_data(this.__wbg_ptr, js_data);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentreplacetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentTransferTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documenttransfertransition_free(ptr >>> 0, 1));

export class DocumentTransferTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentTransferTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentTransferTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentTransferTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documenttransfertransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransfertransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get recipientId() {
        const ret = wasm.documenttransfertransition_get_recipient_owner_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_recipient_owner_id
     */
    set recipientId(js_recipient_owner_id) {
        const ret = wasm.documenttransfertransition_set_recipient_owner_id(this.__wbg_ptr, js_recipient_owner_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documenttransfertransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentTransferTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documenttransfertransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentTransferTransition.__wrap(ret[0]);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {Identifier | Uint8Array | string} js_recipient_owner_id
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, js_recipient_owner_id, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documenttransfertransition_new(document.__wbg_ptr, identity_contract_nonce, js_recipient_owner_id, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentTransferTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documenttransfertransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documenttransfertransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransfertransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documenttransition_free(ptr >>> 0, 1));

export class DocumentTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documenttransition_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    get entropy() {
        const ret = wasm.documenttransition_get_entropy(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get revision() {
        const ret = wasm.documenttransition_get_revision(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} revision
     */
    set revision(revision) {
        wasm.documenttransition_set_revision(this.__wbg_ptr, revision);
    }
    /**
     * @returns {string}
     */
    get actionType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransition_get_action_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get dataContractId() {
        const ret = wasm.documenttransition_get_data_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     */
    set dataContractId(js_data_contract_id) {
        const ret = wasm.documenttransition_set_data_contract_id(this.__wbg_ptr, js_data_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {DocumentCreateTransition}
     */
    get createTransition() {
        const ret = wasm.documenttransition_get_create_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {DocumentDeleteTransition}
     */
    get deleteTransition() {
        const ret = wasm.documenttransition_get_delete_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentDeleteTransition.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get actionTypeNumber() {
        const ret = wasm.documenttransition_get_action_type_number(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get documentTypeName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransition_get_document_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DocumentReplaceTransition}
     */
    get replaceTransition() {
        const ret = wasm.documenttransition_get_replace_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentReplaceTransition.__wrap(ret[0]);
    }
    /**
     * @returns {DocumentPurchaseTransition}
     */
    get purchaseTransition() {
        const ret = wasm.documenttransition_get_purchase_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentPurchaseTransition.__wrap(ret[0]);
    }
    /**
     * @returns {DocumentTransferTransition}
     */
    get transferTransition() {
        const ret = wasm.documenttransition_get_transfer_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentTransferTransition.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get identityContractNonce() {
        const ret = wasm.documenttransition_get_identity_contract_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {DocumentUpdatePriceTransition}
     */
    get updatePriceTransition() {
        const ret = wasm.documenttransition_get_update_price_transition(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentUpdatePriceTransition.__wrap(ret[0]);
    }
    /**
     * @param {bigint} identity_contract_nonce
     */
    set identityContractNonce(identity_contract_nonce) {
        wasm.documenttransition_set_identity_contract_nonce(this.__wbg_ptr, identity_contract_nonce);
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.documenttransition_get_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documenttransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DocumentUpdatePriceTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_documentupdatepricetransition_free(ptr >>> 0, 1));

export class DocumentUpdatePriceTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DocumentUpdatePriceTransition.prototype);
        obj.__wbg_ptr = ptr;
        DocumentUpdatePriceTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DocumentUpdatePriceTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentupdatepricetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentupdatepricetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DocumentTransition}
     */
    toDocumentTransition() {
        const ret = wasm.documentupdatepricetransition_toDocumentTransition(this.__wbg_ptr);
        return DocumentTransition.__wrap(ret);
    }
    /**
     * @param {DocumentTransition} js_transition
     * @returns {DocumentUpdatePriceTransition}
     */
    static fromDocumentTransition(js_transition) {
        _assertClass(js_transition, DocumentTransition);
        var ptr0 = js_transition.__destroy_into_raw();
        const ret = wasm.documentupdatepricetransition_fromDocumentTransition(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DocumentUpdatePriceTransition.__wrap(ret[0]);
    }
    /**
     * @param {Document} document
     * @param {bigint} identity_contract_nonce
     * @param {bigint} price
     * @param {any} js_token_payment_info
     */
    constructor(document, identity_contract_nonce, price, js_token_payment_info) {
        _assertClass(document, Document);
        const ret = wasm.documentupdatepricetransition_new(document.__wbg_ptr, identity_contract_nonce, price, js_token_payment_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        DocumentUpdatePriceTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {DocumentBaseTransition}
     */
    get base() {
        const ret = wasm.documentupdatepricetransition_get_base(this.__wbg_ptr);
        return DocumentBaseTransition.__wrap(ret);
    }
    /**
     * @param {DocumentBaseTransition} base
     */
    set base(base) {
        _assertClass(base, DocumentBaseTransition);
        wasm.documentupdatepricetransition_set_base(this.__wbg_ptr, base.__wbg_ptr);
    }
    /**
     * @returns {bigint}
     */
    get price() {
        const ret = wasm.documentupdatepricetransition_get_price(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} price
     */
    set price(price) {
        wasm.documentupdatepricetransition_set_price(this.__wbg_ptr, price);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.documentupdatepricetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DpnsUsernameInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_dpnsusernameinfo_free(ptr >>> 0, 1));

export class DpnsUsernameInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DpnsUsernameInfo.prototype);
        obj.__wbg_ptr = ptr;
        DpnsUsernameInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DpnsUsernameInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_dpnsusernameinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {DpnsUsernameInfo}
     */
    static fromObject(obj) {
        const ret = wasm.dpnsusernameinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DpnsUsernameInfo.__wrap(ret[0]);
    }
    /**
     * @param {string} username
     * @param {Identifier} identity_id
     * @param {Identifier} document_id
     */
    constructor(username, identity_id, document_id) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(identity_id, Identifier);
        var ptr1 = identity_id.__destroy_into_raw();
        _assertClass(document_id, Identifier);
        var ptr2 = document_id.__destroy_into_raw();
        const ret = wasm.dpnsusernameinfo_new(ptr0, len0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DpnsUsernameInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.dpnsusernameinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {DpnsUsernameInfo}
     */
    static fromJSON(js) {
        const ret = wasm.dpnsusernameinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DpnsUsernameInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.dpnsusernameinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get username() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_dpnsusernameinfo_username(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set username(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.__wbg_get_dpnsusernameinfo_identityId(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier} arg0
     */
    set identityId(arg0) {
        _assertClass(arg0, Identifier);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_dpnsusernameinfo_identityId(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {Identifier}
     */
    get documentId() {
        const ret = wasm.__wbg_get_dpnsusernameinfo_documentId(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier} arg0
     */
    set documentId(arg0) {
        _assertClass(arg0, Identifier);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_dpnsusernameinfo_documentId(this.__wbg_ptr, ptr0);
    }
}

const EpochBasedDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_epochbaseddistribution_free(ptr >>> 0, 1));

export class EpochBasedDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EpochBasedDistribution.prototype);
        obj.__wbg_ptr = ptr;
        EpochBasedDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EpochBasedDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_epochbaseddistribution_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get interval() {
        const ret = wasm.__wbg_get_epochbaseddistribution_interval(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set interval(arg0) {
        wasm.__wbg_set_epochbaseddistribution_interval(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.epochbaseddistribution_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DistributionFunction}
     */
    get function() {
        const ret = wasm.epochbaseddistribution_get_function(this.__wbg_ptr);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {DistributionFunction} _function
     */
    set function(_function) {
        _assertClass(_function, DistributionFunction);
        wasm.epochbaseddistribution_set_function(this.__wbg_ptr, _function.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.epochbaseddistribution_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ExtendedEpochInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_extendedepochinfo_free(ptr >>> 0, 1));

export class ExtendedEpochInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ExtendedEpochInfo.prototype);
        obj.__wbg_ptr = ptr;
        ExtendedEpochInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ExtendedEpochInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_extendedepochinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ExtendedEpochInfo}
     */
    static fromObject(obj) {
        const ret = wasm.extendedepochinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExtendedEpochInfo.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.extendedepochinfo_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get feeMultiplier() {
        const ret = wasm.extendedepochinfo_fee_multiplier(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    get firstBlockTime() {
        const ret = wasm.extendedepochinfo_first_block_time(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    get protocolVersion() {
        const ret = wasm.extendedepochinfo_protocol_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {bigint}
     */
    get firstBlockHeight() {
        const ret = wasm.extendedepochinfo_first_block_height(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} first_block_time
     */
    set firstBlockTime(first_block_time) {
        wasm.extendedepochinfo_set_first_block_time(this.__wbg_ptr, first_block_time);
    }
    /**
     * @param {number} protocol_version
     */
    set protocolVersion(protocol_version) {
        wasm.extendedepochinfo_set_protocol_version(this.__wbg_ptr, protocol_version);
    }
    /**
     * @param {bigint} first_block_height
     */
    set firstBlockHeight(first_block_height) {
        wasm.extendedepochinfo_set_first_block_height(this.__wbg_ptr, first_block_height);
    }
    /**
     * @returns {bigint}
     */
    get feeMultiplierPermille() {
        const ret = wasm.extendedepochinfo_fee_multiplier_permille(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {number}
     */
    get firstCoreBlockHeight() {
        const ret = wasm.extendedepochinfo_first_core_block_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {bigint} fee_multiplier_permille
     */
    set feeMultiplierPermille(fee_multiplier_permille) {
        wasm.extendedepochinfo_set_fee_multiplier_permille(this.__wbg_ptr, fee_multiplier_permille);
    }
    /**
     * @param {number} first_core_block_height
     */
    set firstCoreBlockHeight(first_core_block_height) {
        wasm.extendedepochinfo_set_first_core_block_height(this.__wbg_ptr, first_core_block_height);
    }
    /**
     * @param {number} index
     * @param {bigint} first_block_time
     * @param {bigint} first_block_height
     * @param {number} first_core_block_height
     * @param {bigint} fee_multiplier_permille
     * @param {number} protocol_version
     */
    constructor(index, first_block_time, first_block_height, first_core_block_height, fee_multiplier_permille, protocol_version) {
        const ret = wasm.extendedepochinfo_new(index, first_block_time, first_block_height, first_core_block_height, fee_multiplier_permille, protocol_version);
        this.__wbg_ptr = ret >>> 0;
        ExtendedEpochInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    get index() {
        const ret = wasm.extendedepochinfo_index(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.extendedepochinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ExtendedEpochInfo}
     */
    static fromJSON(js) {
        const ret = wasm.extendedepochinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExtendedEpochInfo.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     */
    set index(index) {
        wasm.extendedepochinfo_set_index(this.__wbg_ptr, index);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.extendedepochinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.extendedepochinfo_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const FeeStrategyStepFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_feestrategystep_free(ptr >>> 0, 1));
/**
 * Defines how fees are paid in address-based state transitions.
 *
 * Fee strategy is a sequence of steps that determine which inputs or outputs
 * should be reduced to cover the transaction fee.
 */
export class FeeStrategyStep {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FeeStrategyStep.prototype);
        obj.__wbg_ptr = ptr;
        FeeStrategyStepFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FeeStrategyStepFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_feestrategystep_free(ptr, 0);
    }
    /**
     * Creates a step that reduces the output at the given index by the fee amount.
     *
     * The output amount will be reduced to cover the fee.
     *
     * @param index - The index of the output address to reduce
     * @param {number} index
     * @returns {FeeStrategyStep}
     */
    static reduceOutput(index) {
        const ret = wasm.feestrategystep_reduceOutput(index);
        return FeeStrategyStep.__wrap(ret);
    }
    /**
     * Returns true if this step reduces an output.
     * @returns {boolean}
     */
    get isReduceOutput() {
        const ret = wasm.feestrategystep_isReduceOutput(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Creates a step that deducts the fee from the input at the given index.
     *
     * The input must have remaining balance after its contribution to outputs.
     *
     * @param index - The index of the input address to deduct fee from
     * @param {number} index
     * @returns {FeeStrategyStep}
     */
    static deductFromInput(index) {
        const ret = wasm.feestrategystep_deductFromInput(index);
        return FeeStrategyStep.__wrap(ret);
    }
    /**
     * Returns true if this step deducts from an input.
     * @returns {boolean}
     */
    get isDeductFromInput() {
        const ret = wasm.feestrategystep_isDeductFromInput(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Returns the index associated with this step.
     * @returns {number}
     */
    get index() {
        const ret = wasm.feestrategystep_index(this.__wbg_ptr);
        return ret;
    }
}

const FinalizedEpochInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_finalizedepochinfo_free(ptr >>> 0, 1));

export class FinalizedEpochInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FinalizedEpochInfo.prototype);
        obj.__wbg_ptr = ptr;
        FinalizedEpochInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FinalizedEpochInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_finalizedepochinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {FinalizedEpochInfo}
     */
    static fromObject(obj) {
        const ret = wasm.finalizedepochinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return FinalizedEpochInfo.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.finalizedepochinfo_struct_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get feeMultiplier() {
        const ret = wasm.finalizedepochinfo_fee_multiplier(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    get blockProposers() {
        const ret = wasm.finalizedepochinfo_block_proposers(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get firstBlockTime() {
        const ret = wasm.finalizedepochinfo_first_block_time(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    get protocolVersion() {
        const ret = wasm.finalizedepochinfo_protocol_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {bigint}
     */
    get coreBlockRewards() {
        const ret = wasm.finalizedepochinfo_core_block_rewards(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    get firstBlockHeight() {
        const ret = wasm.finalizedepochinfo_first_block_height(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} block_proposers
     */
    set blockProposers(block_proposers) {
        const ret = wasm.finalizedepochinfo_set_block_proposers(this.__wbg_ptr, block_proposers);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {bigint} first_block_time
     */
    set firstBlockTime(first_block_time) {
        wasm.finalizedepochinfo_set_first_block_time(this.__wbg_ptr, first_block_time);
    }
    /**
     * @param {number} protocol_version
     */
    set protocolVersion(protocol_version) {
        wasm.finalizedepochinfo_set_protocol_version(this.__wbg_ptr, protocol_version);
    }
    /**
     * @returns {bigint}
     */
    get totalBlocksInEpoch() {
        const ret = wasm.finalizedepochinfo_total_blocks_in_epoch(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    get totalProcessingFees() {
        const ret = wasm.finalizedepochinfo_total_processing_fees(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} core_block_rewards
     */
    set coreBlockRewards(core_block_rewards) {
        wasm.finalizedepochinfo_set_core_block_rewards(this.__wbg_ptr, core_block_rewards);
    }
    /**
     * @param {bigint} first_block_height
     */
    set firstBlockHeight(first_block_height) {
        wasm.finalizedepochinfo_set_first_block_height(this.__wbg_ptr, first_block_height);
    }
    /**
     * @returns {bigint}
     */
    get feeMultiplierPermille() {
        const ret = wasm.finalizedepochinfo_fee_multiplier_permille(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {number}
     */
    get firstCoreBlockHeight() {
        const ret = wasm.finalizedepochinfo_first_core_block_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {bigint} total_blocks_in_epoch
     */
    set totalBlocksInEpoch(total_blocks_in_epoch) {
        wasm.finalizedepochinfo_set_total_blocks_in_epoch(this.__wbg_ptr, total_blocks_in_epoch);
    }
    /**
     * @param {bigint} total_processing_fees
     */
    set totalProcessingFees(total_processing_fees) {
        wasm.finalizedepochinfo_set_total_processing_fees(this.__wbg_ptr, total_processing_fees);
    }
    /**
     * @returns {bigint}
     */
    get totalCreatedStorageFees() {
        const ret = wasm.finalizedepochinfo_total_created_storage_fees(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} fee_multiplier_permille
     */
    set feeMultiplierPermille(fee_multiplier_permille) {
        wasm.finalizedepochinfo_set_fee_multiplier_permille(this.__wbg_ptr, fee_multiplier_permille);
    }
    /**
     * @param {number} first_core_block_height
     */
    set firstCoreBlockHeight(first_core_block_height) {
        wasm.finalizedepochinfo_set_first_core_block_height(this.__wbg_ptr, first_core_block_height);
    }
    /**
     * @param {bigint} total_created_storage_fees
     */
    set totalCreatedStorageFees(total_created_storage_fees) {
        wasm.finalizedepochinfo_set_total_created_storage_fees(this.__wbg_ptr, total_created_storage_fees);
    }
    /**
     * @returns {bigint}
     */
    get totalDistributedStorageFees() {
        const ret = wasm.finalizedepochinfo_total_distributed_storage_fees(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    get nextEpochStartCoreBlockHeight() {
        const ret = wasm.finalizedepochinfo_next_epoch_start_core_block_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {bigint} total_distributed_storage_fees
     */
    set totalDistributedStorageFees(total_distributed_storage_fees) {
        wasm.finalizedepochinfo_set_total_distributed_storage_fees(this.__wbg_ptr, total_distributed_storage_fees);
    }
    /**
     * @param {number} next_epoch_start_core_block_height
     */
    set nextEpochStartCoreBlockHeight(next_epoch_start_core_block_height) {
        wasm.finalizedepochinfo_set_next_epoch_start_core_block_height(this.__wbg_ptr, next_epoch_start_core_block_height);
    }
    /**
     * @param {bigint} first_block_time
     * @param {bigint} first_block_height
     * @param {bigint} total_blocks_in_epoch
     * @param {number} first_core_block_height
     * @param {number} next_epoch_start_core_block_height
     * @param {bigint} total_processing_fees
     * @param {bigint} total_distributed_storage_fees
     * @param {bigint} total_created_storage_fees
     * @param {bigint} core_block_rewards
     * @param {any} block_proposers
     * @param {bigint} fee_multiplier_permille
     * @param {number} protocol_version
     */
    constructor(first_block_time, first_block_height, total_blocks_in_epoch, first_core_block_height, next_epoch_start_core_block_height, total_processing_fees, total_distributed_storage_fees, total_created_storage_fees, core_block_rewards, block_proposers, fee_multiplier_permille, protocol_version) {
        const ret = wasm.finalizedepochinfo_new(first_block_time, first_block_height, total_blocks_in_epoch, first_core_block_height, next_epoch_start_core_block_height, total_processing_fees, total_distributed_storage_fees, total_created_storage_fees, core_block_rewards, block_proposers, fee_multiplier_permille, protocol_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        FinalizedEpochInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.finalizedepochinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {FinalizedEpochInfo}
     */
    static fromJSON(js) {
        const ret = wasm.finalizedepochinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return FinalizedEpochInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.finalizedepochinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.finalizedepochinfo_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GroupFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_group_free(ptr >>> 0, 1));

export class Group {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Group.prototype);
        obj.__wbg_ptr = ptr;
        GroupFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GroupFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_group_free(ptr, 0);
    }
    /**
     * @param {any} js_value
     * @returns {Group}
     */
    static fromObject(js_value) {
        const ret = wasm.group_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Group.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    get members() {
        const ret = wasm.group_get_members(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_members
     */
    set members(js_members) {
        const ret = wasm.group_set_members(this.__wbg_ptr, js_members);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.group_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get requiredPower() {
        const ret = wasm.group_get_required_power(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} required_power
     */
    set requiredPower(required_power) {
        wasm.group_set_required_power(this.__wbg_ptr, required_power);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_member
     * @param {number} member_required_power
     */
    setMemberRequiredPower(js_member, member_required_power) {
        const ret = wasm.group_setMemberRequiredPower(this.__wbg_ptr, js_member, member_required_power);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_members
     * @param {number} required_power
     */
    constructor(js_members, required_power) {
        const ret = wasm.group_new(js_members, required_power);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        GroupFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.group_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_value
     * @returns {Group}
     */
    static fromJSON(js_value) {
        const ret = wasm.group_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Group.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.group_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.group_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GroupActionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_groupaction_free(ptr >>> 0, 1));

export class GroupAction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GroupAction.prototype);
        obj.__wbg_ptr = ptr;
        GroupActionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GroupActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_groupaction_free(ptr, 0);
    }
    /**
     * @returns {Identifier}
     */
    get contractId() {
        const ret = wasm.groupaction_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {any} obj
     * @returns {GroupAction}
     */
    static fromObject(obj) {
        const ret = wasm.groupaction_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GroupAction.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier}
     */
    get proposerId() {
        const ret = wasm.groupaction_proposer_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupaction_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get tokenContractPosition() {
        const ret = wasm.groupaction_token_contract_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {GroupActionEvent}
     */
    get event() {
        const ret = wasm.groupaction_event(this.__wbg_ptr);
        return GroupActionEvent.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.groupaction_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {GroupAction}
     */
    static fromJSON(js) {
        const ret = wasm.groupaction_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GroupAction.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.groupaction_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupaction_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GroupActionEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_groupactionevent_free(ptr >>> 0, 1));

export class GroupActionEvent {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GroupActionEvent.prototype);
        obj.__wbg_ptr = ptr;
        GroupActionEventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GroupActionEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_groupactionevent_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    eventName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupactionevent_eventName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} obj
     * @returns {GroupActionEvent}
     */
    static fromObject(obj) {
        const ret = wasm.groupactionevent_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GroupActionEvent.__wrap(ret[0]);
    }
    /**
     * @returns {string | undefined}
     */
    publicNote() {
        const ret = wasm.groupactionevent_publicNote(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {string}
     */
    get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupactionevent_struct_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {TokenEvent}
     */
    tokenEvent() {
        const ret = wasm.groupactionevent_tokenEvent(this.__wbg_ptr);
        return TokenEvent.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.groupactionevent_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {GroupActionEventVariant}
     */
    get variant() {
        const ret = wasm.groupactionevent_variant(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} js
     * @returns {GroupActionEvent}
     */
    static fromJSON(js) {
        const ret = wasm.groupactionevent_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GroupActionEvent.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.groupactionevent_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupactionevent_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GroupStateTransitionInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_groupstatetransitioninfo_free(ptr >>> 0, 1));

export class GroupStateTransitionInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GroupStateTransitionInfo.prototype);
        obj.__wbg_ptr = ptr;
        GroupStateTransitionInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GroupStateTransitionInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_groupstatetransitioninfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupstatetransitioninfo_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get actionId() {
        const ret = wasm.groupstatetransitioninfo_get_action_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} action_id
     */
    set actionId(action_id) {
        const ret = wasm.groupstatetransitioninfo_set_action_id(this.__wbg_ptr, action_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {boolean}
     */
    get actionIsProposer() {
        const ret = wasm.groupstatetransitioninfo_get_action_is_proposer(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} action_is_proposer
     */
    set actionIsProposer(action_is_proposer) {
        wasm.groupstatetransitioninfo_set_action_is_proposer(this.__wbg_ptr, action_is_proposer);
    }
    /**
     * @returns {number}
     */
    get groupContractPosition() {
        const ret = wasm.groupstatetransitioninfo_get_group_contract_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} group_contract_position
     */
    set groupContractPosition(group_contract_position) {
        wasm.groupstatetransitioninfo_set_group_contract_position(this.__wbg_ptr, group_contract_position);
    }
    /**
     * @param {number} group_contract_position
     * @param {Identifier | Uint8Array | string} action_id
     * @param {boolean} action_is_proposer
     */
    constructor(group_contract_position, action_id, action_is_proposer) {
        const ret = wasm.groupstatetransitioninfo_new(group_contract_position, action_id, action_is_proposer);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        GroupStateTransitionInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupstatetransitioninfo_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GroupStateTransitionInfoStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_groupstatetransitioninfostatus_free(ptr >>> 0, 1));
/**
 * Wrapper for GroupStateTransitionInfoStatus enum.
 *
 * This represents the group action context for a state transition:
 * - Proposer: The identity proposing a new group action
 * - OtherSigner: The identity signing/voting on an existing group action
 */
export class GroupStateTransitionInfoStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GroupStateTransitionInfoStatus.prototype);
        obj.__wbg_ptr = ptr;
        GroupStateTransitionInfoStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GroupStateTransitionInfoStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_groupstatetransitioninfostatus_free(ptr, 0);
    }
    /**
     * Check if this is a proposer status.
     * @returns {boolean}
     */
    get isProposer() {
        const ret = wasm.groupstatetransitioninfostatus_is_proposer(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupstatetransitioninfostatus_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Create a new other signer status for voting on an existing group action.
     *
     * Use this when the identity is signing/voting on an action proposed by someone else.
     *
     * @param groupContractPosition - The position of the group in the contract
     * @param actionId - The ID of the action being voted on
     * @returns GroupStateTransitionInfoStatus for an other signer
     * @param {number} group_contract_position
     * @param {Identifier | Uint8Array | string} action_id
     * @returns {GroupStateTransitionInfoStatus}
     */
    static otherSigner(group_contract_position, action_id) {
        const ret = wasm.groupstatetransitioninfostatus_otherSigner(group_contract_position, action_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GroupStateTransitionInfoStatus.__wrap(ret[0]);
    }
    /**
     * Get the group contract position.
     * @returns {number}
     */
    get groupContractPosition() {
        const ret = wasm.groupstatetransitioninfostatus_group_contract_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * Convert to GroupStateTransitionInfo.
     * @returns {GroupStateTransitionInfo}
     */
    toInfo() {
        const ret = wasm.groupstatetransitioninfostatus_toInfo(this.__wbg_ptr);
        return GroupStateTransitionInfo.__wrap(ret);
    }
    /**
     * Create a new proposer status for initiating a group action.
     *
     * Use this when the identity is proposing a new group action.
     *
     * @param groupContractPosition - The position of the group in the contract
     * @returns GroupStateTransitionInfoStatus for a proposer
     * @param {number} group_contract_position
     * @returns {GroupStateTransitionInfoStatus}
     */
    static proposer(group_contract_position) {
        const ret = wasm.groupstatetransitioninfostatus_proposer(group_contract_position);
        return GroupStateTransitionInfoStatus.__wrap(ret);
    }
    /**
     * Get the action ID (only available for other signer status).
     * Returns null for proposer status.
     * @returns {Identifier | undefined}
     */
    get actionId() {
        const ret = wasm.groupstatetransitioninfostatus_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.groupstatetransitioninfostatus_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentifierFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identifier_free(ptr >>> 0, 1));

export class Identifier {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Identifier.prototype);
        obj.__wbg_ptr = ptr;
        IdentifierFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentifierFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identifier_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {Identifier}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identifier_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @param {string} base58
     * @returns {Identifier}
     */
    static fromBase58(base58) {
        const ptr0 = passStringToWasm0(base58, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identifier_fromBase58(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {Identifier}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identifier_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns the identifier as a Base58 string.
     * This is the default string representation for JavaScript.
     * @returns {string}
     */
    toString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} identifier
     */
    constructor(identifier) {
        const ret = wasm.identifier_new(identifier);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentifierFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_toHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns the identifier as a Base58 string for JSON serialization.
     * This method is called automatically when the object is serialized to JSON.
     * @returns {string}
     */
    toJSON() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_toJSON(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} hex
     * @returns {Identifier}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identifier_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identifier_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {string}
     */
    toBase58() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_toBase58(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_toBase64(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identifier_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identity_free(ptr >>> 0, 1));

export class Identity {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Identity.prototype);
        obj.__wbg_ptr = ptr;
        IdentityFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identity_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {Identity}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identity_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identity.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {Identity}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identity_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identity.__wrap(ret[0]);
    }
    /**
     * @param {any} js_value
     * @returns {Identity}
     */
    static fromObject(js_value) {
        const ret = wasm.identity_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identity.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get balance() {
        const ret = wasm.identity_get_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} balance
     */
    set balance(balance) {
        wasm.identity_set_balance(this.__wbg_ptr, balance);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identity_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get revision() {
        const ret = wasm.identity_get_revision(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} revision
     */
    set revision(revision) {
        wasm.identity_set_revision(this.__wbg_ptr, revision);
    }
    /**
     * @param {IdentityPublicKey} public_key
     */
    addPublicKey(public_key) {
        _assertClass(public_key, IdentityPublicKey);
        wasm.identity_addPublicKey(this.__wbg_ptr, public_key.__wbg_ptr);
    }
    /**
     * @returns {IdentityPublicKey[]}
     */
    getPublicKeys() {
        const ret = wasm.identity_getPublicKeys(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {number} key_id
     * @returns {IdentityPublicKey | undefined}
     */
    getPublicKeyById(key_id) {
        const ret = wasm.identity_getPublicKeyById(this.__wbg_ptr, key_id);
        return ret === 0 ? undefined : IdentityPublicKey.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identifier
     */
    constructor(js_identifier) {
        const ret = wasm.identity_new(js_identifier);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.identity_get_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identifier
     */
    set id(js_identifier) {
        const ret = wasm.identity_set_id(this.__wbg_ptr, js_identifier);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identity_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identity_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {Identity}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identity_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identity.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identity_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js_value
     * @returns {Identity}
     */
    static fromJSON(js_value) {
        const ret = wasm.identity_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identity.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identity_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identity_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identity_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityBalanceAndRevisionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitybalanceandrevision_free(ptr >>> 0, 1));

export class IdentityBalanceAndRevision {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityBalanceAndRevision.prototype);
        obj.__wbg_ptr = ptr;
        IdentityBalanceAndRevisionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityBalanceAndRevisionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitybalanceandrevision_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {IdentityBalanceAndRevision}
     */
    static fromObject(obj) {
        const ret = wasm.identitybalanceandrevision_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityBalanceAndRevision.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get balance() {
        const ret = wasm.identitybalanceandrevision_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitybalanceandrevision_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get revision() {
        const ret = wasm.identitybalanceandrevision_revision(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {any} js
     * @returns {IdentityBalanceAndRevision}
     */
    static fromJSON(js) {
        const ret = wasm.identitybalanceandrevision_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityBalanceAndRevision.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitybalanceandrevision_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const IdentityContractKeysFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycontractkeys_free(ptr >>> 0, 1));

export class IdentityContractKeys {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityContractKeys.prototype);
        obj.__wbg_ptr = ptr;
        IdentityContractKeysFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityContractKeysFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycontractkeys_free(ptr, 0);
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.identitycontractkeys_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {IdentityPublicKey[]}
     */
    get keys() {
        const ret = wasm.identitycontractkeys_keys(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
}

const IdentityCreateFromAddressesResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycreatefromaddressesresult_free(ptr >>> 0, 1));
/**
 * Result of creating an identity from Platform addresses.
 */
export class IdentityCreateFromAddressesResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityCreateFromAddressesResult.prototype);
        obj.__wbg_ptr = ptr;
        IdentityCreateFromAddressesResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreateFromAddressesResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycreatefromaddressesresult_free(ptr, 0);
    }
    /**
     * Map of addresses to their updated info after the identity creation.
     * @returns {Map<any, any>}
     */
    get addressInfos() {
        const ret = wasm.identitycreatefromaddressesresult_address_infos(this.__wbg_ptr);
        return ret;
    }
    /**
     * The newly created identity.
     * @returns {Identity}
     */
    get identity() {
        const ret = wasm.identitycreatefromaddressesresult_identity(this.__wbg_ptr);
        return Identity.__wrap(ret);
    }
}

const IdentityCreateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycreatetransition_free(ptr >>> 0, 1));

export class IdentityCreateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityCreateTransition.prototype);
        obj.__wbg_ptr = ptr;
        IdentityCreateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycreatetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityCreateTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreatetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {IdentityCreateTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreatetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {IdentityCreateTransition}
     */
    static fromObject(obj) {
        const ret = wasm.identitycreatetransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycreatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identitycreatetransition_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitycreatetransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    getIdentifier() {
        const ret = wasm.identitycreatetransition_getIdentifier(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {IdentityPublicKeyInCreation[]}
     */
    get publicKeys() {
        const ret = wasm.identitycreatetransition_get_public_keys(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Array<any>} js_public_keys
     */
    set publicKeys(js_public_keys) {
        const ret = wasm.identitycreatetransition_set_public_keys(this.__wbg_ptr, js_public_keys);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.identitycreatetransition_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.identitycreatetransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @returns {AssetLockProof}
     */
    get assetLock() {
        const ret = wasm.identitycreatetransition_get_asset_lock_proof(this.__wbg_ptr);
        return AssetLockProof.__wrap(ret);
    }
    /**
     * @param {AssetLockProof} proof
     */
    set assetLock(proof) {
        _assertClass(proof, AssetLockProof);
        var ptr0 = proof.__destroy_into_raw();
        const ret = wasm.identitycreatetransition_set_asset_lock_proof(this.__wbg_ptr, ptr0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {StateTransition} st
     * @returns {IdentityCreateTransition}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.identitycreatetransition_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.identitycreatetransition_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} amount
     */
    set userFeeIncrease(amount) {
        wasm.identitycreatetransition_set_user_fee_increase(this.__wbg_ptr, amount);
    }
    /**
     * @param {Array<any>} js_public_keys
     * @param {AssetLockProof} asset_lock
     * @param {Uint8Array | null} [signature]
     * @param {number | null} [user_fee_increase]
     */
    constructor(js_public_keys, asset_lock, signature, user_fee_increase) {
        _assertClass(asset_lock, AssetLockProof);
        var ptr0 = isLikeNone(signature) ? 0 : passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreatetransition_new(js_public_keys, asset_lock.__wbg_ptr, ptr0, len0, isLikeNone(user_fee_increase) ? 0xFFFFFF : user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityCreateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycreatetransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {any} js_platform_version
     * @returns {IdentityCreateTransition}
     */
    static default(js_platform_version) {
        const ret = wasm.identitycreatetransition_default(js_platform_version);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitycreatetransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {IdentityCreateTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreatetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identitycreatetransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {IdentityCreateTransition}
     */
    static fromJSON(js) {
        const ret = wasm.identitycreatetransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycreatetransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitycreatetransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycreatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityCreditTransferFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycredittransfer_free(ptr >>> 0, 1));

export class IdentityCreditTransfer {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityCreditTransfer.prototype);
        obj.__wbg_ptr = ptr;
        IdentityCreditTransferFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreditTransferFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycredittransfer_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityCreditTransfer}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycredittransfer_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.identitycredittransfer_get_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} amount
     */
    set amount(amount) {
        wasm.identitycredittransfer_set_amount(this.__wbg_ptr, amount);
    }
    /**
     * @param {string} hex
     * @returns {IdentityCreditTransfer}
     */
    static fromBase64(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycredittransfer_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycredittransfer_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identitycredittransfer_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Identifier | Uint8Array | string} js_sender
     */
    set senderId(js_sender) {
        const ret = wasm.identitycredittransfer_set_sender_id(this.__wbg_ptr, js_sender);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitycredittransfer_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get senderId() {
        const ret = wasm.identitycredittransfer_get_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {Identifier}
     */
    get recipientId() {
        const ret = wasm.identitycredittransfer_get_recipient_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_recipient
     */
    set recipientId(js_recipient) {
        const ret = wasm.identitycredittransfer_set_recipient_id(this.__wbg_ptr, js_recipient);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.identitycredittransfer_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.identitycredittransfer_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} st
     * @returns {IdentityCreditTransfer}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.identitycredittransfer_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.identitycredittransfer_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} amount
     */
    set userFeeIncrease(amount) {
        wasm.identitycredittransfer_set_user_fee_increase(this.__wbg_ptr, amount);
    }
    /**
     * @returns {number}
     */
    get signaturePublicKeyId() {
        const ret = wasm.identitycredittransfer_get_signature_public_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} public_key_id
     */
    set signaturePublicKeyId(public_key_id) {
        wasm.identitycredittransfer_set_signature_public_key_id(this.__wbg_ptr, public_key_id);
    }
    /**
     * @param {bigint} amount
     * @param {Identifier | Uint8Array | string} js_sender
     * @param {Identifier | Uint8Array | string} js_recipient
     * @param {bigint} nonce
     * @param {number | null} [user_fee_increase]
     */
    constructor(amount, js_sender, js_recipient, nonce, user_fee_increase) {
        const ret = wasm.identitycredittransfer_new(amount, js_sender, js_recipient, nonce, isLikeNone(user_fee_increase) ? 0xFFFFFF : user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityCreditTransferFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycredittransfer_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {string} hex
     * @returns {IdentityCreditTransfer}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycredittransfer_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identitycredittransfer_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {bigint}
     */
    get nonce() {
        const ret = wasm.identitycredittransfer_get_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} nonce
     */
    set nonce(nonce) {
        wasm.identitycredittransfer_set_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycredittransfer_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycredittransfer_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityCreditTransferResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycredittransferresult_free(ptr >>> 0, 1));
/**
 * Result of transferring credits between identities.
 */
export class IdentityCreditTransferResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityCreditTransferResult.prototype);
        obj.__wbg_ptr = ptr;
        IdentityCreditTransferResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreditTransferResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycredittransferresult_free(ptr, 0);
    }
    /**
     * Balance of the sender identity after the transfer.
     * @returns {bigint}
     */
    get senderBalance() {
        const ret = wasm.identitycredittransferresult_sender_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * Balance of the recipient identity after the transfer.
     * @returns {bigint}
     */
    get recipientBalance() {
        const ret = wasm.identitycredittransferresult_recipient_balance(this.__wbg_ptr);
        return ret;
    }
}

const IdentityCreditTransferTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycredittransfertransition_free(ptr >>> 0, 1));

export class IdentityCreditTransferTransition {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreditTransferTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycredittransfertransition_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {IdentityCreditTransfer}
     */
    static fromObject(obj) {
        const ret = wasm.identitycredittransfertransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitycredittransfertransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {IdentityCreditTransfer}
     */
    static fromJSON(js) {
        const ret = wasm.identitycredittransfertransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditTransfer.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitycredittransfertransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const IdentityCreditWithdrawalTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitycreditwithdrawaltransition_free(ptr >>> 0, 1));

export class IdentityCreditWithdrawalTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityCreditWithdrawalTransition.prototype);
        obj.__wbg_ptr = ptr;
        IdentityCreditWithdrawalTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityCreditWithdrawalTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitycreditwithdrawaltransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreditwithdrawaltransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.identitycreditwithdrawaltransition_get_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} amount
     */
    set amount(amount) {
        wasm.identitycreditwithdrawaltransition_set_amount(this.__wbg_ptr, amount);
    }
    /**
     * @param {string} base64
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreditwithdrawaltransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromObject(obj) {
        const ret = wasm.identitycreditwithdrawaltransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get pooling() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycreditwithdrawaltransition_get_pooling(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_pooling
     */
    set pooling(js_pooling) {
        const ret = wasm.identitycreditwithdrawaltransition_set_pooling(this.__wbg_ptr, js_pooling);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycreditwithdrawaltransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identitycreditwithdrawaltransition_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitycreditwithdrawaltransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.identitycreditwithdrawaltransition_get_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     */
    set identityId(js_identity_id) {
        const ret = wasm.identitycreditwithdrawaltransition_set_identity_id(this.__wbg_ptr, js_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {CoreScript | undefined}
     */
    get outputScript() {
        const ret = wasm.identitycreditwithdrawaltransition_get_output_script(this.__wbg_ptr);
        return ret === 0 ? undefined : CoreScript.__wrap(ret);
    }
    /**
     * @param {any} js_script
     */
    set outputScript(js_script) {
        const ret = wasm.identitycreditwithdrawaltransition_set_output_script(this.__wbg_ptr, js_script);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.identitycreditwithdrawaltransition_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.identitycreditwithdrawaltransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} st
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.identitycreditwithdrawaltransition_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get coreFeePerByte() {
        const ret = wasm.identitycreditwithdrawaltransition_get_core_fee_per_byte(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {Identifier[]}
     */
    getModifiedDataIds() {
        const ret = wasm.identitycreditwithdrawaltransition_getModifiedDataIds(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.identitycreditwithdrawaltransition_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} fee_per_byte
     */
    set coreFeePerByte(fee_per_byte) {
        wasm.identitycreditwithdrawaltransition_set_core_fee_per_byte(this.__wbg_ptr, fee_per_byte);
    }
    /**
     * @param {number} user_fee_increase
     */
    set userFeeIncrease(user_fee_increase) {
        wasm.identitycreditwithdrawaltransition_set_user_fee_increase(this.__wbg_ptr, user_fee_increase);
    }
    /**
     * @returns {string[]}
     */
    getPurposeRequirement() {
        const ret = wasm.identitycreditwithdrawaltransition_getPurposeRequirement(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    get signaturePublicKeyId() {
        const ret = wasm.identitycreditwithdrawaltransition_get_signature_public_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} signature_public_key_id
     */
    set signaturePublicKeyId(signature_public_key_id) {
        wasm.identitycreditwithdrawaltransition_set_signature_public_key_id(this.__wbg_ptr, signature_public_key_id);
    }
    /**
     * @returns {any}
     */
    getOptionalAssetLockProof() {
        const ret = wasm.identitycreditwithdrawaltransition_getOptionalAssetLockProof(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @param {bigint} amount
     * @param {number} core_fee_per_byte
     * @param {any} js_pooling
     * @param {any} js_output_script
     * @param {bigint | null} [nonce]
     * @param {number | null} [user_fee_increase]
     */
    constructor(js_identity_id, amount, core_fee_per_byte, js_pooling, js_output_script, nonce, user_fee_increase) {
        const ret = wasm.identitycreditwithdrawaltransition_new(js_identity_id, amount, core_fee_per_byte, js_pooling, js_output_script, !isLikeNone(nonce), isLikeNone(nonce) ? BigInt(0) : nonce, isLikeNone(user_fee_increase) ? 0xFFFFFF : user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityCreditWithdrawalTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycreditwithdrawaltransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitycreditwithdrawaltransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitycreditwithdrawaltransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identitycreditwithdrawaltransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {IdentityCreditWithdrawalTransition}
     */
    static fromJSON(js) {
        const ret = wasm.identitycreditwithdrawaltransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityCreditWithdrawalTransition.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get nonce() {
        const ret = wasm.identitycreditwithdrawaltransition_get_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} nonce
     */
    set nonce(nonce) {
        wasm.identitycreditwithdrawaltransition_set_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitycreditwithdrawaltransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitycreditwithdrawaltransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitycreditwithdrawaltransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityGroupInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitygroupinfo_free(ptr >>> 0, 1));

export class IdentityGroupInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityGroupInfo.prototype);
        obj.__wbg_ptr = ptr;
        IdentityGroupInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityGroupInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitygroupinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get dataContractId() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitygroupinfo_data_contract_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get groupContractPosition() {
        const ret = wasm.identitygroupinfo_group_contract_position(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {string}
     */
    get role() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitygroupinfo_role(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get power() {
        const ret = wasm.identitygroupinfo_power(this.__wbg_ptr);
        return ret;
    }
}

const IdentityPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitypublickey_free(ptr >>> 0, 1));

export class IdentityPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        IdentityPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitypublickey_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityPublicKey}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get keyId() {
        const ret = wasm.identitypublickey_get_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} key_id
     */
    set keyId(key_id) {
        wasm.identitypublickey_set_key_id(this.__wbg_ptr, key_id);
    }
    /**
     * @param {string} hex
     * @returns {IdentityPublicKey}
     */
    static fromBase64(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * Deserialize from JS object (non-human-readable).
     *
     * Uses platform_value conversion which properly handles the tagged enum.
     * @param {any} js_value
     * @returns {IdentityPublicKey}
     */
    static fromObject(js_value) {
        const ret = wasm.identitypublickey_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get purpose() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_get_purpose(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} purpose
     */
    set purpose(purpose) {
        const ret = wasm.identitypublickey_set_purpose(this.__wbg_ptr, purpose);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get keyType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_get_key_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} key_type
     */
    set keyType(key_type) {
        const ret = wasm.identitypublickey_set_key_type(this.__wbg_ptr, key_type);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {boolean}
     */
    get readOnly() {
        const ret = wasm.identitypublickey_get_read_only(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} read_only
     */
    set readOnly(read_only) {
        wasm.identitypublickey_set_read_only(this.__wbg_ptr, read_only);
    }
    /**
     * @returns {any}
     */
    getContractBounds() {
        const ret = wasm.identitypublickey_getContractBounds(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint | undefined}
     */
    get disabledAt() {
        const ret = wasm.identitypublickey_get_disabled_at(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {string}
     */
    getPublicKeyHash() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitypublickey_getPublicKeyHash(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {bigint} disabled_at
     */
    set disabledAt(disabled_at) {
        wasm.identitypublickey_set_disabled_at(this.__wbg_ptr, disabled_at);
    }
    /**
     * @returns {Purpose}
     */
    get purposeNumber() {
        const ret = wasm.identitypublickey_get_purpose_number(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get securityLevel() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_get_security_level(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} purpose
     */
    set purposeNumber(purpose) {
        const ret = wasm.identitypublickey_set_purpose_number(this.__wbg_ptr, purpose);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} security_level
     */
    set securityLevel(security_level) {
        const ret = wasm.identitypublickey_set_security_level(this.__wbg_ptr, security_level);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {KeyType}
     */
    get keyTypeNumber() {
        const ret = wasm.identitypublickey_get_key_type_number(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} key_type
     */
    set keyTypeNumber(key_type) {
        const ret = wasm.identitypublickey_set_key_type_number(this.__wbg_ptr, key_type);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {Uint8Array} js_private_key_bytes
     * @param {NetworkLike} network
     * @returns {boolean}
     */
    validatePrivateKey(js_private_key_bytes, network) {
        const ptr0 = passArray8ToWasm0(js_private_key_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_validatePrivateKey(this.__wbg_ptr, ptr0, len0, network);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * @returns {SecurityLevel}
     */
    get securityLevelNumber() {
        const ret = wasm.identitypublickey_get_security_level_number(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} security_level
     */
    set securityLevelNumber(security_level) {
        const ret = wasm.identitypublickey_set_security_level_number(this.__wbg_ptr, security_level);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {number} id
     * @param {any} js_purpose
     * @param {any} js_security_level
     * @param {any} js_key_type
     * @param {boolean} read_only
     * @param {string} binary_data
     * @param {bigint | null | undefined} disabled_at
     * @param {any} js_contract_bounds
     */
    constructor(id, js_purpose, js_security_level, js_key_type, read_only, binary_data, disabled_at, js_contract_bounds) {
        const ptr0 = passStringToWasm0(binary_data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_new(id, js_purpose, js_security_level, js_key_type, read_only, ptr0, len0, !isLikeNone(disabled_at), isLikeNone(disabled_at) ? BigInt(0) : disabled_at, js_contract_bounds);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityPublicKeyFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    hex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitypublickey_hex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Serialize to JSON-compatible JS object (human-readable).
     *
     * Uses serde_json conversion which properly handles the tagged enum
     * and serializes binary data as base64 strings.
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitypublickey_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {IdentityPublicKey}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get data() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_get_data(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} binary_data
     */
    set data(binary_data) {
        const ptr0 = passStringToWasm0(binary_data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickey_set_data(this.__wbg_ptr, ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identitypublickey_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * Deserialize from JSON-compatible JS object (human-readable).
     *
     * Uses serde_json conversion which properly handles the tagged enum
     * and deserializes base64 strings to binary data.
     * @param {any} js_value
     * @returns {IdentityPublicKey}
     */
    static fromJSON(js_value) {
        const ret = wasm.identitypublickey_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {boolean}
     */
    isMaster() {
        const ret = wasm.identitypublickey_isMaster(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {string}
     */
    base64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitypublickey_base64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Serialize to JS object (non-human-readable).
     *
     * Uses platform_value conversion which properly handles the tagged enum
     * and removes None fields like disabledAt.
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitypublickey_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickey_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityPublicKeyInCreationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitypublickeyincreation_free(ptr >>> 0, 1));

export class IdentityPublicKeyInCreation {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityPublicKeyInCreation.prototype);
        obj.__wbg_ptr = ptr;
        IdentityPublicKeyInCreationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityPublicKeyInCreationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitypublickeyincreation_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get keyId() {
        const ret = wasm.identitypublickeyincreation_get_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} key_id
     */
    set keyId(key_id) {
        wasm.identitypublickeyincreation_set_key_id(this.__wbg_ptr, key_id);
    }
    /**
     * @param {any} obj
     * @returns {IdentityPublicKeyInCreation}
     */
    static fromObject(obj) {
        const ret = wasm.identitypublickeyincreation_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKeyInCreation.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get purpose() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickeyincreation_get_purpose(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_purpose
     */
    set purpose(js_purpose) {
        const ret = wasm.identitypublickeyincreation_set_purpose(this.__wbg_ptr, js_purpose);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickeyincreation_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get keyType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickeyincreation_get_key_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} key_type
     */
    set keyType(key_type) {
        const ret = wasm.identitypublickeyincreation_set_key_type(this.__wbg_ptr, key_type);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {boolean}
     */
    get readOnly() {
        const ret = wasm.identitypublickeyincreation_get_read_only(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identitypublickeyincreation_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {boolean} read_only
     */
    set readOnly(read_only) {
        wasm.identitypublickeyincreation_set_read_only(this.__wbg_ptr, read_only);
    }
    /**
     * @param {Uint8Array} binary_data
     */
    set signature(binary_data) {
        const ptr0 = passArray8ToWasm0(binary_data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitypublickeyincreation_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get securityLevel() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickeyincreation_get_security_level(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_security_level
     */
    set securityLevel(js_security_level) {
        const ret = wasm.identitypublickeyincreation_set_security_level(this.__wbg_ptr, js_security_level);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {ContractBounds | undefined}
     */
    get contractBounds() {
        const ret = wasm.identitypublickeyincreation_get_contract_bounds(this.__wbg_ptr);
        return ret === 0 ? undefined : ContractBounds.__wrap(ret);
    }
    /**
     * @param {any} js_bounds
     */
    set contractBounds(js_bounds) {
        const ret = wasm.identitypublickeyincreation_set_contract_bounds(this.__wbg_ptr, js_bounds);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {IdentityPublicKey}
     */
    toIdentityPublicKey() {
        const ret = wasm.identitypublickeyincreation_toIdentityPublicKey(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {number} id
     * @param {any} js_purpose
     * @param {any} js_security_level
     * @param {any} js_key_type
     * @param {boolean} read_only
     * @param {Uint8Array} binary_data
     * @param {Uint8Array | null | undefined} signature
     * @param {any} js_contract_bounds
     */
    constructor(id, js_purpose, js_security_level, js_key_type, read_only, binary_data, signature, js_contract_bounds) {
        const ptr0 = passArray8ToWasm0(binary_data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(signature) ? 0 : passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.identitypublickeyincreation_new(id, js_purpose, js_security_level, js_key_type, read_only, ptr0, len0, ptr1, len1, js_contract_bounds);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityPublicKeyInCreationFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitypublickeyincreation_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get data() {
        const ret = wasm.identitypublickeyincreation_get_data(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {Uint8Array}
     */
    getHash() {
        const ret = wasm.identitypublickeyincreation_getHash(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} binary_data
     */
    set data(binary_data) {
        const ptr0 = passArray8ToWasm0(binary_data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitypublickeyincreation_set_data(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} js
     * @returns {IdentityPublicKeyInCreation}
     */
    static fromJSON(js) {
        const ret = wasm.identitypublickeyincreation_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityPublicKeyInCreation.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitypublickeyincreation_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitypublickeyincreation_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentitySignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitysigner_free(ptr >>> 0, 1));
/**
 * A signer for identity-based state transitions.
 *
 * Private keys are stored by their public key hash (20 bytes).
 * Both ECDSA_HASH160 and ECDSA_SECP256K1 keys are looked up by hash160.
 */
export class IdentitySigner {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentitySignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitysigner_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitysigner_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Adds a private key from WIF format.
     *
     * @param wif - The private key in WIF format
     * @param {string} wif
     */
    addKeyFromWif(wif) {
        const ptr0 = passStringToWasm0(wif, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitysigner_addKeyFromWif(this.__wbg_ptr, ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * Creates a new empty IdentitySigner.
     */
    constructor() {
        const ret = wasm.identitysigner_new();
        this.__wbg_ptr = ret >>> 0;
        IdentitySignerFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Adds a private key to the signer.
     *
     * The key is stored by public key hash (20 bytes): Hash160(compressed_public_key)
     *
     * @param privateKey - The PrivateKey object
     * @param {PrivateKey} private_key
     */
    addKey(private_key) {
        _assertClass(private_key, PrivateKey);
        const ret = wasm.identitysigner_addKey(this.__wbg_ptr, private_key.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * Returns the number of keys in this signer.
     * @returns {number}
     */
    get keyCount() {
        const ret = wasm.identitysigner_key_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitysigner_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityTokenInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitytokeninfo_free(ptr >>> 0, 1));

export class IdentityTokenInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityTokenInfo.prototype);
        obj.__wbg_ptr = ptr;
        IdentityTokenInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityTokenInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitytokeninfo_free(ptr, 0);
    }
    /**
     * @returns {boolean}
     */
    get frozen() {
        const ret = wasm.identitytokeninfo_frozen(this.__wbg_ptr);
        return ret !== 0;
    }
}

const IdentityTopUpFromAddressesResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitytopupfromaddressesresult_free(ptr >>> 0, 1));
/**
 * Result of topping up an identity from Platform addresses.
 */
export class IdentityTopUpFromAddressesResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityTopUpFromAddressesResult.prototype);
        obj.__wbg_ptr = ptr;
        IdentityTopUpFromAddressesResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityTopUpFromAddressesResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitytopupfromaddressesresult_free(ptr, 0);
    }
    /**
     * New balance of the identity after top up.
     * @returns {bigint}
     */
    get newBalance() {
        const ret = wasm.identitytopupfromaddressesresult_new_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * Map of addresses to their updated info after the top up.
     * @returns {Map<any, any>}
     */
    get addressInfos() {
        const ret = wasm.identitytopupfromaddressesresult_address_infos(this.__wbg_ptr);
        return ret;
    }
}

const IdentityTopUpTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitytopuptransition_free(ptr >>> 0, 1));

export class IdentityTopUpTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityTopUpTransition.prototype);
        obj.__wbg_ptr = ptr;
        IdentityTopUpTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityTopUpTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitytopuptransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityTopUpTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitytopuptransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {IdentityTopUpTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitytopuptransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {IdentityTopUpTransition}
     */
    static fromObject(obj) {
        const ret = wasm.identitytopuptransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitytopuptransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identitytopuptransition_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identitytopuptransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.identitytopuptransition_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.identitytopuptransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @returns {AssetLockProof}
     */
    get assetLockProof() {
        const ret = wasm.identitytopuptransition_get_asset_lock_proof(this.__wbg_ptr);
        return AssetLockProof.__wrap(ret);
    }
    /**
     * @param {AssetLockProof} asset_lock_proof
     */
    set assetLockProof(asset_lock_proof) {
        _assertClass(asset_lock_proof, AssetLockProof);
        const ret = wasm.identitytopuptransition_set_asset_lock_proof(this.__wbg_ptr, asset_lock_proof.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {StateTransition} st
     * @returns {IdentityTopUpTransition}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.identitytopuptransition_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier[]}
     */
    getModifiedDataIds() {
        const ret = wasm.identitytopuptransition_getModifiedDataIds(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.identitytopuptransition_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} user_fee_increase
     */
    set userFeeIncrease(user_fee_increase) {
        wasm.identitytopuptransition_set_user_fee_increase(this.__wbg_ptr, user_fee_increase);
    }
    /**
     * @returns {Identifier}
     */
    get identityIdentifier() {
        const ret = wasm.identitytopuptransition_get_identity_identifier(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_identifier
     */
    set identityIdentifier(js_identity_identifier) {
        const ret = wasm.identitytopuptransition_set_identity_identifier(this.__wbg_ptr, js_identity_identifier);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {any}
     */
    getOptionalAssetLockProof() {
        const ret = wasm.identitytopuptransition_getOptionalAssetLockProof(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {AssetLockProof} asset_lock_proof
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @param {number | null} [user_fee_increase]
     */
    constructor(asset_lock_proof, js_identity_id, user_fee_increase) {
        _assertClass(asset_lock_proof, AssetLockProof);
        const ret = wasm.identitytopuptransition_new(asset_lock_proof.__wbg_ptr, js_identity_id, isLikeNone(user_fee_increase) ? 0xFFFFFF : user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityTopUpTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitytopuptransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identitytopuptransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {IdentityTopUpTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identitytopuptransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identitytopuptransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {IdentityTopUpTransition}
     */
    static fromJSON(js) {
        const ret = wasm.identitytopuptransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityTopUpTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identitytopuptransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identitytopuptransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identitytopuptransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IdentityTransferToAddressesResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identitytransfertoaddressesresult_free(ptr >>> 0, 1));
/**
 * Result of transferring credits from an identity to Platform addresses.
 */
export class IdentityTransferToAddressesResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityTransferToAddressesResult.prototype);
        obj.__wbg_ptr = ptr;
        IdentityTransferToAddressesResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityTransferToAddressesResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitytransfertoaddressesresult_free(ptr, 0);
    }
    /**
     * New balance of the identity after transfer.
     * @returns {bigint}
     */
    get newBalance() {
        const ret = wasm.identitytransfertoaddressesresult_new_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * Map of addresses to their updated info after the transfer.
     * @returns {Map<any, any>}
     */
    get addressInfos() {
        const ret = wasm.identitytransfertoaddressesresult_address_infos(this.__wbg_ptr);
        return ret;
    }
}

const IdentityUpdateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_identityupdatetransition_free(ptr >>> 0, 1));

export class IdentityUpdateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IdentityUpdateTransition.prototype);
        obj.__wbg_ptr = ptr;
        IdentityUpdateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IdentityUpdateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identityupdatetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {IdentityUpdateTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identityupdatetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {IdentityUpdateTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identityupdatetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {IdentityUpdateTransition}
     */
    static fromObject(obj) {
        const ret = wasm.identityupdatetransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identityupdatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get revision() {
        const ret = wasm.identityupdatetransition_get_revision(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} revision
     */
    set revision(revision) {
        wasm.identityupdatetransition_set_revision(this.__wbg_ptr, revision);
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.identityupdatetransition_get_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identityupdatetransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.identityupdatetransition_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.identityupdatetransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @param {StateTransition} st
     * @returns {IdentityUpdateTransition}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.identityupdatetransition_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier[]}
     */
    getModifiedDataIds() {
        const ret = wasm.identityupdatetransition_getModifiedDataIds(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.identityupdatetransition_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} user_fee_increase
     */
    set userFeeIncrease(user_fee_increase) {
        wasm.identityupdatetransition_set_user_fee_increase(this.__wbg_ptr, user_fee_increase);
    }
    /**
     * @returns {Identifier}
     */
    get identityIdentifier() {
        const ret = wasm.identityupdatetransition_get_identity_identifier(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string[]}
     */
    getPurposeRequirement() {
        const ret = wasm.identityupdatetransition_getPurposeRequirement(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     */
    set identityIdentifier(js_identity_id) {
        const ret = wasm.identityupdatetransition_set_identity_identifier(this.__wbg_ptr, js_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {IdentityPublicKeyInCreation[]}
     */
    get publicKeyIdsToAdd() {
        const ret = wasm.identityupdatetransition_get_public_key_ids_to_add(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Array<any>} js_add_public_keys
     */
    set publicKeyIdsToAdd(js_add_public_keys) {
        const ret = wasm.identityupdatetransition_set_public_key_ids_to_add(this.__wbg_ptr, js_add_public_keys);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {number}
     */
    get signaturePublicKeyId() {
        const ret = wasm.identityupdatetransition_get_signature_public_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} signature_public_key_id
     */
    set signaturePublicKeyId(signature_public_key_id) {
        wasm.identityupdatetransition_set_signature_public_key_id(this.__wbg_ptr, signature_public_key_id);
    }
    /**
     * @returns {any}
     */
    getOptionalAssetLockProof() {
        const ret = wasm.identityupdatetransition_getOptionalAssetLockProof(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Uint32Array}
     */
    get publicKeyIdsToDisable() {
        const ret = wasm.identityupdatetransition_get_public_key_ids_to_disable(this.__wbg_ptr);
        var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Uint32Array} public_keys
     */
    set publicKeyIdsToDisable(public_keys) {
        const ptr0 = passArray32ToWasm0(public_keys, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.identityupdatetransition_set_public_key_ids_to_disable(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @param {bigint} revision
     * @param {bigint} nonce
     * @param {Array<any>} js_add_public_keys
     * @param {Uint32Array} disable_public_keys
     * @param {number | null} [user_fee_increase]
     */
    constructor(js_identity_id, revision, nonce, js_add_public_keys, disable_public_keys, user_fee_increase) {
        const ptr0 = passArray32ToWasm0(disable_public_keys, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identityupdatetransition_new(js_identity_id, revision, nonce, js_add_public_keys, ptr0, len0, isLikeNone(user_fee_increase) ? 0xFFFFFF : user_fee_increase);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        IdentityUpdateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identityupdatetransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.identityupdatetransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {IdentityUpdateTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.identityupdatetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.identityupdatetransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {IdentityUpdateTransition}
     */
    static fromJSON(js) {
        const ret = wasm.identityupdatetransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return IdentityUpdateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get nonce() {
        const ret = wasm.identityupdatetransition_get_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} nonce
     */
    set nonce(nonce) {
        wasm.identityupdatetransition_set_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.identityupdatetransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.identityupdatetransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.identityupdatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const InstantAssetLockProofFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_instantassetlockproof_free(ptr >>> 0, 1));

export class InstantAssetLockProof {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(InstantAssetLockProof.prototype);
        obj.__wbg_ptr = ptr;
        InstantAssetLockProofFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InstantAssetLockProofFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_instantassetlockproof_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    getOutput() {
        const ret = wasm.instantassetlockproof_getOutput(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {any} obj
     * @returns {InstantAssetLockProof}
     */
    static fromObject(obj) {
        const ret = wasm.instantassetlockproof_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InstantAssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.instantassetlockproof_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {OutPoint | undefined}
     */
    getOutPoint() {
        const ret = wasm.instantassetlockproof_getOutPoint(this.__wbg_ptr);
        return ret === 0 ? undefined : OutPoint.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    getTransaction() {
        const ret = wasm.instantassetlockproof_getTransaction(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {Uint8Array}
     */
    get instantLock() {
        const ret = wasm.instantassetlockproof_get_instant_lock(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {number}
     */
    get outputIndex() {
        const ret = wasm.instantassetlockproof_get_output_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {Uint8Array} instant_lock
     */
    set instantLock(instant_lock) {
        const ptr0 = passArray8ToWasm0(instant_lock, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.instantassetlockproof_set_instant_lock(this.__wbg_ptr, ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {number} output_index
     */
    set outputIndex(output_index) {
        wasm.instantassetlockproof_set_output_index(this.__wbg_ptr, output_index);
    }
    /**
     * @returns {Identifier}
     */
    createIdentityId() {
        const ret = wasm.instantassetlockproof_createIdentityId(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} instant_lock
     * @param {Uint8Array} transaction
     * @param {number} output_index
     */
    constructor(instant_lock, transaction, output_index) {
        const ptr0 = passArray8ToWasm0(instant_lock, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(transaction, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.instantassetlockproof_new(ptr0, len0, ptr1, len1, output_index);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        InstantAssetLockProofFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.instantassetlockproof_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {InstantAssetLockProof}
     */
    static fromJSON(js) {
        const ret = wasm.instantassetlockproof_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InstantAssetLockProof.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.instantassetlockproof_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.instantassetlockproof_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const IntoUnderlyingByteSourceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));

export class IntoUnderlyingByteSource {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntoUnderlyingByteSourceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_intounderlyingbytesource_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get autoAllocateChunkSize() {
        const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {ReadableByteStreamController} controller
     * @returns {Promise<any>}
     */
    pull(controller) {
        const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, controller);
        return ret;
    }
    /**
     * @param {ReadableByteStreamController} controller
     */
    start(controller) {
        wasm.intounderlyingbytesource_start(this.__wbg_ptr, controller);
    }
    /**
     * @returns {ReadableStreamType}
     */
    get type() {
        const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);
        return __wbindgen_enum_ReadableStreamType[ret];
    }
    cancel() {
        const ptr = this.__destroy_into_raw();
        wasm.intounderlyingbytesource_cancel(ptr);
    }
}

const IntoUnderlyingSinkFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));

export class IntoUnderlyingSink {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntoUnderlyingSinkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_intounderlyingsink_free(ptr, 0);
    }
    /**
     * @param {any} reason
     * @returns {Promise<any>}
     */
    abort(reason) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.intounderlyingsink_abort(ptr, reason);
        return ret;
    }
    /**
     * @returns {Promise<any>}
     */
    close() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.intounderlyingsink_close(ptr);
        return ret;
    }
    /**
     * @param {any} chunk
     * @returns {Promise<any>}
     */
    write(chunk) {
        const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, chunk);
        return ret;
    }
}

const IntoUnderlyingSourceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));

export class IntoUnderlyingSource {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntoUnderlyingSourceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_intounderlyingsource_free(ptr, 0);
    }
    /**
     * @param {ReadableStreamDefaultController} controller
     * @returns {Promise<any>}
     */
    pull(controller) {
        const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, controller);
        return ret;
    }
    cancel() {
        const ptr = this.__destroy_into_raw();
        wasm.intounderlyingsource_cancel(ptr);
    }
}

const KeyPairFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_keypair_free(ptr >>> 0, 1));

export class KeyPair {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KeyPair.prototype);
        obj.__wbg_ptr = ptr;
        KeyPairFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeyPairFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keypair_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {KeyPair}
     */
    static fromObject(obj) {
        const ret = wasm.keypair_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KeyPair.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.keypair_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {KeyPair}
     */
    static fromJSON(js) {
        const ret = wasm.keypair_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KeyPair.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.keypair_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get privateKeyWif() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_keypair_privateKeyWif(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyWif(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_keypair_privateKeyHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyHex(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_keypair_publicKey(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set publicKey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_keypair_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_keypair_network(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
}

const MasternodeVoteTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_masternodevotetransition_free(ptr >>> 0, 1));

export class MasternodeVoteTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MasternodeVoteTransition.prototype);
        obj.__wbg_ptr = ptr;
        MasternodeVoteTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MasternodeVoteTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_masternodevotetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {MasternodeVoteTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.masternodevotetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {MasternodeVoteTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.masternodevotetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @param {any} obj
     * @returns {MasternodeVoteTransition}
     */
    static fromObject(obj) {
        const ret = wasm.masternodevotetransition_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier}
     */
    get proTxHash() {
        const ret = wasm.masternodevotetransition_pro_tx_hash(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.masternodevotetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Uint8Array} signature
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.masternodevotetransition_set_signature(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_pro_tx_hash
     */
    set proTxHash(js_pro_tx_hash) {
        const ret = wasm.masternodevotetransition_set_pro_tx_hash(this.__wbg_ptr, js_pro_tx_hash);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Identifier}
     */
    get voterIdentityId() {
        const ret = wasm.masternodevotetransition_voter_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    getSignableBytes() {
        const ret = wasm.masternodevotetransition_getSignableBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {StateTransition}
     */
    toStateTransition() {
        const ret = wasm.masternodevotetransition_toStateTransition(this.__wbg_ptr);
        return StateTransition.__wrap(ret);
    }
    /**
     * @returns {AssetLockProof | undefined}
     */
    get assetLock() {
        const ret = wasm.masternodevotetransition_get_asset_lock_proof(this.__wbg_ptr);
        return ret === 0 ? undefined : AssetLockProof.__wrap(ret);
    }
    /**
     * @param {StateTransition} st
     * @returns {MasternodeVoteTransition}
     */
    static fromStateTransition(st) {
        _assertClass(st, StateTransition);
        const ret = wasm.masternodevotetransition_fromStateTransition(st.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier[]}
     */
    get modifiedDataIds() {
        const ret = wasm.masternodevotetransition_get_modified_data_ids(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.masternodevotetransition_get_asset_lock_proof(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} amount
     */
    set userFeeIncrease(amount) {
        wasm.masternodevotetransition_set_user_fee_increase(this.__wbg_ptr, amount);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_voter_identity_id
     */
    set voterIdentityId(js_voter_identity_id) {
        const ret = wasm.masternodevotetransition_set_voter_identity_id(this.__wbg_ptr, js_voter_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {number}
     */
    get signaturePublicKeyId() {
        const ret = wasm.masternodevotetransition_signature_public_key_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} signature_public_key_id
     */
    set signaturePublicKeyId(signature_public_key_id) {
        wasm.masternodevotetransition_set_signature_public_key_id(this.__wbg_ptr, signature_public_key_id);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_pro_tx_hash
     * @param {Identifier | Uint8Array | string} js_voter_identity_id
     * @param {Vote} vote
     * @param {bigint} nonce
     * @param {number | null} [signature_public_key]
     * @param {Uint8Array | null} [signature]
     */
    constructor(js_pro_tx_hash, js_voter_identity_id, vote, nonce, signature_public_key, signature) {
        _assertClass(vote, Vote);
        var ptr0 = isLikeNone(signature) ? 0 : passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.masternodevotetransition_new(js_pro_tx_hash, js_voter_identity_id, vote.__wbg_ptr, nonce, isLikeNone(signature_public_key) ? 0x100000001 : (signature_public_key) >>> 0, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        MasternodeVoteTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Vote}
     */
    get vote() {
        const ret = wasm.masternodevotetransition_vote(this.__wbg_ptr);
        return Vote.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    get nonce() {
        const ret = wasm.masternodevotetransition_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.masternodevotetransition_toHex(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.masternodevotetransition_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {MasternodeVoteTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.masternodevotetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @param {Vote} vote
     */
    set vote(vote) {
        _assertClass(vote, Vote);
        wasm.masternodevotetransition_set_vote(this.__wbg_ptr, vote.__wbg_ptr);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.masternodevotetransition_toBytes(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {any} js
     * @returns {MasternodeVoteTransition}
     */
    static fromJSON(js) {
        const ret = wasm.masternodevotetransition_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MasternodeVoteTransition.__wrap(ret[0]);
    }
    /**
     * @param {bigint} nonce
     */
    set nonce(nonce) {
        wasm.masternodevotetransition_set_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.masternodevotetransition_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.masternodevotetransition_toBase64(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.masternodevotetransition_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.masternodevotetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const OutPointFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_outpoint_free(ptr >>> 0, 1));

export class OutPoint {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OutPoint.prototype);
        obj.__wbg_ptr = ptr;
        OutPointFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OutPointFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_outpoint_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} js_buffer
     * @returns {OutPoint}
     */
    static fromBytes(js_buffer) {
        const ptr0 = passArray8ToWasm0(js_buffer, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.outpoint_fromBytes(ptr0, len0);
        return OutPoint.__wrap(ret);
    }
    /**
     * @param {string} base64
     * @returns {OutPoint}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.outpoint_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return OutPoint.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.outpoint_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} txid_hex
     * @param {number} vout
     */
    constructor(txid_hex, vout) {
        const ptr0 = passStringToWasm0(txid_hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.outpoint_new(ptr0, len0, vout);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        OutPointFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.outpoint_toHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} hex
     * @returns {OutPoint}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.outpoint_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return OutPoint.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    getVOUT() {
        const ret = wasm.outpoint_getVOUT(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.outpoint_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {string}
     */
    getTXID() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.outpoint_getTXID(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toBase64() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.outpoint_toBase64(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.outpoint_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const PartialIdentityFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_partialidentity_free(ptr >>> 0, 1));

export class PartialIdentity {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PartialIdentityFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_partialidentity_free(ptr, 0);
    }
    /**
     * @param {bigint | null} [balance]
     */
    set balance(balance) {
        wasm.partialidentity_set_balance(this.__wbg_ptr, !isLikeNone(balance), isLikeNone(balance) ? BigInt(0) : balance);
    }
    /**
     * @param {bigint | null} [revision]
     */
    set revision(revision) {
        wasm.partialidentity_set_revision(this.__wbg_ptr, !isLikeNone(revision), isLikeNone(revision) ? BigInt(0) : revision);
    }
    /**
     * @returns {object}
     */
    get loadedPublicKeys() {
        const ret = wasm.partialidentity_loaded_public_keys(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {Array<any>}
     */
    get notFoundPublicKeys() {
        const ret = wasm.partialidentity_not_found_public_keys(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} loaded_public_keys
     */
    set loadedPublicKeys(loaded_public_keys) {
        const ret = wasm.partialidentity_set_loaded_public_keys(this.__wbg_ptr, loaded_public_keys);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {Array<any> | null} [keys]
     */
    set notFoundPublicKeys(keys) {
        const ret = wasm.partialidentity_set_not_found_public_keys(this.__wbg_ptr, isLikeNone(keys) ? 0 : addToExternrefTable0(keys));
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Identifier}
     */
    get id() {
        const ret = wasm.partialidentity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     * @param {any} js_loaded_public_keys
     * @param {bigint | null} [balance]
     * @param {bigint | null} [revision]
     * @param {Array<any> | null} [js_not_found_public_keys]
     */
    constructor(js_id, js_loaded_public_keys, balance, revision, js_not_found_public_keys) {
        const ret = wasm.partialidentity_new(js_id, js_loaded_public_keys, !isLikeNone(balance), isLikeNone(balance) ? BigInt(0) : balance, !isLikeNone(revision), isLikeNone(revision) ? BigInt(0) : revision, isLikeNone(js_not_found_public_keys) ? 0 : addToExternrefTable0(js_not_found_public_keys));
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        PartialIdentityFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     */
    set id(js_id) {
        const ret = wasm.partialidentity_set_id(this.__wbg_ptr, js_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get balance() {
        const ret = wasm.partialidentity_balance(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.partialidentity_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get revision() {
        const ret = wasm.partialidentity_revision(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.partialidentity_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PathDerivedKeyInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_pathderivedkeyinfo_free(ptr >>> 0, 1));

export class PathDerivedKeyInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PathDerivedKeyInfo.prototype);
        obj.__wbg_ptr = ptr;
        PathDerivedKeyInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PathDerivedKeyInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pathderivedkeyinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get path() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_path(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set path(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_derivationpathinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyWif() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_privateKeyWif(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyWif(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dip13derivationpathinfo_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_privateKeyHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyHex(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_publicKey(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set publicKey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_pathderivedkeyinfo_network(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} obj
     * @returns {PathDerivedKeyInfo}
     */
    static fromObject(obj) {
        const ret = wasm.pathderivedkeyinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PathDerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.pathderivedkeyinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {PathDerivedKeyInfo}
     */
    static fromJSON(js) {
        const ret = wasm.pathderivedkeyinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PathDerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.pathderivedkeyinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PathElementFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_pathelement_free(ptr >>> 0, 1));

export class PathElement {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PathElement.prototype);
        obj.__wbg_ptr = ptr;
        PathElementFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PathElementFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pathelement_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {PathElement}
     */
    static fromObject(obj) {
        const ret = wasm.pathelement_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PathElement.__wrap(ret[0]);
    }
    /**
     * @returns {Array<any>}
     */
    get path() {
        const ret = wasm.pathelement_path(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string | undefined}
     */
    get value() {
        const ret = wasm.pathelement_value(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.pathelement_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {PathElement}
     */
    static fromJSON(js) {
        const ret = wasm.pathelement_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PathElement.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.pathelement_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PlatformAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_platformaddress_free(ptr >>> 0, 1));

export class PlatformAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlatformAddress.prototype);
        obj.__wbg_ptr = ptr;
        PlatformAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlatformAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_platformaddress_free(ptr, 0);
    }
    /**
     * Creates a PlatformAddress from raw bytes (21 bytes: type byte + 20-byte hash).
     * @param {Uint8Array} bytes
     * @returns {PlatformAddress}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.platformaddress_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Returns the bech32m-encoded address string for the specified network.
     * @param {NetworkLike} network
     * @returns {string}
     */
    toBech32m(network) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.platformaddress_toBech32m(this.__wbg_ptr, network);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Returns the hash as a hex string.
     * @returns {string}
     */
    hashToHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddress_hashToHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddress_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns the address type: "P2PKH" or "P2SH".
     * @returns {string}
     */
    get addressType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddress_addressType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Creates a PlatformAddress from a bech32m-encoded string.
     *
     * Accepts addresses with either mainnet ("dashevo") or testnet ("tdashevo") HRP.
     * @param {string} address
     * @returns {PlatformAddress}
     */
    static fromBech32m(address) {
        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.platformaddress_fromBech32m(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Creates a P2SH address from a 20-byte script hash.
     * @param {Uint8Array} hash
     * @returns {PlatformAddress}
     */
    static fromP2shHash(hash) {
        const ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.platformaddress_fromP2shHash(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Creates a P2PKH address from a 20-byte public key hash.
     * @param {Uint8Array} hash
     * @returns {PlatformAddress}
     */
    static fromP2pkhHash(hash) {
        const ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.platformaddress_fromP2pkhHash(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Creates a new PlatformAddress from various input types.
     *
     * Accepts:
     * - A bech32m string (e.g., "dashevo1..." or "tdashevo1...")
     * - A Uint8Array (21 bytes: type byte + 20-byte hash)
     * - An existing PlatformAddress object
     * @param {PlatformAddress | Uint8Array | string} js_address
     */
    constructor(js_address) {
        const ret = wasm.platformaddress_new(js_address);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        PlatformAddressFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the 20-byte hash portion of the address.
     * @returns {Uint8Array}
     */
    hash() {
        const ret = wasm.platformaddress_hash(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * Returns the hex-encoded address bytes.
     * @returns {string}
     */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddress_toHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns true if this is a P2SH address.
     * @returns {boolean}
     */
    get isP2sh() {
        const ret = wasm.platformaddress_isP2sh(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Creates a PlatformAddress from a hex-encoded string.
     * @param {string} hex_string
     * @returns {PlatformAddress}
     */
    static fromHex(hex_string) {
        const ptr0 = passStringToWasm0(hex_string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.platformaddress_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Returns true if this is a P2PKH address.
     * @returns {boolean}
     */
    get isP2pkh() {
        const ret = wasm.platformaddress_isP2pkh(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Returns the raw bytes of the address (21 bytes: type byte + 20-byte hash).
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.platformaddress_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddress_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const PlatformAddressInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_platformaddressinfo_free(ptr >>> 0, 1));
/**
 * Information about a Platform address including its nonce and balance.
 */
export class PlatformAddressInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlatformAddressInfo.prototype);
        obj.__wbg_ptr = ptr;
        PlatformAddressInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlatformAddressInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_platformaddressinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {PlatformAddressInfo}
     */
    static fromObject(obj) {
        const ret = wasm.platformaddressinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddressInfo.__wrap(ret[0]);
    }
    /**
     * Returns the nonce associated with the address.
     * @returns {bigint}
     */
    get nonce() {
        const ret = wasm.platformaddressinfo_nonce(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the platform address.
     * @returns {PlatformAddress}
     */
    get address() {
        const ret = wasm.platformaddressinfo_address(this.__wbg_ptr);
        return PlatformAddress.__wrap(ret);
    }
    /**
     * Returns the balance stored for the address in credits.
     * @returns {bigint}
     */
    get balance() {
        const ret = wasm.platformaddressinfo_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.platformaddressinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {PlatformAddressInfo}
     */
    static fromJSON(js) {
        const ret = wasm.platformaddressinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddressInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.platformaddressinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PlatformAddressInputFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_platformaddressinput_free(ptr >>> 0, 1));
/**
 * Represents an input address for address-based state transitions.
 *
 * An input specifies a Platform address that will spend credits,
 * along with its current nonce and the amount to spend.
 */
export class PlatformAddressInput {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlatformAddressInputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_platformaddressinput_free(ptr, 0);
    }
    /**
     * Creates a new PlatformAddressInput.
     *
     * @param address - The Platform address (PlatformAddress, Uint8Array, or bech32m string)
     * @param nonce - The current nonce of the address (will be incremented for the transaction)
     * @param amount - The amount of credits to spend from this address
     * @param {PlatformAddressLike} address
     * @param {number} nonce
     * @param {bigint} amount
     */
    constructor(address, nonce, amount) {
        const ret = wasm.platformaddressinput_new(address, nonce, amount);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        PlatformAddressInputFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the nonce.
     * @returns {number}
     */
    get nonce() {
        const ret = wasm.platformaddressinput_nonce(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Returns the amount.
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.platformaddressinput_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the Platform address.
     * @returns {PlatformAddress}
     */
    get address() {
        const ret = wasm.platformaddressinput_address(this.__wbg_ptr);
        return PlatformAddress.__wrap(ret);
    }
}

const PlatformAddressOutputFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_platformaddressoutput_free(ptr >>> 0, 1));
/**
 * Represents an output address for address-based state transitions.
 *
 * An output specifies a Platform address that will receive credits,
 * along with an optional amount to receive. When amount is None,
 * the system distributes funds automatically (used for asset lock funding).
 */
export class PlatformAddressOutput {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlatformAddressOutputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_platformaddressoutput_free(ptr, 0);
    }
    /**
     * Creates a new PlatformAddressOutput with a specific amount.
     *
     * @param address - The Platform address (PlatformAddress, Uint8Array, or bech32m string)
     * @param amount - The amount of credits to send to this address (optional for asset lock funding)
     * @param {PlatformAddressLike} address
     * @param {bigint | null} [amount]
     */
    constructor(address, amount) {
        const ret = wasm.platformaddressoutput_new(address, isLikeNone(amount) ? 0 : addToExternrefTable0(amount));
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        PlatformAddressOutputFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the amount, or undefined if not specified.
     * @returns {bigint | undefined}
     */
    get amount() {
        const ret = wasm.platformaddressoutput_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the Platform address.
     * @returns {PlatformAddress}
     */
    get address() {
        const ret = wasm.platformaddressoutput_address(this.__wbg_ptr);
        return PlatformAddress.__wrap(ret);
    }
}

const PlatformAddressSignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_platformaddresssigner_free(ptr >>> 0, 1));
/**
 * A signer for Platform address-based state transitions.
 *
 * This signer holds private keys for Platform addresses and can sign
 * state transitions that spend from those addresses.
 */
export class PlatformAddressSigner {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlatformAddressSignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_platformaddresssigner_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddresssigner_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns all private keys as an array of {addressHash: Uint8Array, privateKey: Uint8Array}.
     * This is used internally for cross-package access.
     * @returns {Array<any>}
     */
    getPrivateKeysBytes() {
        const ret = wasm.platformaddresssigner_getPrivateKeysBytes(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * Creates a new empty PlatformAddressSigner.
     */
    constructor() {
        const ret = wasm.identitysigner_new();
        this.__wbg_ptr = ret >>> 0;
        PlatformAddressSignerFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Adds a private key and derives the Platform address from it.
     *
     * The address is derived as: P2PKH(Hash160(compressed_public_key))
     *
     * @param privateKey - The PrivateKey object
     * @returns The derived Platform address
     * @param {PrivateKey} private_key
     * @returns {PlatformAddress}
     */
    addKey(private_key) {
        _assertClass(private_key, PrivateKey);
        const ret = wasm.platformaddresssigner_addKey(this.__wbg_ptr, private_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlatformAddress.__wrap(ret[0]);
    }
    /**
     * Returns true if this signer has a key for the given address.
     * @param {PlatformAddressLike} address
     * @returns {boolean}
     */
    hasKey(address) {
        const ret = wasm.platformaddresssigner_hasKey(this.__wbg_ptr, address);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * Returns the number of keys in this signer.
     * @returns {number}
     */
    get keyCount() {
        const ret = wasm.platformaddresssigner_key_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Returns the type name for WASM object identification (instance getter).
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.platformaddresssigner_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const PrefundedSpecializedBalanceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_prefundedspecializedbalance_free(ptr >>> 0, 1));

export class PrefundedSpecializedBalance {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrefundedSpecializedBalance.prototype);
        obj.__wbg_ptr = ptr;
        PrefundedSpecializedBalanceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrefundedSpecializedBalanceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_prefundedspecializedbalance_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {PrefundedSpecializedBalance}
     */
    static fromObject(obj) {
        const ret = wasm.prefundedspecializedbalance_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrefundedSpecializedBalance.__wrap(ret[0]);
    }
    /**
     * @returns {Identifier}
     */
    get identityId() {
        const ret = wasm.prefundedspecializedbalance_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    get balance() {
        const ret = wasm.prefundedspecializedbalance_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.prefundedspecializedbalance_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {PrefundedSpecializedBalance}
     */
    static fromJSON(js) {
        const ret = wasm.prefundedspecializedbalance_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrefundedSpecializedBalance.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.prefundedspecializedbalance_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PrefundedVotingBalanceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_prefundedvotingbalance_free(ptr >>> 0, 1));

export class PrefundedVotingBalance {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrefundedVotingBalance.prototype);
        obj.__wbg_ptr = ptr;
        PrefundedVotingBalanceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrefundedVotingBalanceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_prefundedvotingbalance_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get indexName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.prefundedvotingbalance_indexName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.prefundedvotingbalance_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} index_name
     * @param {bigint} credits
     */
    constructor(index_name, credits) {
        const ptr0 = passStringToWasm0(index_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.prefundedvotingbalance_new(ptr0, len0, credits);
        this.__wbg_ptr = ret >>> 0;
        PrefundedVotingBalanceFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {bigint}
     */
    get credits() {
        const ret = wasm.prefundedvotingbalance_credits(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.prefundedvotingbalance_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const PrivateEncryptedNoteFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_privateencryptednote_free(ptr >>> 0, 1));

export class PrivateEncryptedNote {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrivateEncryptedNote.prototype);
        obj.__wbg_ptr = ptr;
        PrivateEncryptedNoteFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateEncryptedNoteFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privateencryptednote_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privateencryptednote_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get rootEncryptionKeyIndex() {
        const ret = wasm.privateencryptednote_root_encryption_key_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     */
    set rootEncryptionKeyIndex(index) {
        wasm.privateencryptednote_set_root_encryption_key_index(this.__wbg_ptr, index);
    }
    /**
     * @returns {number}
     */
    get derivationEncryptionKeyIndex() {
        const ret = wasm.privateencryptednote_derivation_encryption_key_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     */
    set derivationEncryptionKeyIndex(index) {
        wasm.privateencryptednote_set_derivation_encryption_key_index(this.__wbg_ptr, index);
    }
    /**
     * @param {number} root_encryption_key_index
     * @param {number} derivation_encryption_key_index
     * @param {Uint8Array} value
     */
    constructor(root_encryption_key_index, derivation_encryption_key_index, value) {
        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privateencryptednote_new(root_encryption_key_index, derivation_encryption_key_index, ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        PrivateEncryptedNoteFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Uint8Array}
     */
    get value() {
        const ret = wasm.privateencryptednote_value(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} value
     */
    set value(value) {
        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.privateencryptednote_set_value(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privateencryptednote_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_privatekey_free(ptr >>> 0, 1));

export class PrivateKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrivateKey.prototype);
        obj.__wbg_ptr = ptr;
        PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privatekey_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @param {Network | string} network
     * @returns {PrivateKey}
     */
    static fromBytes(bytes, network) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_fromBytes(ptr0, len0, network);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {PublicKey}
     */
    getPublicKey() {
        const ret = wasm.privatekey_getPublicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getPublicKeyHash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_getPublicKeyHash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_toHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    WIF() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_WIF(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} hex_key
     * @param {Network | string} network
     * @returns {PrivateKey}
     */
    static fromHex(hex_key, network) {
        const ptr0 = passStringToWasm0(hex_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_fromHex(ptr0, len0, network);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @param {string} wif
     * @returns {PrivateKey}
     */
    static fromWIF(wif) {
        const ptr0 = passStringToWasm0(wif, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_fromWIF(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.privatekey_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ProTxHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protxhash_free(ptr >>> 0, 1));

export class ProTxHash {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProTxHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protxhash_free(ptr, 0);
    }
}

const ProofInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proofinfo_free(ptr >>> 0, 1));

export class ProofInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProofInfo.prototype);
        obj.__wbg_ptr = ptr;
        ProofInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProofInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proofinfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ProofInfo}
     */
    static fromObject(obj) {
        const ret = wasm.proofinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProofInfo.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get quorumHash() {
        const ret = wasm.proofinfo_quorum_hash(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    get quorumType() {
        const ret = wasm.proofinfo_quorum_type(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {Uint8Array}
     */
    get blockIdHash() {
        const ret = wasm.proofinfo_block_id_hash(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Uint8Array}
     */
    get grovedbProof() {
        const ret = wasm.proofinfo_grovedb_proof(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Uint8Array} signature
     */
    setSignature(signature) {
        wasm.proofinfo_setSignature(this.__wbg_ptr, signature);
    }
    /**
     * @param {Uint8Array} quorumHash
     */
    setQuorumHash(quorumHash) {
        wasm.proofinfo_setQuorumHash(this.__wbg_ptr, quorumHash);
    }
    /**
     * @param {Uint8Array} blockIdHash
     */
    setBlockIdHash(blockIdHash) {
        wasm.proofinfo_setBlockIdHash(this.__wbg_ptr, blockIdHash);
    }
    /**
     * @param {Uint8Array} grovedbProof
     */
    setGrovedbProof(grovedbProof) {
        wasm.proofinfo_setGrovedbProof(this.__wbg_ptr, grovedbProof);
    }
    /**
     * @param {Uint8Array} grovedbProof
     * @param {Uint8Array} quorumHash
     * @param {Uint8Array} signature
     * @param {number} round
     * @param {Uint8Array} blockIdHash
     * @param {number} quorumType
     */
    constructor(grovedbProof, quorumHash, signature, round, blockIdHash, quorumType) {
        const ret = wasm.proofinfo_new(grovedbProof, quorumHash, signature, round, blockIdHash, quorumType);
        this.__wbg_ptr = ret >>> 0;
        ProofInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    get round() {
        const ret = wasm.proofinfo_round(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.proofinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ProofInfo}
     */
    static fromJSON(js) {
        const ret = wasm.proofinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProofInfo.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.proofinfo_signature(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.proofinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ProofMetadataResponseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proofmetadataresponse_free(ptr >>> 0, 1));

export class ProofMetadataResponse {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProofMetadataResponse.prototype);
        obj.__wbg_ptr = ptr;
        ProofMetadataResponseFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProofMetadataResponseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proofmetadataresponse_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ProofMetadataResponse}
     */
    static fromObject(obj) {
        const ret = wasm.proofmetadataresponse_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProofMetadataResponse.__wrap(ret[0]);
    }
    /**
     * @param {ResponseMetadata} metadata
     */
    setMetadata(metadata) {
        _assertClass(metadata, ResponseMetadata);
        var ptr0 = metadata.__destroy_into_raw();
        wasm.proofmetadataresponse_setMetadata(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {any} data
     * @param {ResponseMetadata} metadata
     * @param {ProofInfo} proof
     */
    constructor(data, metadata, proof) {
        _assertClass(metadata, ResponseMetadata);
        var ptr0 = metadata.__destroy_into_raw();
        _assertClass(proof, ProofInfo);
        var ptr1 = proof.__destroy_into_raw();
        const ret = wasm.proofmetadataresponse_new(data, ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        ProofMetadataResponseFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    get data() {
        const ret = wasm.proofmetadataresponse_data(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ProofInfo}
     */
    get proof() {
        const ret = wasm.proofmetadataresponse_proof(this.__wbg_ptr);
        return ProofInfo.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.proofmetadataresponse_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {ResponseMetadata}
     */
    get metadata() {
        const ret = wasm.proofmetadataresponse_metadata(this.__wbg_ptr);
        return ResponseMetadata.__wrap(ret);
    }
    /**
     * @param {any} data
     */
    setData(data) {
        wasm.proofmetadataresponse_setData(this.__wbg_ptr, data);
    }
    /**
     * @param {any} js
     * @returns {ProofMetadataResponse}
     */
    static fromJSON(js) {
        const ret = wasm.proofmetadataresponse_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProofMetadataResponse.__wrap(ret[0]);
    }
    /**
     * @param {ProofInfo} proof
     */
    setProof(proof) {
        _assertClass(proof, ProofInfo);
        var ptr0 = proof.__destroy_into_raw();
        wasm.proofmetadataresponse_setProof(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.proofmetadataresponse_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ProtocolVersionUpgradeStateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protocolversionupgradestate_free(ptr >>> 0, 1));

export class ProtocolVersionUpgradeState {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProtocolVersionUpgradeState.prototype);
        obj.__wbg_ptr = ptr;
        ProtocolVersionUpgradeStateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProtocolVersionUpgradeStateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolversionupgradestate_free(ptr, 0);
    }
    /**
     * @returns {number | undefined}
     */
    get voteCount() {
        const ret = wasm.protocolversionupgradestate_vote_count(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {any} obj
     * @returns {ProtocolVersionUpgradeState}
     */
    static fromObject(obj) {
        const ret = wasm.protocolversionupgradestate_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersionUpgradeState.__wrap(ret[0]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get activationHeight() {
        const ret = wasm.protocolversionupgradestate_activation_height(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {boolean}
     */
    get thresholdReached() {
        const ret = wasm.protocolversionupgradestate_threshold_reached(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {number | undefined}
     */
    get nextProtocolVersion() {
        const ret = wasm.protocolversionupgradestate_next_protocol_version(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @returns {number}
     */
    get currentProtocolVersion() {
        const ret = wasm.protocolversionupgradestate_current_protocol_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.protocolversionupgradestate_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ProtocolVersionUpgradeState}
     */
    static fromJSON(js) {
        const ret = wasm.protocolversionupgradestate_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersionUpgradeState.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.protocolversionupgradestate_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ProtocolVersionUpgradeVoteStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protocolversionupgradevotestatus_free(ptr >>> 0, 1));

export class ProtocolVersionUpgradeVoteStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProtocolVersionUpgradeVoteStatus.prototype);
        obj.__wbg_ptr = ptr;
        ProtocolVersionUpgradeVoteStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProtocolVersionUpgradeVoteStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolversionupgradevotestatus_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ProtocolVersionUpgradeVoteStatus}
     */
    static fromObject(obj) {
        const ret = wasm.protocolversionupgradevotestatus_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersionUpgradeVoteStatus.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get proTxHash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.protocolversionupgradevotestatus_pro_tx_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.protocolversionupgradevotestatus_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {number}
     */
    get version() {
        const ret = wasm.protocolversionupgradevotestatus_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {any} js
     * @returns {ProtocolVersionUpgradeVoteStatus}
     */
    static fromJSON(js) {
        const ret = wasm.protocolversionupgradevotestatus_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersionUpgradeVoteStatus.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.protocolversionupgradevotestatus_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0, 1));

export class PublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr, 0);
    }
    /**
     * @returns {boolean}
     */
    get compressed() {
        const ret = wasm.publickey_compressed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {PublicKey}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.publickey_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.publickey_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {boolean} compressed
     */
    set compressed(compressed) {
        wasm.publickey_set_compressed(this.__wbg_ptr, compressed);
    }
    /**
     * @returns {string}
     */
    getPublicKeyHash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.publickey_getPublicKeyHash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {boolean} compressed
     * @param {Uint8Array} public_key_bytes
     */
    constructor(compressed, public_key_bytes) {
        const ptr0 = passArray8ToWasm0(public_key_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.publickey_new(compressed, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        PublicKeyFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Uint8Array}
     */
    get inner() {
        const ret = wasm.publickey_inner(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const ret = wasm.publickey_toBytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} inner
     */
    set inner(inner) {
        const ptr0 = passArray8ToWasm0(inner, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.publickey_set_inner(this.__wbg_ptr, ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.publickey_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const QuorumInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_quoruminfo_free(ptr >>> 0, 1));

export class QuorumInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(QuorumInfo.prototype);
        obj.__wbg_ptr = ptr;
        QuorumInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        QuorumInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_quoruminfo_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {QuorumInfo}
     */
    static fromObject(obj) {
        const ret = wasm.quoruminfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return QuorumInfo.__wrap(ret[0]);
    }
    /**
     * @returns {boolean}
     */
    get isVerified() {
        const ret = wasm.quoruminfo_is_verified(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {string}
     */
    get quorumHash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.quoruminfo_quorum_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get quorumType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.quoruminfo_quorum_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get memberCount() {
        const ret = wasm.quoruminfo_member_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.quoruminfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {QuorumInfo}
     */
    static fromJSON(js) {
        const ret = wasm.quoruminfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return QuorumInfo.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    get threshold() {
        const ret = wasm.quoruminfo_threshold(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.quoruminfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const RegisterDpnsNameResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_registerdpnsnameresult_free(ptr >>> 0, 1));

export class RegisterDpnsNameResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegisterDpnsNameResult.prototype);
        obj.__wbg_ptr = ptr;
        RegisterDpnsNameResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegisterDpnsNameResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_registerdpnsnameresult_free(ptr, 0);
    }
    /**
     * @returns {Identifier}
     */
    get preorderDocumentId() {
        const ret = wasm.__wbg_get_registerdpnsnameresult_preorderDocumentId(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier} arg0
     */
    set preorderDocumentId(arg0) {
        _assertClass(arg0, Identifier);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_dpnsusernameinfo_identityId(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {Identifier}
     */
    get domainDocumentId() {
        const ret = wasm.__wbg_get_registerdpnsnameresult_domainDocumentId(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier} arg0
     */
    set domainDocumentId(arg0) {
        _assertClass(arg0, Identifier);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_dpnsusernameinfo_documentId(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get fullDomainName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_registerdpnsnameresult_fullDomainName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set fullDomainName(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} obj
     * @returns {RegisterDpnsNameResult}
     */
    static fromObject(obj) {
        const ret = wasm.registerdpnsnameresult_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegisterDpnsNameResult.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.registerdpnsnameresult_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {RegisterDpnsNameResult}
     */
    static fromJSON(js) {
        const ret = wasm.registerdpnsnameresult_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegisterDpnsNameResult.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.registerdpnsnameresult_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const ResourceVoteFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_resourcevote_free(ptr >>> 0, 1));

export class ResourceVote {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ResourceVote.prototype);
        obj.__wbg_ptr = ptr;
        ResourceVoteFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResourceVoteFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resourcevote_free(ptr, 0);
    }
    /**
     * @param {ResourceVoteChoice} choice
     */
    set choice(choice) {
        _assertClass(choice, ResourceVoteChoice);
        wasm.resourcevote_set_choice(this.__wbg_ptr, choice.__wbg_ptr);
    }
    /**
     * @param {any} obj
     * @returns {ResourceVote}
     */
    static fromObject(obj) {
        const ret = wasm.resourcevote_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResourceVote.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resourcevote_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {VotePoll} vote_poll
     */
    set votePoll(vote_poll) {
        _assertClass(vote_poll, VotePoll);
        wasm.resourcevote_set_vote_poll(this.__wbg_ptr, vote_poll.__wbg_ptr);
    }
    /**
     * @param {VotePoll} vote_poll
     * @param {ResourceVoteChoice} choice
     */
    constructor(vote_poll, choice) {
        _assertClass(vote_poll, VotePoll);
        _assertClass(choice, ResourceVoteChoice);
        const ret = wasm.resourcevote_new(vote_poll.__wbg_ptr, choice.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        ResourceVoteFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {ResourceVoteChoice}
     */
    get choice() {
        const ret = wasm.resourcevote_choice(this.__wbg_ptr);
        return ResourceVoteChoice.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.resourcevote_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {ResourceVote}
     */
    static fromJSON(js) {
        const ret = wasm.resourcevote_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResourceVote.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.resourcevote_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resourcevote_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {VotePoll}
     */
    get votePoll() {
        const ret = wasm.resourcevote_vote_poll(this.__wbg_ptr);
        return VotePoll.__wrap(ret);
    }
}

const ResourceVoteChoiceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_resourcevotechoice_free(ptr >>> 0, 1));

export class ResourceVoteChoice {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ResourceVoteChoice.prototype);
        obj.__wbg_ptr = ptr;
        ResourceVoteChoiceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResourceVoteChoiceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resourcevotechoice_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ResourceVoteChoice}
     */
    static fromObject(obj) {
        const ret = wasm.resourcevotechoice_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResourceVoteChoice.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resourcevotechoice_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     * @returns {ResourceVoteChoice}
     */
    static TowardsIdentity(js_id) {
        const ret = wasm.resourcevotechoice_TowardsIdentity(js_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResourceVoteChoice.__wrap(ret[0]);
    }
    /**
     * @returns {ResourceVoteChoice}
     */
    static Lock() {
        const ret = wasm.resourcevotechoice_Lock();
        return ResourceVoteChoice.__wrap(ret);
    }
    /**
     * @returns {ResourceVoteChoice}
     */
    static Abstain() {
        const ret = wasm.resourcevotechoice_Abstain();
        return ResourceVoteChoice.__wrap(ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.resourcevotechoice_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    getType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resourcevotechoice_getType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js
     * @returns {ResourceVoteChoice}
     */
    static fromJSON(js) {
        const ret = wasm.resourcevotechoice_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResourceVoteChoice.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    getValue() {
        const ret = wasm.resourcevotechoice_getValue(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.resourcevotechoice_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resourcevotechoice_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const ResponseMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_responsemetadata_free(ptr >>> 0, 1));

export class ResponseMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ResponseMetadata.prototype);
        obj.__wbg_ptr = ptr;
        ResponseMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResponseMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_responsemetadata_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {ResponseMetadata}
     */
    static fromObject(obj) {
        const ret = wasm.responsemetadata_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResponseMetadata.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} chainId
     */
    setChainId(chainId) {
        wasm.responsemetadata_setChainId(this.__wbg_ptr, chainId);
    }
    /**
     * @returns {number}
     */
    get protocolVersion() {
        const ret = wasm.responsemetadata_protocol_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    get coreChainLockedHeight() {
        const ret = wasm.responsemetadata_core_chain_locked_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {bigint} height
     * @param {number} coreChainLockedHeight
     * @param {number} epoch
     * @param {bigint} timeMs
     * @param {number} protocolVersion
     * @param {Uint8Array} chainId
     */
    constructor(height, coreChainLockedHeight, epoch, timeMs, protocolVersion, chainId) {
        const ret = wasm.responsemetadata_new(height, coreChainLockedHeight, epoch, timeMs, protocolVersion, chainId);
        this.__wbg_ptr = ret >>> 0;
        ResponseMetadataFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    get epoch() {
        const ret = wasm.responsemetadata_epoch(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {bigint}
     */
    get height() {
        const ret = wasm.responsemetadata_height(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    get timeMs() {
        const ret = wasm.responsemetadata_time_ms(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.responsemetadata_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get chainId() {
        const ret = wasm.responsemetadata_chain_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} js
     * @returns {ResponseMetadata}
     */
    static fromJSON(js) {
        const ret = wasm.responsemetadata_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResponseMetadata.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.responsemetadata_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const RewardDistributionMomentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rewarddistributionmoment_free(ptr >>> 0, 1));

export class RewardDistributionMoment {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RewardDistributionMoment.prototype);
        obj.__wbg_ptr = ptr;
        RewardDistributionMomentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RewardDistributionMomentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewarddistributionmoment_free(ptr, 0);
    }
    /**
     * Returns the epoch index (only valid when type is "epoch")
     * @returns {number | undefined}
     */
    get epochIndex() {
        const ret = wasm.rewarddistributionmoment_epoch_index(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
     * Returns the type: "block", "time", or "epoch"
     * @returns {string}
     */
    get type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.rewarddistributionmoment_moment_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Returns the block height (only valid when type is "block")
     * @returns {bigint | undefined}
     */
    get blockHeight() {
        const ret = wasm.rewarddistributionmoment_block_height(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * Returns the timestamp in ms (only valid when type is "time")
     * @returns {bigint | undefined}
     */
    get timestampMs() {
        const ret = wasm.rewarddistributionmoment_timestamp_ms(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
}

const RewardDistributionTypeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rewarddistributiontype_free(ptr >>> 0, 1));

export class RewardDistributionType {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RewardDistributionType.prototype);
        obj.__wbg_ptr = ptr;
        RewardDistributionTypeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RewardDistributionTypeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewarddistributiontype_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.rewarddistributiontype_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    getDistribution() {
        const ret = wasm.rewarddistributiontype_getDistribution(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} interval
     * @param {DistributionFunction} _function
     * @returns {RewardDistributionType}
     */
    static TimeBasedDistribution(interval, _function) {
        _assertClass(_function, DistributionFunction);
        const ret = wasm.rewarddistributiontype_TimeBasedDistribution(interval, _function.__wbg_ptr);
        return RewardDistributionType.__wrap(ret);
    }
    /**
     * @param {bigint} interval
     * @param {DistributionFunction} _function
     * @returns {RewardDistributionType}
     */
    static BlockBasedDistribution(interval, _function) {
        _assertClass(_function, DistributionFunction);
        const ret = wasm.rewarddistributiontype_BlockBasedDistribution(interval, _function.__wbg_ptr);
        return RewardDistributionType.__wrap(ret);
    }
    /**
     * @param {number} interval
     * @param {DistributionFunction} _function
     * @returns {RewardDistributionType}
     */
    static EpochBasedDistribution(interval, _function) {
        _assertClass(_function, DistributionFunction);
        const ret = wasm.rewarddistributiontype_EpochBasedDistribution(interval, _function.__wbg_ptr);
        return RewardDistributionType.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.rewarddistributiontype_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const SeedPhraseKeyInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_seedphrasekeyinfo_free(ptr >>> 0, 1));

export class SeedPhraseKeyInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SeedPhraseKeyInfo.prototype);
        obj.__wbg_ptr = ptr;
        SeedPhraseKeyInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SeedPhraseKeyInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_seedphrasekeyinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get privateKeyWif() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_seedphrasekeyinfo_privateKeyWif(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyWif(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_derivationpathinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get privateKeyHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_seedphrasekeyinfo_privateKeyHex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set privateKeyHex(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dip13derivationpathinfo_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_seedphrasekeyinfo_publicKey(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set publicKey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_seedphrasekeyinfo_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_seedphrasekeyinfo_network(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_pathderivedkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} obj
     * @returns {SeedPhraseKeyInfo}
     */
    static fromObject(obj) {
        const ret = wasm.seedphrasekeyinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SeedPhraseKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.seedphrasekeyinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {SeedPhraseKeyInfo}
     */
    static fromJSON(js) {
        const ret = wasm.seedphrasekeyinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SeedPhraseKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.seedphrasekeyinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const SharedEncryptedNoteFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_sharedencryptednote_free(ptr >>> 0, 1));

export class SharedEncryptedNote {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SharedEncryptedNote.prototype);
        obj.__wbg_ptr = ptr;
        SharedEncryptedNoteFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SharedEncryptedNoteFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_sharedencryptednote_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.sharedencryptednote_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    get senderKeyIndex() {
        const ret = wasm.sharedencryptednote_sender_key_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    get recipientKeyIndex() {
        const ret = wasm.sharedencryptednote_recipient_key_index(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     */
    set senderKeyIndex(index) {
        wasm.sharedencryptednote_set_sender_key_index(this.__wbg_ptr, index);
    }
    /**
     * @param {number} index
     */
    set recipientKeyIndex(index) {
        wasm.sharedencryptednote_set_recipient_key_index(this.__wbg_ptr, index);
    }
    /**
     * @param {number} sender_key_index
     * @param {number} recipient_key_index
     * @param {Uint8Array} value
     */
    constructor(sender_key_index, recipient_key_index, value) {
        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privateencryptednote_new(sender_key_index, recipient_key_index, ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        SharedEncryptedNoteFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Uint8Array}
     */
    get value() {
        const ret = wasm.sharedencryptednote_value(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} value
     */
    set value(value) {
        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.sharedencryptednote_set_value(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.sharedencryptednote_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const StateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statetransition_free(ptr >>> 0, 1));

export class StateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StateTransition.prototype);
        obj.__wbg_ptr = ptr;
        StateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statetransition_free(ptr, 0);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {StateTransition}
     */
    static fromBytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.statetransition_fromBytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StateTransition.__wrap(ret[0]);
    }
    /**
     * @param {string} base64
     * @returns {StateTransition}
     */
    static fromBase64(base64) {
        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.statetransition_fromBase64(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StateTransition.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.statetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier | undefined}
     */
    getOwnerId() {
        const ret = wasm.statetransition_getOwnerId(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_owner_id
     */
    setOwnerId(js_owner_id) {
        const ret = wasm.statetransition_setOwnerId(this.__wbg_ptr, js_owner_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    get signature() {
        const ret = wasm.statetransition_get_signature(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    set signature(signature) {
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.statetransition_set_signature(this.__wbg_ptr, ptr0, len0);
        return ret !== 0;
    }
    /**
     * @returns {string}
     */
    getActionType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.statetransition_getActionType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {IdentityPublicKey} public_key
     * @param {boolean | null} [js_allow_signing_with_any_security_level]
     * @param {boolean | null} [js_allow_signing_with_any_purpose]
     */
    verifyPublicKey(public_key, js_allow_signing_with_any_security_level, js_allow_signing_with_any_purpose) {
        _assertClass(public_key, IdentityPublicKey);
        const ret = wasm.statetransition_verifyPublicKey(this.__wbg_ptr, public_key.__wbg_ptr, isLikeNone(js_allow_signing_with_any_security_level) ? 0xFFFFFF : js_allow_signing_with_any_security_level ? 1 : 0, isLikeNone(js_allow_signing_with_any_purpose) ? 0xFFFFFF : js_allow_signing_with_any_purpose ? 1 : 0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    getIdentityNonce() {
        const ret = wasm.statetransition_getIdentityNonce(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} nonce
     */
    setIdentityNonce(nonce) {
        const ret = wasm.statetransition_setIdentityNonce(this.__wbg_ptr, nonce);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {PrivateKey} private_key
     * @param {number | null | undefined} key_id
     * @param {any} js_key_type
     * @returns {Uint8Array}
     */
    signByPrivateKey(private_key, key_id, js_key_type) {
        _assertClass(private_key, PrivateKey);
        const ret = wasm.statetransition_signByPrivateKey(this.__wbg_ptr, private_key.__wbg_ptr, isLikeNone(key_id) ? 0x100000001 : (key_id) >>> 0, js_key_type);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {number}
     */
    get userFeeIncrease() {
        const ret = wasm.statetransition_get_user_fee_increase(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} user_fee_increase
     */
    set userFeeIncrease(user_fee_increase) {
        wasm.statetransition_set_user_fee_increase(this.__wbg_ptr, user_fee_increase);
    }
    /**
     * @returns {number}
     */
    getActionTypeNumber() {
        const ret = wasm.statetransition_getActionTypeNumber(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string[] | undefined}
     */
    getPurposeRequirement() {
        const ret = wasm.statetransition_getPurposeRequirement(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        }
        return v1;
    }
    /**
     * @param {any} js_purpose
     * @returns {string[] | undefined}
     */
    getKeyLevelRequirement(js_purpose) {
        const ret = wasm.statetransition_getKeyLevelRequirement(this.__wbg_ptr, js_purpose);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        }
        return v1;
    }
    /**
     * @returns {bigint | undefined}
     */
    getIdentityContractNonce() {
        const ret = wasm.statetransition_getIdentityContractNonce(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {number | undefined}
     */
    get signaturePublicKeyId() {
        const ret = wasm.statetransition_get_signature_public_key_id(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {bigint} nonce
     */
    setIdentityContractNonce(nonce) {
        const ret = wasm.statetransition_setIdentityContractNonce(this.__wbg_ptr, nonce);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {number} key_id
     */
    set signaturePublicKeyId(key_id) {
        wasm.statetransition_set_signature_public_key_id(this.__wbg_ptr, key_id);
    }
    /**
     * @param {PrivateKey} private_key
     * @param {IdentityPublicKey} public_key
     * @returns {Uint8Array}
     */
    sign(private_key, public_key) {
        _assertClass(private_key, PrivateKey);
        _assertClass(public_key, IdentityPublicKey);
        const ret = wasm.statetransition_sign(this.__wbg_ptr, private_key.__wbg_ptr, public_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {any}
     */
    toHex() {
        const ret = wasm.statetransition_toHex(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} hex
     * @returns {StateTransition}
     */
    static fromHex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.statetransition_fromHex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StateTransition.__wrap(ret[0]);
    }
    /**
     * @param {boolean} skip_signature
     * @returns {string}
     */
    hash(skip_signature) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.statetransition_hash(this.__wbg_ptr, skip_signature);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toBytes() {
        const ret = wasm.statetransition_toBytes(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {any}
     */
    toBase64() {
        const ret = wasm.statetransition_toBase64(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.statetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const StateTransitionResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statetransitionresult_free(ptr >>> 0, 1));

export class StateTransitionResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StateTransitionResult.prototype);
        obj.__wbg_ptr = ptr;
        StateTransitionResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StateTransitionResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statetransitionresult_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get state_transition_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statetransitionresult_state_transition_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set state_transition_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get status() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statetransitionresult_status(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set status(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get error() {
        const ret = wasm.__wbg_get_statetransitionresult_error(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set error(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statetransitionresult_error(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {any} obj
     * @returns {StateTransitionResult}
     */
    static fromObject(obj) {
        const ret = wasm.statetransitionresult_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StateTransitionResult.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statetransitionresult_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StateTransitionResult}
     */
    static fromJSON(js) {
        const ret = wasm.statetransitionresult_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StateTransitionResult.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statetransitionresult_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const StatusChainFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statuschain_free(ptr >>> 0, 1));

export class StatusChain {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusChain.prototype);
        obj.__wbg_ptr = ptr;
        StatusChainFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusChainFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statuschain_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusChain}
     */
    static fromObject(obj) {
        const ret = wasm.statuschain_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusChain.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statuschain_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusChain}
     */
    static fromJSON(js) {
        const ret = wasm.statuschain_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusChain.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statuschain_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {boolean}
     */
    get catching_up() {
        const ret = wasm.__wbg_get_statuschain_catching_up(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set catching_up(arg0) {
        wasm.__wbg_set_statuschain_catching_up(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get latest_block_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_latest_block_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set latest_block_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_latest_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get latest_app_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_latest_app_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set latest_app_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_latest_app_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get latest_block_height() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_latest_block_height(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set latest_block_height(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_latest_block_height(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get earliest_block_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_earliest_block_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set earliest_block_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_earliest_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get earliest_app_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_earliest_app_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set earliest_app_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_earliest_app_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get earliest_block_height() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_earliest_block_height(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set earliest_block_height(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_earliest_block_height(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get max_peer_block_height() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statuschain_max_peer_block_height(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set max_peer_block_height(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_max_peer_block_height(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number | undefined}
     */
    get core_chain_locked_height() {
        const ret = wasm.__wbg_get_statuschain_core_chain_locked_height(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set core_chain_locked_height(arg0) {
        wasm.__wbg_set_statuschain_core_chain_locked_height(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : (arg0) >>> 0);
    }
}

const StatusDriveProtocolFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusdriveprotocol_free(ptr >>> 0, 1));

export class StatusDriveProtocol {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusDriveProtocol.prototype);
        obj.__wbg_ptr = ptr;
        StatusDriveProtocolFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusDriveProtocolFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusdriveprotocol_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get latest() {
        const ret = wasm.__wbg_get_statusdriveprotocol_latest(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set latest(arg0) {
        wasm.__wbg_set_statusdriveprotocol_latest(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get current() {
        const ret = wasm.__wbg_get_statusdriveprotocol_current(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set current(arg0) {
        wasm.__wbg_set_statusdriveprotocol_current(this.__wbg_ptr, arg0);
    }
    /**
     * @param {any} obj
     * @returns {StatusDriveProtocol}
     */
    static fromObject(obj) {
        const ret = wasm.statusdriveprotocol_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusDriveProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusdriveprotocol_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusDriveProtocol}
     */
    static fromJSON(js) {
        const ret = wasm.statusdriveprotocol_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusDriveProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusdriveprotocol_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const StatusNetworkFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusnetwork_free(ptr >>> 0, 1));

export class StatusNetwork {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusNetwork.prototype);
        obj.__wbg_ptr = ptr;
        StatusNetworkFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusNetworkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusnetwork_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusNetwork}
     */
    static fromObject(obj) {
        const ret = wasm.statusnetwork_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusNetwork.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusnetwork_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusNetwork}
     */
    static fromJSON(js) {
        const ret = wasm.statusnetwork_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusNetwork.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusnetwork_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get chain_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusnetwork_chain_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set chain_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get peers_count() {
        const ret = wasm.__wbg_get_statusnetwork_peers_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set peers_count(arg0) {
        wasm.__wbg_set_statusnetwork_peers_count(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {boolean}
     */
    get listening() {
        const ret = wasm.__wbg_get_statusnetwork_listening(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set listening(arg0) {
        wasm.__wbg_set_statusnetwork_listening(this.__wbg_ptr, arg0);
    }
}

const StatusNodeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusnode_free(ptr >>> 0, 1));

export class StatusNode {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusNode.prototype);
        obj.__wbg_ptr = ptr;
        StatusNodeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusNodeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusnode_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusNode}
     */
    static fromObject(obj) {
        const ret = wasm.statusnode_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusNode.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusnode_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusNode}
     */
    static fromJSON(js) {
        const ret = wasm.statusnode_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusNode.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusnode_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusnode_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get pro_tx_hash() {
        const ret = wasm.__wbg_get_statusnode_pro_tx_hash(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set pro_tx_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statusnode_pro_tx_hash(this.__wbg_ptr, ptr0, len0);
    }
}

const StatusProtocolFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusprotocol_free(ptr >>> 0, 1));

export class StatusProtocol {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusProtocol.prototype);
        obj.__wbg_ptr = ptr;
        StatusProtocolFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusProtocolFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusprotocol_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusProtocol}
     */
    static fromObject(obj) {
        const ret = wasm.statusprotocol_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusprotocol_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusProtocol}
     */
    static fromJSON(js) {
        const ret = wasm.statusprotocol_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusprotocol_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {StatusTenderdashProtocol}
     */
    get tenderdash() {
        const ret = wasm.__wbg_get_statusprotocol_tenderdash(this.__wbg_ptr);
        return StatusTenderdashProtocol.__wrap(ret);
    }
    /**
     * @param {StatusTenderdashProtocol} arg0
     */
    set tenderdash(arg0) {
        _assertClass(arg0, StatusTenderdashProtocol);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusprotocol_tenderdash(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusDriveProtocol}
     */
    get drive() {
        const ret = wasm.__wbg_get_statusprotocol_drive(this.__wbg_ptr);
        return StatusDriveProtocol.__wrap(ret);
    }
    /**
     * @param {StatusDriveProtocol} arg0
     */
    set drive(arg0) {
        _assertClass(arg0, StatusDriveProtocol);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusprotocol_drive(this.__wbg_ptr, ptr0);
    }
}

const StatusResponseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusresponse_free(ptr >>> 0, 1));

export class StatusResponse {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusResponse.prototype);
        obj.__wbg_ptr = ptr;
        StatusResponseFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusResponseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusresponse_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusResponse}
     */
    static fromObject(obj) {
        const ret = wasm.statusresponse_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusResponse.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusresponse_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusResponse}
     */
    static fromJSON(js) {
        const ret = wasm.statusresponse_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusResponse.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusresponse_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {StatusVersion}
     */
    get version() {
        const ret = wasm.__wbg_get_statusresponse_version(this.__wbg_ptr);
        return StatusVersion.__wrap(ret);
    }
    /**
     * @param {StatusVersion} arg0
     */
    set version(arg0) {
        _assertClass(arg0, StatusVersion);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_version(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusNode}
     */
    get node() {
        const ret = wasm.__wbg_get_statusresponse_node(this.__wbg_ptr);
        return StatusNode.__wrap(ret);
    }
    /**
     * @param {StatusNode} arg0
     */
    set node(arg0) {
        _assertClass(arg0, StatusNode);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_node(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusChain}
     */
    get chain() {
        const ret = wasm.__wbg_get_statusresponse_chain(this.__wbg_ptr);
        return StatusChain.__wrap(ret);
    }
    /**
     * @param {StatusChain} arg0
     */
    set chain(arg0) {
        _assertClass(arg0, StatusChain);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_chain(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusNetwork}
     */
    get network() {
        const ret = wasm.__wbg_get_statusresponse_network(this.__wbg_ptr);
        return StatusNetwork.__wrap(ret);
    }
    /**
     * @param {StatusNetwork} arg0
     */
    set network(arg0) {
        _assertClass(arg0, StatusNetwork);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_network(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusStateSync}
     */
    get state_sync() {
        const ret = wasm.__wbg_get_statusresponse_state_sync(this.__wbg_ptr);
        return StatusStateSync.__wrap(ret);
    }
    /**
     * @param {StatusStateSync} arg0
     */
    set state_sync(arg0) {
        _assertClass(arg0, StatusStateSync);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_state_sync(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusTime}
     */
    get time() {
        const ret = wasm.__wbg_get_statusresponse_time(this.__wbg_ptr);
        return StatusTime.__wrap(ret);
    }
    /**
     * @param {StatusTime} arg0
     */
    set time(arg0) {
        _assertClass(arg0, StatusTime);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusresponse_time(this.__wbg_ptr, ptr0);
    }
}

const StatusSoftwareFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statussoftware_free(ptr >>> 0, 1));

export class StatusSoftware {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusSoftware.prototype);
        obj.__wbg_ptr = ptr;
        StatusSoftwareFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusSoftwareFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statussoftware_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusSoftware}
     */
    static fromObject(obj) {
        const ret = wasm.statussoftware_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusSoftware.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statussoftware_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusSoftware}
     */
    static fromJSON(js) {
        const ret = wasm.statussoftware_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusSoftware.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statussoftware_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get dapi() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statussoftware_dapi(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set dapi(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get drive() {
        const ret = wasm.__wbg_get_statussoftware_drive(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set drive(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statusnode_pro_tx_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get tenderdash() {
        const ret = wasm.__wbg_get_statussoftware_tenderdash(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set tenderdash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statetransitionresult_error(this.__wbg_ptr, ptr0, len0);
    }
}

const StatusStateSyncFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusstatesync_free(ptr >>> 0, 1));

export class StatusStateSync {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusStateSync.prototype);
        obj.__wbg_ptr = ptr;
        StatusStateSyncFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusStateSyncFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusstatesync_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusStateSync}
     */
    static fromObject(obj) {
        const ret = wasm.statusstatesync_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusStateSync.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusstatesync_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusStateSync}
     */
    static fromJSON(js) {
        const ret = wasm.statusstatesync_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusStateSync.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusstatesync_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get total_synced_time() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_total_synced_time(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set total_synced_time(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_path(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get remaining_time() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_remaining_time(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set remaining_time(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyWif(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get total_snapshots() {
        const ret = wasm.__wbg_get_statusstatesync_total_snapshots(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set total_snapshots(arg0) {
        wasm.__wbg_set_statusstatesync_total_snapshots(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get chunk_process_avg_time() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_chunk_process_avg_time(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set chunk_process_avg_time(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_privateKeyHex(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get snapshot_height() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_snapshot_height(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set snapshot_height(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_publicKey(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get snapshot_chunks_count() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_snapshot_chunks_count(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set snapshot_chunks_count(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get backfilled_blocks() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_backfilled_blocks(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set backfilled_blocks(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get backfill_blocks_total() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statusstatesync_backfill_blocks_total(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set backfill_blocks_total(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_dashpaycontactkeyinfo_xprv(this.__wbg_ptr, ptr0, len0);
    }
}

const StatusTenderdashProtocolFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statustenderdashprotocol_free(ptr >>> 0, 1));

export class StatusTenderdashProtocol {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusTenderdashProtocol.prototype);
        obj.__wbg_ptr = ptr;
        StatusTenderdashProtocolFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusTenderdashProtocolFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statustenderdashprotocol_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    get p2p() {
        const ret = wasm.__wbg_get_statustenderdashprotocol_p2p(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set p2p(arg0) {
        wasm.__wbg_set_statusdriveprotocol_latest(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get block() {
        const ret = wasm.__wbg_get_statustenderdashprotocol_block(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set block(arg0) {
        wasm.__wbg_set_statusdriveprotocol_current(this.__wbg_ptr, arg0);
    }
    /**
     * @param {any} obj
     * @returns {StatusTenderdashProtocol}
     */
    static fromObject(obj) {
        const ret = wasm.statustenderdashprotocol_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusTenderdashProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statustenderdashprotocol_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusTenderdashProtocol}
     */
    static fromJSON(js) {
        const ret = wasm.statustenderdashprotocol_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusTenderdashProtocol.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statustenderdashprotocol_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const StatusTimeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statustime_free(ptr >>> 0, 1));

export class StatusTime {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusTime.prototype);
        obj.__wbg_ptr = ptr;
        StatusTimeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusTimeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statustime_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusTime}
     */
    static fromObject(obj) {
        const ret = wasm.statustime_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusTime.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statustime_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusTime}
     */
    static fromJSON(js) {
        const ret = wasm.statustime_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusTime.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statustime_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get local() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_statustime_local(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set local(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statuschain_latest_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get block() {
        const ret = wasm.__wbg_get_statustime_block(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set block(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statustime_block(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string | undefined}
     */
    get genesis() {
        const ret = wasm.__wbg_get_statustime_genesis(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set genesis(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_statustime_genesis(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number | undefined}
     */
    get epoch() {
        const ret = wasm.__wbg_get_statustime_epoch(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set epoch(arg0) {
        wasm.__wbg_set_statuschain_core_chain_locked_height(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : (arg0) >>> 0);
    }
}

const StatusVersionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_statusversion_free(ptr >>> 0, 1));

export class StatusVersion {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StatusVersion.prototype);
        obj.__wbg_ptr = ptr;
        StatusVersionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StatusVersionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_statusversion_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {StatusVersion}
     */
    static fromObject(obj) {
        const ret = wasm.statusversion_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusVersion.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.statusversion_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {StatusVersion}
     */
    static fromJSON(js) {
        const ret = wasm.statusversion_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StatusVersion.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.statusversion_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {StatusSoftware}
     */
    get software() {
        const ret = wasm.__wbg_get_statusversion_software(this.__wbg_ptr);
        return StatusSoftware.__wrap(ret);
    }
    /**
     * @param {StatusSoftware} arg0
     */
    set software(arg0) {
        _assertClass(arg0, StatusSoftware);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusversion_software(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {StatusProtocol}
     */
    get protocol() {
        const ret = wasm.__wbg_get_statusversion_protocol(this.__wbg_ptr);
        return StatusProtocol.__wrap(ret);
    }
    /**
     * @param {StatusProtocol} arg0
     */
    set protocol(arg0) {
        _assertClass(arg0, StatusProtocol);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_statusversion_protocol(this.__wbg_ptr, ptr0);
    }
}

const TimeBasedDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_timebaseddistribution_free(ptr >>> 0, 1));

export class TimeBasedDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TimeBasedDistribution.prototype);
        obj.__wbg_ptr = ptr;
        TimeBasedDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TimeBasedDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_timebaseddistribution_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get interval() {
        const ret = wasm.__wbg_get_timebaseddistribution_interval(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} arg0
     */
    set interval(arg0) {
        wasm.__wbg_set_blockbaseddistribution_interval(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.timebaseddistribution_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {DistributionFunction}
     */
    get function() {
        const ret = wasm.timebaseddistribution_get_function(this.__wbg_ptr);
        return DistributionFunction.__wrap(ret);
    }
    /**
     * @param {DistributionFunction} _function
     */
    set function(_function) {
        _assertClass(_function, DistributionFunction);
        wasm.timebaseddistribution_set_function(this.__wbg_ptr, _function.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.timebaseddistribution_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenBaseTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenbasetransition_free(ptr >>> 0, 1));

export class TokenBaseTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenBaseTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenBaseTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenBaseTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenbasetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenbasetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get tokenId() {
        const ret = wasm.tokenbasetransition_get_token_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identifier
     */
    set tokenId(js_identifier) {
        const ret = wasm.tokenbasetransition_set_token_id(this.__wbg_ptr, js_identifier);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {Identifier}
     */
    get dataContractId() {
        const ret = wasm.tokenbasetransition_get_data_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {GroupStateTransitionInfo | undefined}
     */
    get usingGroupInfo() {
        const ret = wasm.tokenbasetransition_get_using_group_info(this.__wbg_ptr);
        return ret === 0 ? undefined : GroupStateTransitionInfo.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identifier
     */
    set dataContractId(js_identifier) {
        const ret = wasm.tokenbasetransition_set_data_contract_id(this.__wbg_ptr, js_identifier);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_using_group_info
     */
    set usingGroupInfo(js_using_group_info) {
        const ret = wasm.tokenbasetransition_set_using_group_info(this.__wbg_ptr, js_using_group_info);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {bigint}
     */
    get identityContractNonce() {
        const ret = wasm.tokenbasetransition_get_identity_contract_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {number}
     */
    get tokenContractPosition() {
        const ret = wasm.tokenbasetransition_get_token_contract_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {bigint} identity_contract_nonce
     */
    set identityContractNonce(identity_contract_nonce) {
        wasm.tokenbasetransition_set_identity_contract_nonce(this.__wbg_ptr, identity_contract_nonce);
    }
    /**
     * @param {number} pos
     */
    set tokenContractPosition(pos) {
        wasm.tokenbasetransition_set_token_contract_position(this.__wbg_ptr, pos);
    }
    /**
     * @param {bigint} identity_contract_nonce
     * @param {number} token_contract_position
     * @param {Identifier | Uint8Array | string} js_data_contract_id
     * @param {Identifier | Uint8Array | string} js_token_id
     * @param {any} js_using_group_info
     */
    constructor(identity_contract_nonce, token_contract_position, js_data_contract_id, js_token_id, js_using_group_info) {
        const ret = wasm.tokenbasetransition_new(identity_contract_nonce, token_contract_position, js_data_contract_id, js_token_id, js_using_group_info);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenBaseTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenbasetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenBurnResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenburnresult_free(ptr >>> 0, 1));
/**
 * Result of burning tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns owner ID and remaining balance
 * - Tokens with history: returns a document
 * - Group-managed tokens: returns group power and action status
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenBurnResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenBurnResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenBurnResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenBurnResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenburnresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenburnresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The remaining token balance after burning.
     * @returns {bigint | undefined}
     */
    get remainingBalance() {
        const ret = wasm.tokenburnresult_remaining_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * The group action status (for group actions).
     * @returns {string | undefined}
     */
    get groupActionStatus() {
        const ret = wasm.tokenburnresult_group_action_status(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenburnresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
    /**
     * The owner's identity ID (for balance results).
     * @returns {Identifier | undefined}
     */
    get ownerId() {
        const ret = wasm.tokenburnresult_owner_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
}

const TokenBurnTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenburntransition_free(ptr >>> 0, 1));

export class TokenBurnTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenBurnTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenBurnTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenBurnTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenburntransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenburntransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get burnAmount() {
        const ret = wasm.tokenburntransition_get_burn_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenburntransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {bigint} amount
     */
    set burnAmount(amount) {
        wasm.tokenburntransition_set_burn_amount(this.__wbg_ptr, amount);
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenburntransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {bigint} burn_amount
     * @param {string | null} [public_note]
     */
    constructor(base, burn_amount, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenburntransition_new(base.__wbg_ptr, burn_amount, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenBurnTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenburntransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenburntransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenburntransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenClaimResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenclaimresult_free(ptr >>> 0, 1));
/**
 * Result of claiming tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns document
 * - Group-managed tokens: returns group power and document
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenClaimResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenClaimResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenClaimResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenClaimResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenclaimresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenclaimresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The document.
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenclaimresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenClaimTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenclaimtransition_free(ptr >>> 0, 1));

export class TokenClaimTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenClaimTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenClaimTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenClaimTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenclaimtransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenclaimtransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenclaimtransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenclaimtransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get distributionType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenclaimtransition_get_distribution_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_distribution_type
     */
    set distributionType(js_distribution_type) {
        const ret = wasm.tokenclaimtransition_set_distribution_type(this.__wbg_ptr, js_distribution_type);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {any} js_distribution_type
     * @param {string | null} [public_note]
     */
    constructor(base, js_distribution_type, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenclaimtransition_new(base.__wbg_ptr, js_distribution_type, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenClaimTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenclaimtransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenclaimtransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenclaimtransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenConfigUpdateTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenconfigupdatetransition_free(ptr >>> 0, 1));

export class TokenConfigUpdateTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenConfigUpdateTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenConfigUpdateTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenConfigUpdateTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenconfigupdatetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigupdatetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenconfigupdatetransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenconfigupdatetransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {TokenConfigurationChangeItem}
     */
    get updateTokenConfigurationItem() {
        const ret = wasm.tokenconfigupdatetransition_get_update_token_configuration_item(this.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {TokenConfigurationChangeItem} item
     */
    set updateTokenConfigurationItem(item) {
        _assertClass(item, TokenConfigurationChangeItem);
        wasm.tokenconfigupdatetransition_set_update_token_configuration_item(this.__wbg_ptr, item.__wbg_ptr);
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {TokenConfigurationChangeItem} update_token_configuration_item
     * @param {string | null} [public_note]
     */
    constructor(base, update_token_configuration_item, public_note) {
        _assertClass(base, TokenBaseTransition);
        _assertClass(update_token_configuration_item, TokenConfigurationChangeItem);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenconfigupdatetransition_new(base.__wbg_ptr, update_token_configuration_item.__wbg_ptr, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenConfigUpdateTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenconfigupdatetransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenconfigupdatetransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigupdatetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenConfigurationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenconfiguration_free(ptr >>> 0, 1));

export class TokenConfiguration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenConfiguration.prototype);
        obj.__wbg_ptr = ptr;
        TokenConfigurationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenConfigurationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenconfiguration_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfiguration_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get maxSupply() {
        const ret = wasm.tokenconfiguration_get_max_supply(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [max_supply]
     */
    set maxSupply(max_supply) {
        wasm.tokenconfiguration_set_max_supply(this.__wbg_ptr, !isLikeNone(max_supply), isLikeNone(max_supply) ? BigInt(0) : max_supply);
    }
    /**
     * @returns {bigint}
     */
    get baseSupply() {
        const ret = wasm.tokenconfiguration_get_base_supply(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {TokenConfigurationConvention}
     */
    get conventions() {
        const ret = wasm.tokenconfiguration_get_conventions(this.__wbg_ptr);
        return TokenConfigurationConvention.__wrap(ret);
    }
    /**
     * @returns {string | undefined}
     */
    get description() {
        const ret = wasm.tokenconfiguration_get_description(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {bigint} base_supply
     */
    set baseSupply(base_supply) {
        wasm.tokenconfiguration_set_base_supply(this.__wbg_ptr, base_supply);
    }
    /**
     * @param {TokenConfigurationConvention} conventions
     */
    set conventions(conventions) {
        _assertClass(conventions, TokenConfigurationConvention);
        wasm.tokenconfiguration_set_conventions(this.__wbg_ptr, conventions.__wbg_ptr);
    }
    /**
     * @param {string | null} [description]
     */
    set description(description) {
        var ptr0 = isLikeNone(description) ? 0 : passStringToWasm0(description, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenconfiguration_set_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get freezeRules() {
        const ret = wasm.tokenconfiguration_get_freeze_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set freezeRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_freeze_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {TokenKeepsHistoryRules}
     */
    get keepsHistory() {
        const ret = wasm.tokenconfiguration_get_keeps_history(this.__wbg_ptr);
        return TokenKeepsHistoryRules.__wrap(ret);
    }
    /**
     * @param {TokenKeepsHistoryRules} keeps_history
     */
    set keepsHistory(keeps_history) {
        _assertClass(keeps_history, TokenKeepsHistoryRules);
        wasm.tokenconfiguration_set_keeps_history(this.__wbg_ptr, keeps_history.__wbg_ptr);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     * @param {number} token_pos
     * @returns {Identifier}
     */
    static calculateTokenId(js_contract_id, token_pos) {
        const ret = wasm.tokenconfiguration_calculateTokenId(js_contract_id, token_pos);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get unfreezeRules() {
        const ret = wasm.tokenconfiguration_get_unfreeze_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set unfreezeRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_unfreeze_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {boolean}
     */
    get startAsPaused() {
        const ret = wasm.tokenconfiguration_get_start_as_paused(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} start_as_paused
     */
    set startAsPaused(start_as_paused) {
        wasm.tokenconfiguration_set_start_as_paused(this.__wbg_ptr, start_as_paused);
    }
    /**
     * @returns {TokenMarketplaceRules}
     */
    get marketplaceRules() {
        const ret = wasm.tokenconfiguration_get_marketplace_rules(this.__wbg_ptr);
        return TokenMarketplaceRules.__wrap(ret);
    }
    /**
     * @param {TokenMarketplaceRules} marketplace_rules
     */
    set marketplaceRules(marketplace_rules) {
        _assertClass(marketplace_rules, TokenMarketplaceRules);
        wasm.tokenconfiguration_set_marketplace_rules(this.__wbg_ptr, marketplace_rules.__wbg_ptr);
    }
    /**
     * @returns {TokenDistributionRules}
     */
    get distributionRules() {
        const ret = wasm.tokenconfiguration_get_distribution_rules(this.__wbg_ptr);
        return TokenDistributionRules.__wrap(ret);
    }
    /**
     * @returns {number | undefined}
     */
    get mainControlGroup() {
        const ret = wasm.tokenconfiguration_get_main_control_group(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
     * @param {TokenDistributionRules} rules
     */
    set distributionRules(rules) {
        _assertClass(rules, TokenDistributionRules);
        wasm.tokenconfiguration_set_distribution_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @param {number | null} [group]
     */
    set mainControlGroup(group) {
        wasm.tokenconfiguration_set_main_control_group(this.__wbg_ptr, isLikeNone(group) ? 0xFFFFFF : group);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get manualBurningRules() {
        const ret = wasm.tokenconfiguration_get_manual_burning_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get manualMintingRules() {
        const ret = wasm.tokenconfiguration_get_manual_minting_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set manualBurningRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_manual_burning_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set manualMintingRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_manual_minting_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get emergencyActionRules() {
        const ret = wasm.tokenconfiguration_get_emergency_action_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set emergencyActionRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_emergency_action_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get maxSupplyChangeRules() {
        const ret = wasm.tokenconfiguration_get_max_supply_change_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set maxSupplyChangeRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_max_supply_change_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get conventionsChangeRules() {
        const ret = wasm.tokenconfiguration_get_conventions_change_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set conventionsChangeRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_conventions_change_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get destroyFrozenFundsRules() {
        const ret = wasm.tokenconfiguration_get_destroy_frozen_funds_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set destroyFrozenFundsRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokenconfiguration_set_destroy_frozen_funds_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {AuthorizedActionTakers}
     */
    get mainControlGroupCanBeModified() {
        const ret = wasm.tokenconfiguration_get_main_control_group_can_be_modified(this.__wbg_ptr);
        return AuthorizedActionTakers.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} authorized_action_taker
     */
    set mainControlGroupCanBeModified(authorized_action_taker) {
        _assertClass(authorized_action_taker, AuthorizedActionTakers);
        wasm.tokenconfiguration_set_main_control_group_can_be_modified(this.__wbg_ptr, authorized_action_taker.__wbg_ptr);
    }
    /**
     * @param {TokenConfigurationConvention} conventions
     * @param {ChangeControlRules} conventions_change_rules
     * @param {bigint} base_supply
     * @param {bigint | null | undefined} max_supply
     * @param {TokenKeepsHistoryRules} keeps_history
     * @param {boolean} start_as_paused
     * @param {boolean} allow_transfer_to_frozen_balance
     * @param {ChangeControlRules} max_supply_change_rules
     * @param {TokenDistributionRules} distribution_rules
     * @param {TokenMarketplaceRules} marketplace_rules
     * @param {ChangeControlRules} manual_minting_rules
     * @param {ChangeControlRules} manual_burning_rules
     * @param {ChangeControlRules} freeze_rules
     * @param {ChangeControlRules} unfreeze_rules
     * @param {ChangeControlRules} destroy_frozen_funds_rules
     * @param {ChangeControlRules} emergency_action_rules
     * @param {number | null | undefined} main_control_group
     * @param {AuthorizedActionTakers} main_control_group_can_be_modified
     * @param {string | null} [description]
     */
    constructor(conventions, conventions_change_rules, base_supply, max_supply, keeps_history, start_as_paused, allow_transfer_to_frozen_balance, max_supply_change_rules, distribution_rules, marketplace_rules, manual_minting_rules, manual_burning_rules, freeze_rules, unfreeze_rules, destroy_frozen_funds_rules, emergency_action_rules, main_control_group, main_control_group_can_be_modified, description) {
        _assertClass(conventions, TokenConfigurationConvention);
        _assertClass(conventions_change_rules, ChangeControlRules);
        _assertClass(keeps_history, TokenKeepsHistoryRules);
        _assertClass(max_supply_change_rules, ChangeControlRules);
        _assertClass(distribution_rules, TokenDistributionRules);
        _assertClass(marketplace_rules, TokenMarketplaceRules);
        _assertClass(manual_minting_rules, ChangeControlRules);
        _assertClass(manual_burning_rules, ChangeControlRules);
        _assertClass(freeze_rules, ChangeControlRules);
        _assertClass(unfreeze_rules, ChangeControlRules);
        _assertClass(destroy_frozen_funds_rules, ChangeControlRules);
        _assertClass(emergency_action_rules, ChangeControlRules);
        _assertClass(main_control_group_can_be_modified, AuthorizedActionTakers);
        var ptr0 = isLikeNone(description) ? 0 : passStringToWasm0(description, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenconfiguration_new(conventions.__wbg_ptr, conventions_change_rules.__wbg_ptr, base_supply, !isLikeNone(max_supply), isLikeNone(max_supply) ? BigInt(0) : max_supply, keeps_history.__wbg_ptr, start_as_paused, allow_transfer_to_frozen_balance, max_supply_change_rules.__wbg_ptr, distribution_rules.__wbg_ptr, marketplace_rules.__wbg_ptr, manual_minting_rules.__wbg_ptr, manual_burning_rules.__wbg_ptr, freeze_rules.__wbg_ptr, unfreeze_rules.__wbg_ptr, destroy_frozen_funds_rules.__wbg_ptr, emergency_action_rules.__wbg_ptr, isLikeNone(main_control_group) ? 0xFFFFFF : main_control_group, main_control_group_can_be_modified.__wbg_ptr, ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        TokenConfigurationFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {boolean}
     */
    get isAllowedTransferToFrozenBalance() {
        const ret = wasm.tokenconfiguration_get_is_allowed_transfer_to_frozen_balance(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} is_allowed_transfer_to_frozen_balance
     */
    set isAllowedTransferToFrozenBalance(is_allowed_transfer_to_frozen_balance) {
        wasm.tokenconfiguration_set_is_allowed_transfer_to_frozen_balance(this.__wbg_ptr, is_allowed_transfer_to_frozen_balance);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfiguration_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenConfigurationChangeItemFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenconfigurationchangeitem_free(ptr >>> 0, 1));

export class TokenConfigurationChangeItem {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenConfigurationChangeItem.prototype);
        obj.__wbg_ptr = ptr;
        TokenConfigurationChangeItemFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenConfigurationChangeItemFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenconfigurationchangeitem_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationchangeitem_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    getItemName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationchangeitem_getItemName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    getItem() {
        const ret = wasm.tokenconfigurationchangeitem_getItem(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationchangeitem_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {bigint | null} [supply]
     * @returns {TokenConfigurationChangeItem}
     */
    static MaxSupplyItem(supply) {
        const ret = wasm.tokenconfigurationchangeitem_MaxSupplyItem(!isLikeNone(supply), isLikeNone(supply) ? BigInt(0) : supply);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MaxSupplyAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MaxSupplyAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MaxSupplyControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MaxSupplyControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {TokenConfigurationConvention} convention
     * @returns {TokenConfigurationChangeItem}
     */
    static conventionsItem(convention) {
        _assertClass(convention, TokenConfigurationConvention);
        const ret = wasm.tokenconfigurationchangeitem_conventionsItem(convention.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ConventionsAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ConventionsAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ConventionsControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ConventionsControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ManualBurningItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ManualBurningItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ManualBurningAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ManualBurningAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ManualMintingItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ManualMintingItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static ManualMintingAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_ManualMintingAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static EmergencyActionItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_EmergencyActionItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static EmergencyActionAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_EmergencyActionAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {number | null} [group_contract_position]
     * @returns {TokenConfigurationChangeItem}
     */
    static MainControlGroupItem(group_contract_position) {
        const ret = wasm.tokenconfigurationchangeitem_MainControlGroupItem(isLikeNone(group_contract_position) ? 0xFFFFFF : group_contract_position);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static DestroyFrozenFundsItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_DestroyFrozenFundsItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static DestroyFrozenFundsAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_DestroyFrozenFundsAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {TokenTradeMode} trade_mode
     * @returns {TokenConfigurationChangeItem}
     */
    static MarketplaceTradeModeItem(trade_mode) {
        _assertClass(trade_mode, TokenTradeMode);
        const ret = wasm.tokenconfigurationchangeitem_MarketplaceTradeModeItem(trade_mode.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MarketplaceTradeModeAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MarketplaceTradeModeAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MarketplaceTradeModeControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MarketplaceTradeModeControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {any} js_perpetual_distribution_value
     * @returns {TokenConfigurationChangeItem}
     */
    static PerpetualDistributionConfigurationItem(js_perpetual_distribution_value) {
        const ret = wasm.tokenconfigurationchangeitem_PerpetualDistributionConfigurationItem(js_perpetual_distribution_value);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static PerpetualDistributionAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_PerpetualDistributionAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static PerpetualDistributionControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_PerpetualDistributionControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @returns {TokenConfigurationChangeItem}
     */
    static NewTokensDestinationIdentityItem(js_identity_id) {
        const ret = wasm.tokenconfigurationchangeitem_NewTokensDestinationIdentityItem(js_identity_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenConfigurationChangeItem.__wrap(ret[0]);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static NewTokensDestinationIdentityAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_NewTokensDestinationIdentityAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static NewTokensDestinationIdentityControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_NewTokensDestinationIdentityControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {boolean} flag
     * @returns {TokenConfigurationChangeItem}
     */
    static MintingAllowChoosingDestinationItem(flag) {
        const ret = wasm.tokenconfigurationchangeitem_MintingAllowChoosingDestinationItem(flag);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MintingAllowChoosingDestinationAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MintingAllowChoosingDestinationAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static MintingAllowChoosingDestinationControlGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_MintingAllowChoosingDestinationControlGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static FreezeItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_FreezeItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static FreezeAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_FreezeAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static UnfreezeItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_UnfreezeItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @param {AuthorizedActionTakers} action_taker
     * @returns {TokenConfigurationChangeItem}
     */
    static UnfreezeAdminGroupItem(action_taker) {
        _assertClass(action_taker, AuthorizedActionTakers);
        const ret = wasm.tokenconfigurationchangeitem_UnfreezeAdminGroupItem(action_taker.__wbg_ptr);
        return TokenConfigurationChangeItem.__wrap(ret);
    }
    /**
     * @returns {TokenConfigurationChangeItem}
     */
    static noChangeItem() {
        const ret = wasm.tokenconfigurationchangeitem_noChangeItem();
        return TokenConfigurationChangeItem.__wrap(ret);
    }
}

const TokenConfigurationConventionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenconfigurationconvention_free(ptr >>> 0, 1));

export class TokenConfigurationConvention {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenConfigurationConvention.prototype);
        obj.__wbg_ptr = ptr;
        TokenConfigurationConventionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenConfigurationConventionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenconfigurationconvention_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationconvention_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {number} decimals
     */
    set decimals(decimals) {
        wasm.tokenconfigurationconvention_set_decimals(this.__wbg_ptr, decimals);
    }
    /**
     * @returns {any}
     */
    get localizations() {
        const ret = wasm.tokenconfigurationconvention_localizations(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_localizations
     */
    set localizations(js_localizations) {
        const ret = wasm.tokenconfigurationconvention_set_localizations(this.__wbg_ptr, js_localizations);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_localizations
     * @param {number} decimals
     */
    constructor(js_localizations, decimals) {
        const ret = wasm.tokenconfigurationconvention_new(js_localizations, decimals);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenConfigurationConventionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    get decimals() {
        const ret = wasm.tokenconfigurationconvention_decimals(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationconvention_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenConfigurationLocalizationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenconfigurationlocalization_free(ptr >>> 0, 1));

export class TokenConfigurationLocalization {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenConfigurationLocalization.prototype);
        obj.__wbg_ptr = ptr;
        TokenConfigurationLocalizationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenConfigurationLocalizationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenconfigurationlocalization_free(ptr, 0);
    }
    /**
     * @param {any} js_value
     * @returns {TokenConfigurationLocalization}
     */
    static fromObject(js_value) {
        const ret = wasm.tokenconfigurationlocalization_fromObject(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenConfigurationLocalization.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationlocalization_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get pluralForm() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationlocalization_get_plural_form(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} plural_form
     */
    set pluralForm(plural_form) {
        const ptr0 = passStringToWasm0(plural_form, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.tokenconfigurationlocalization_set_plural_form(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get singularForm() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationlocalization_get_singular_form(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} singular_form
     */
    set singularForm(singular_form) {
        const ptr0 = passStringToWasm0(singular_form, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.tokenconfigurationlocalization_set_singular_form(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean}
     */
    get shouldCapitalize() {
        const ret = wasm.tokenconfigurationlocalization_get_should_capitalize(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} capitalize
     */
    set shouldCapitalize(capitalize) {
        wasm.tokenconfigurationlocalization_set_should_capitalize(this.__wbg_ptr, capitalize);
    }
    /**
     * @param {boolean} should_capitalize
     * @param {string} singular_form
     * @param {string} plural_form
     */
    constructor(should_capitalize, singular_form, plural_form) {
        const ptr0 = passStringToWasm0(singular_form, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(plural_form, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.tokenconfigurationlocalization_new(should_capitalize, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        TokenConfigurationLocalizationFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.tokenconfigurationlocalization_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_value
     * @returns {TokenConfigurationLocalization}
     */
    static fromJSON(js_value) {
        const ret = wasm.tokenconfigurationlocalization_fromJSON(js_value);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenConfigurationLocalization.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.tokenconfigurationlocalization_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenconfigurationlocalization_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenContractInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokencontractinfo_free(ptr >>> 0, 1));

export class TokenContractInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenContractInfo.prototype);
        obj.__wbg_ptr = ptr;
        TokenContractInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenContractInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokencontractinfo_free(ptr, 0);
    }
    /**
     * @returns {Identifier}
     */
    get contractId() {
        const ret = wasm.tokencontractinfo_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    get tokenContractPosition() {
        const ret = wasm.tokencontractinfo_token_contract_position(this.__wbg_ptr);
        return ret;
    }
}

const TokenDestroyFrozenFundsTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendestroyfrozenfundstransition_free(ptr >>> 0, 1));

export class TokenDestroyFrozenFundsTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDestroyFrozenFundsTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenDestroyFrozenFundsTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDestroyFrozenFundsTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendestroyfrozenfundstransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendestroyfrozenfundstransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokendestroyfrozenfundstransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokendestroyfrozenfundstransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get frozenIdentityId() {
        const ret = wasm.tokendestroyfrozenfundstransition_get_frozen_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_frozen_identity_id
     */
    set frozenIdentityId(js_frozen_identity_id) {
        const ret = wasm.tokendestroyfrozenfundstransition_set_frozen_identity_id(this.__wbg_ptr, js_frozen_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {Identifier | Uint8Array | string} js_frozen_identity_id
     * @param {string | null} [public_note]
     */
    constructor(base, js_frozen_identity_id, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokendestroyfrozenfundstransition_new(base.__wbg_ptr, js_frozen_identity_id, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenDestroyFrozenFundsTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokendestroyfrozenfundstransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokendestroyfrozenfundstransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendestroyfrozenfundstransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenDestroyFrozenResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendestroyfrozenresult_free(ptr >>> 0, 1));
/**
 * Result of destroying frozen tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns historical document
 * - Group-managed tokens: returns group power and document
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenDestroyFrozenResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDestroyFrozenResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenDestroyFrozenResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDestroyFrozenResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendestroyfrozenresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokendestroyfrozenresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokendestroyfrozenresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenDirectPurchaseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendirectpurchaseresult_free(ptr >>> 0, 1));
/**
 * Result of a direct token purchase.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns balance
 * - Tokens with history: returns document
 * - Group-managed tokens: returns group power and document
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenDirectPurchaseResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDirectPurchaseResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenDirectPurchaseResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDirectPurchaseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendirectpurchaseresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokendirectpurchaseresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The buyer's new balance after purchase.
     * @returns {bigint | undefined}
     */
    get newBalance() {
        const ret = wasm.tokendirectpurchaseresult_new_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * The buyer's identity ID.
     * @returns {Identifier | undefined}
     */
    get buyerId() {
        const ret = wasm.tokendirectpurchaseresult_buyer_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokendirectpurchaseresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenDirectPurchaseTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendirectpurchasetransition_free(ptr >>> 0, 1));

export class TokenDirectPurchaseTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDirectPurchaseTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenDirectPurchaseTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDirectPurchaseTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendirectpurchasetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendirectpurchasetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint}
     */
    get tokenCount() {
        const ret = wasm.tokendirectpurchasetransition_get_token_count(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} token_count
     */
    set tokenCount(token_count) {
        wasm.tokendirectpurchasetransition_set_token_count(this.__wbg_ptr, token_count);
    }
    /**
     * @returns {bigint}
     */
    get totalAgreedPrice() {
        const ret = wasm.tokendirectpurchasetransition_get_total_agreed_price(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} total_agreed_price
     */
    set totalAgreedPrice(total_agreed_price) {
        wasm.tokendirectpurchasetransition_set_total_agreed_price(this.__wbg_ptr, total_agreed_price);
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {bigint} token_count
     * @param {bigint} total_agreed_price
     */
    constructor(base, token_count, total_agreed_price) {
        _assertClass(base, TokenBaseTransition);
        const ret = wasm.tokendirectpurchasetransition_new(base.__wbg_ptr, token_count, total_agreed_price);
        this.__wbg_ptr = ret >>> 0;
        TokenDirectPurchaseTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokendirectpurchasetransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokendirectpurchasetransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendirectpurchasetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenDistributionRecipientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendistributionrecipient_free(ptr >>> 0, 1));

export class TokenDistributionRecipient {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDistributionRecipient.prototype);
        obj.__wbg_ptr = ptr;
        TokenDistributionRecipientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDistributionRecipientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendistributionrecipient_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendistributionrecipient_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {TokenDistributionRecipient}
     */
    static ContractOwner() {
        const ret = wasm.tokendistributionrecipient_ContractOwner();
        return TokenDistributionRecipient.__wrap(ret);
    }
    /**
     * @returns {TokenDistributionRecipient}
     */
    static EvonodesByParticipation() {
        const ret = wasm.tokendistributionrecipient_EvonodesByParticipation();
        return TokenDistributionRecipient.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendistributionrecipient_getType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identity_id
     * @returns {TokenDistributionRecipient}
     */
    static Identity(js_identity_id) {
        const ret = wasm.tokendistributionrecipient_Identity(js_identity_id);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenDistributionRecipient.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    getValue() {
        const ret = wasm.tokendistributionrecipient_getValue(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendistributionrecipient_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenDistributionRulesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokendistributionrules_free(ptr >>> 0, 1));

export class TokenDistributionRules {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenDistributionRules.prototype);
        obj.__wbg_ptr = ptr;
        TokenDistributionRulesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenDistributionRulesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokendistributionrules_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendistributionrules_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {TokenPerpetualDistribution | undefined}
     */
    get perpetualDistribution() {
        const ret = wasm.tokendistributionrules_get_perpetual_distribution(this.__wbg_ptr);
        return ret === 0 ? undefined : TokenPerpetualDistribution.__wrap(ret);
    }
    /**
     * @param {any} js_perpetual_distribution
     */
    set perpetualDistribution(js_perpetual_distribution) {
        const ret = wasm.tokendistributionrules_set_perpetual_distribution(this.__wbg_ptr, js_perpetual_distribution);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {TokenPreProgrammedDistribution | undefined}
     */
    get preProgrammedDistribution() {
        const ret = wasm.tokendistributionrules_get_pre_programmed_distribution(this.__wbg_ptr);
        return ret === 0 ? undefined : TokenPreProgrammedDistribution.__wrap(ret);
    }
    /**
     * @param {any} js_distribution
     */
    set preProgrammedDistribution(js_distribution) {
        const ret = wasm.tokendistributionrules_set_pre_programmed_distribution(this.__wbg_ptr, js_distribution);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {ChangeControlRules}
     */
    get perpetualDistributionRules() {
        const ret = wasm.tokendistributionrules_get_perpetual_distribution_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set perpetualDistributionRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokendistributionrules_set_perpetual_distribution_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {Identifier | undefined}
     */
    get newTokenDestinationIdentity() {
        const ret = wasm.tokendistributionrules_get_new_tokens_destination_identity(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_identifier
     */
    set newTokenDestinationIdentity(js_identifier) {
        const ret = wasm.tokendistributionrules_set_new_tokens_destination_identity(this.__wbg_ptr, js_identifier);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {boolean}
     */
    get mintingAllowChoosingDestination() {
        const ret = wasm.tokendistributionrules_get_minting_allow_choosing_destination(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} flag
     */
    set mintingAllowChoosingDestination(flag) {
        wasm.tokendistributionrules_set_minting_allow_choosing_destination(this.__wbg_ptr, flag);
    }
    /**
     * @param {any} js_perpetual_distribution
     * @param {ChangeControlRules} perpetual_distribution_rules
     * @param {any} js_pre_programmed_distribution
     * @param {Identifier | Uint8Array | string} js_new_tokens_destination_identity
     * @param {ChangeControlRules} new_tokens_destination_identity_rules
     * @param {boolean} minting_allow_choosing_destination
     * @param {ChangeControlRules} minting_allow_choosing_destination_rules
     * @param {ChangeControlRules} change_direct_purchase_pricing_rules
     */
    constructor(js_perpetual_distribution, perpetual_distribution_rules, js_pre_programmed_distribution, js_new_tokens_destination_identity, new_tokens_destination_identity_rules, minting_allow_choosing_destination, minting_allow_choosing_destination_rules, change_direct_purchase_pricing_rules) {
        _assertClass(perpetual_distribution_rules, ChangeControlRules);
        _assertClass(new_tokens_destination_identity_rules, ChangeControlRules);
        _assertClass(minting_allow_choosing_destination_rules, ChangeControlRules);
        _assertClass(change_direct_purchase_pricing_rules, ChangeControlRules);
        const ret = wasm.tokendistributionrules_new(js_perpetual_distribution, perpetual_distribution_rules.__wbg_ptr, js_pre_programmed_distribution, js_new_tokens_destination_identity, new_tokens_destination_identity_rules.__wbg_ptr, minting_allow_choosing_destination, minting_allow_choosing_destination_rules.__wbg_ptr, change_direct_purchase_pricing_rules.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenDistributionRulesFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {ChangeControlRules}
     */
    get changeDirectPurchasePricingRules() {
        const ret = wasm.tokendistributionrules_get_change_direct_purchase_pricing_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set changeDirectPurchasePricingRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokendistributionrules_set_change_direct_purchase_pricing_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get newTokenDestinationIdentityRules() {
        const ret = wasm.tokendistributionrules_get_new_tokens_destination_identity_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set newTokenDestinationIdentityRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokendistributionrules_set_new_tokens_destination_identity_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get mintingAllowChoosingDestinationRules() {
        const ret = wasm.tokendistributionrules_get_minting_allow_choosing_destination_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} rules
     */
    set mintingAllowChoosingDestinationRules(rules) {
        _assertClass(rules, ChangeControlRules);
        wasm.tokendistributionrules_set_minting_allow_choosing_destination_rules(this.__wbg_ptr, rules.__wbg_ptr);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokendistributionrules_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenEmergencyActionResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenemergencyactionresult_free(ptr >>> 0, 1));
/**
 * Result of an emergency action.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns document
 * - Group-managed tokens: returns group power and document
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenEmergencyActionResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenEmergencyActionResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenEmergencyActionResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenEmergencyActionResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenemergencyactionresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenemergencyactionresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The document.
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenemergencyactionresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenEmergencyActionTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenemergencyactiontransition_free(ptr >>> 0, 1));

export class TokenEmergencyActionTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenEmergencyActionTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenEmergencyActionTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenEmergencyActionTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenemergencyactiontransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenemergencyactiontransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenemergencyactiontransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenemergencyactiontransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get emergencyAction() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenemergencyactiontransition_get_emergency_action(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {TokenEmergencyAction} action
     */
    set emergencyAction(action) {
        wasm.tokenemergencyactiontransition_set_emergency_action(this.__wbg_ptr, action);
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {TokenEmergencyAction} emergency_action
     * @param {string | null} [public_note]
     */
    constructor(base, emergency_action, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenemergencyactiontransition_new(base.__wbg_ptr, emergency_action, ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        TokenEmergencyActionTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenemergencyactiontransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenemergencyactiontransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenemergencyactiontransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenevent_free(ptr >>> 0, 1));

export class TokenEvent {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenEvent.prototype);
        obj.__wbg_ptr = ptr;
        TokenEventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenevent_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {TokenEvent}
     */
    static fromObject(obj) {
        const ret = wasm.tokenevent_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenEvent.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenevent_struct_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.tokenevent_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {TokenEventVariant}
     */
    get variant() {
        const ret = wasm.tokenevent_variant(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} js
     * @returns {TokenEvent}
     */
    static fromJSON(js) {
        const ret = wasm.tokenevent_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenEvent.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.tokenevent_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenevent_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenFreezeResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenfreezeresult_free(ptr >>> 0, 1));
/**
 * Result of freezing tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns frozen identity ID
 * - Tokens with history: returns a document
 * - Group-managed tokens: returns group power and status
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenFreezeResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenFreezeResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenFreezeResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenFreezeResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenfreezeresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenfreezeresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The identity ID that was frozen.
     * @returns {Identifier | undefined}
     */
    get frozenIdentityId() {
        const ret = wasm.tokenfreezeresult_frozen_identity_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenfreezeresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenFreezeTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenfreezetransition_free(ptr >>> 0, 1));

export class TokenFreezeTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenFreezeTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenFreezeTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenFreezeTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenfreezetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenfreezetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenfreezetransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenfreezetransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get frozenIdentityId() {
        const ret = wasm.tokenfreezetransition_get_frozen_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_frozen_identity_id
     */
    set frozenIdentityId(js_frozen_identity_id) {
        const ret = wasm.tokenfreezetransition_set_frozen_identity_id(this.__wbg_ptr, js_frozen_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {Identifier | Uint8Array | string} js_identity_to_freeze_id
     * @param {string | null} [public_note]
     */
    constructor(base, js_identity_to_freeze_id, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenfreezetransition_new(base.__wbg_ptr, js_identity_to_freeze_id, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenFreezeTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenfreezetransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenfreezetransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenfreezetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenKeepsHistoryRulesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenkeepshistoryrules_free(ptr >>> 0, 1));

export class TokenKeepsHistoryRules {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenKeepsHistoryRules.prototype);
        obj.__wbg_ptr = ptr;
        TokenKeepsHistoryRulesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenKeepsHistoryRulesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenkeepshistoryrules_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenkeepshistoryrules_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {boolean}
     */
    get keepsBurningHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_burning_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    get keepsMintingHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_minting_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} keeps_burning_history
     */
    set keepsBurningHistory(keeps_burning_history) {
        wasm.tokenkeepshistoryrules_set_keeps_burning_history(this.__wbg_ptr, keeps_burning_history);
    }
    /**
     * @param {boolean} keeps_minting_history
     */
    set keepsMintingHistory(keeps_minting_history) {
        wasm.tokenkeepshistoryrules_set_keeps_minting_history(this.__wbg_ptr, keeps_minting_history);
    }
    /**
     * @returns {boolean}
     */
    get keepsFreezingHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_freezing_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    get keepsTransferHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_transfer_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} keeps_freezing_history
     */
    set keepsFreezingHistory(keeps_freezing_history) {
        wasm.tokenkeepshistoryrules_set_keeps_freezing_history(this.__wbg_ptr, keeps_freezing_history);
    }
    /**
     * @param {boolean} keeps_transfer_history
     */
    set keepsTransferHistory(keeps_transfer_history) {
        wasm.tokenkeepshistoryrules_set_keeps_transfer_history(this.__wbg_ptr, keeps_transfer_history);
    }
    /**
     * @returns {boolean}
     */
    get keepsDirectPricingHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_direct_pricing_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} keeps_direct_pricing_history
     */
    set keepsDirectPricingHistory(keeps_direct_pricing_history) {
        wasm.tokenkeepshistoryrules_set_keeps_direct_pricing_history(this.__wbg_ptr, keeps_direct_pricing_history);
    }
    /**
     * @returns {boolean}
     */
    get keepsDirectPurchaseHistory() {
        const ret = wasm.tokenkeepshistoryrules_get_keeps_direct_purchase_history(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} keeps_direct_purchase_history
     */
    set keepsDirectPurchaseHistory(keeps_direct_purchase_history) {
        wasm.tokenkeepshistoryrules_set_keeps_direct_purchase_history(this.__wbg_ptr, keeps_direct_purchase_history);
    }
    /**
     * @param {boolean} keeps_transfer_history
     * @param {boolean} keeps_freezing_history
     * @param {boolean} keeps_minting_history
     * @param {boolean} keeps_burning_history
     * @param {boolean} keeps_direct_pricing_history
     * @param {boolean} keeps_direct_purchase_history
     */
    constructor(keeps_transfer_history, keeps_freezing_history, keeps_minting_history, keeps_burning_history, keeps_direct_pricing_history, keeps_direct_purchase_history) {
        const ret = wasm.tokenkeepshistoryrules_new(keeps_transfer_history, keeps_freezing_history, keeps_minting_history, keeps_burning_history, keeps_direct_pricing_history, keeps_direct_purchase_history);
        this.__wbg_ptr = ret >>> 0;
        TokenKeepsHistoryRulesFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenkeepshistoryrules_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenMarketplaceRulesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenmarketplacerules_free(ptr >>> 0, 1));

export class TokenMarketplaceRules {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenMarketplaceRules.prototype);
        obj.__wbg_ptr = ptr;
        TokenMarketplaceRulesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenMarketplaceRulesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenmarketplacerules_free(ptr, 0);
    }
    /**
     * @returns {TokenTradeMode}
     */
    get tradeMode() {
        const ret = wasm.tokenmarketplacerules_trade_mode(this.__wbg_ptr);
        return TokenTradeMode.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenmarketplacerules_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {TokenTradeMode} trade_mode
     */
    set tradeMode(trade_mode) {
        _assertClass(trade_mode, TokenTradeMode);
        wasm.tokenmarketplacerules_set_trade_mode(this.__wbg_ptr, trade_mode.__wbg_ptr);
    }
    /**
     * @returns {ChangeControlRules}
     */
    get tradeModeChangeRules() {
        const ret = wasm.tokenmarketplacerules_trade_mode_change_rules(this.__wbg_ptr);
        return ChangeControlRules.__wrap(ret);
    }
    /**
     * @param {ChangeControlRules} trade_mode_change_rules
     */
    set tradeModeChangeRules(trade_mode_change_rules) {
        _assertClass(trade_mode_change_rules, ChangeControlRules);
        wasm.tokenmarketplacerules_set_trade_mode_change_rules(this.__wbg_ptr, trade_mode_change_rules.__wbg_ptr);
    }
    /**
     * @param {TokenTradeMode} trade_mode
     * @param {ChangeControlRules} trade_mode_change_rules
     */
    constructor(trade_mode, trade_mode_change_rules) {
        _assertClass(trade_mode, TokenTradeMode);
        _assertClass(trade_mode_change_rules, ChangeControlRules);
        const ret = wasm.tokenmarketplacerules_new(trade_mode.__wbg_ptr, trade_mode_change_rules.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        TokenMarketplaceRulesFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenmarketplacerules_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenMintResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenmintresult_free(ptr >>> 0, 1));
/**
 * Result of minting tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns recipient ID and new balance
 * - Tokens with history: returns a document
 * - Group-managed tokens: returns group power and action status
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenMintResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenMintResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenMintResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenMintResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenmintresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenmintresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The new token balance after minting.
     * @returns {bigint | undefined}
     */
    get newBalance() {
        const ret = wasm.tokenmintresult_new_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * The recipient's identity ID (for balance results).
     * @returns {Identifier | undefined}
     */
    get recipientId() {
        const ret = wasm.tokenmintresult_recipient_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * The group action status (for group actions).
     * @returns {string | undefined}
     */
    get groupActionStatus() {
        const ret = wasm.tokenmintresult_group_action_status(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenmintresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenMintTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenminttransition_free(ptr >>> 0, 1));

export class TokenMintTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenMintTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenMintTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenMintTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenminttransition_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.tokenminttransition_get_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} amount
     */
    set amount(amount) {
        wasm.tokenminttransition_set_amount(this.__wbg_ptr, amount);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenminttransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {TokenConfiguration} config
     * @returns {Identifier}
     */
    getRecipientId(config) {
        _assertClass(config, TokenConfiguration);
        const ret = wasm.tokenminttransition_getRecipientId(this.__wbg_ptr, config.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenminttransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenminttransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier | undefined}
     */
    get issuedToIdentityId() {
        const ret = wasm.tokenminttransition_issued_to_identity_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     */
    set issuedToIdentityId(js_id) {
        const ret = wasm.tokenminttransition_set_issued_to_identity_id(this.__wbg_ptr, js_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {Identifier | Uint8Array | string} js_issued_to_identity_id
     * @param {bigint} amount
     * @param {string | null} [public_note]
     */
    constructor(base, js_issued_to_identity_id, amount, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenminttransition_new(base.__wbg_ptr, js_issued_to_identity_id, amount, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenMintTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenminttransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenminttransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenminttransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenPaymentInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenpaymentinfo_free(ptr >>> 0, 1));

export class TokenPaymentInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenPaymentInfo.prototype);
        obj.__wbg_ptr = ptr;
        TokenPaymentInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenPaymentInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenpaymentinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpaymentinfo_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get gasFeesPaidBy() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpaymentinfo_gas_fees_paid_by(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {bigint | undefined}
     */
    get maximumTokenCost() {
        const ret = wasm.tokenpaymentinfo_maximum_token_cost(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get minimumTokenCost() {
        const ret = wasm.tokenpaymentinfo_minimum_token_cost(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {any} js_gas_fees_paid_by
     */
    set gasFeesPaidBy(js_gas_fees_paid_by) {
        const ret = wasm.tokenpaymentinfo_set_gas_fees_paid_by(this.__wbg_ptr, js_gas_fees_paid_by);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {bigint | null} [maximum_cost]
     */
    set maximumTokenCost(maximum_cost) {
        wasm.tokenpaymentinfo_set_maximum_token_cost(this.__wbg_ptr, !isLikeNone(maximum_cost), isLikeNone(maximum_cost) ? BigInt(0) : maximum_cost);
    }
    /**
     * @param {bigint | null} [minimum_cost]
     */
    set minimumTokenCost(minimum_cost) {
        wasm.tokenpaymentinfo_set_maximum_token_cost(this.__wbg_ptr, !isLikeNone(minimum_cost), isLikeNone(minimum_cost) ? BigInt(0) : minimum_cost);
    }
    /**
     * @returns {number}
     */
    get tokenContractPosition() {
        const ret = wasm.tokenpaymentinfo_token_contract_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Identifier | undefined}
     */
    get paymentTokenContractId() {
        const ret = wasm.tokenpaymentinfo_payment_token_contract_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * @param {number} token_contract_position
     */
    set tokenContractPosition(token_contract_position) {
        wasm.tokenpaymentinfo_set_token_contract_position(this.__wbg_ptr, token_contract_position);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_payment_token_contract_id
     */
    set paymentTokenContractId(js_payment_token_contract_id) {
        const ret = wasm.tokenpaymentinfo_set_payment_token_contract_id(this.__wbg_ptr, js_payment_token_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} js_payment_token_contract_id
     * @param {number} token_contract_position
     * @param {bigint | null | undefined} minimum_token_cost
     * @param {bigint | null | undefined} maximum_token_cost
     * @param {any} js_gas_fees_paid_by
     */
    constructor(js_payment_token_contract_id, token_contract_position, minimum_token_cost, maximum_token_cost, js_gas_fees_paid_by) {
        const ret = wasm.tokenpaymentinfo_new(js_payment_token_contract_id, token_contract_position, !isLikeNone(minimum_token_cost), isLikeNone(minimum_token_cost) ? BigInt(0) : minimum_token_cost, !isLikeNone(maximum_token_cost), isLikeNone(maximum_token_cost) ? BigInt(0) : maximum_token_cost, js_gas_fees_paid_by);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenPaymentInfoFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpaymentinfo_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenPerpetualDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenperpetualdistribution_free(ptr >>> 0, 1));

export class TokenPerpetualDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenPerpetualDistribution.prototype);
        obj.__wbg_ptr = ptr;
        TokenPerpetualDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenPerpetualDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenperpetualdistribution_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenperpetualdistribution_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {TokenDistributionRecipient} distribution_recipient
     */
    set distributionRecipient(distribution_recipient) {
        _assertClass(distribution_recipient, TokenDistributionRecipient);
        wasm.tokenperpetualdistribution_set_recipient(this.__wbg_ptr, distribution_recipient.__wbg_ptr);
    }
    /**
     * @returns {RewardDistributionType}
     */
    get distributionType() {
        const ret = wasm.tokenperpetualdistribution_distribution_type(this.__wbg_ptr);
        return RewardDistributionType.__wrap(ret);
    }
    /**
     * @param {RewardDistributionType} distribution_type
     */
    set distributionType(distribution_type) {
        _assertClass(distribution_type, RewardDistributionType);
        wasm.tokenperpetualdistribution_set_distribution_type(this.__wbg_ptr, distribution_type.__wbg_ptr);
    }
    /**
     * @param {RewardDistributionType} distribution_type
     * @param {TokenDistributionRecipient} recipient
     */
    constructor(distribution_type, recipient) {
        _assertClass(distribution_type, RewardDistributionType);
        _assertClass(recipient, TokenDistributionRecipient);
        const ret = wasm.tokenperpetualdistribution_new(distribution_type.__wbg_ptr, recipient.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        TokenPerpetualDistributionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenDistributionRecipient}
     */
    get distributionRecipient() {
        const ret = wasm.tokenperpetualdistribution_recipient(this.__wbg_ptr);
        return TokenDistributionRecipient.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenperpetualdistribution_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenPreProgrammedDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenpreprogrammeddistribution_free(ptr >>> 0, 1));

export class TokenPreProgrammedDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenPreProgrammedDistribution.prototype);
        obj.__wbg_ptr = ptr;
        TokenPreProgrammedDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenPreProgrammedDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenpreprogrammeddistribution_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpreprogrammeddistribution_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    get distributions() {
        const ret = wasm.tokenpreprogrammeddistribution_get_distributions(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js_distributions
     */
    set distributions(js_distributions) {
        const ret = wasm.tokenpreprogrammeddistribution_set_distributions(this.__wbg_ptr, js_distributions);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_distributions
     */
    constructor(js_distributions) {
        const ret = wasm.tokenpreprogrammeddistribution_new(js_distributions);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenPreProgrammedDistributionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpreprogrammeddistribution_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenPriceInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenpriceinfo_free(ptr >>> 0, 1));

export class TokenPriceInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenPriceInfo.prototype);
        obj.__wbg_ptr = ptr;
        TokenPriceInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenPriceInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenpriceinfo_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get basePrice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpriceinfo_base_price(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} obj
     * @returns {TokenPriceInfo}
     */
    static fromObject(obj) {
        const ret = wasm.tokenpriceinfo_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenPriceInfo.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get currentPrice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpriceinfo_current_price(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.tokenpriceinfo_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {Identifier}
     */
    get tokenId() {
        const ret = wasm.tokenpriceinfo_token_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {any} js
     * @returns {TokenPriceInfo}
     */
    static fromJSON(js) {
        const ret = wasm.tokenpriceinfo_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenPriceInfo.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.tokenpriceinfo_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const TokenPricingScheduleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenpricingschedule_free(ptr >>> 0, 1));

export class TokenPricingSchedule {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenPricingSchedule.prototype);
        obj.__wbg_ptr = ptr;
        TokenPricingScheduleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenPricingScheduleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenpricingschedule_free(ptr, 0);
    }
    /**
     * @param {any} js_prices
     * @returns {TokenPricingSchedule}
     */
    static SetPrices(js_prices) {
        const ret = wasm.tokenpricingschedule_SetPrices(js_prices);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenPricingSchedule.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpricingschedule_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {bigint} credits
     * @returns {TokenPricingSchedule}
     */
    static SinglePrice(credits) {
        const ret = wasm.tokenpricingschedule_SinglePrice(credits);
        return TokenPricingSchedule.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getScheduleType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpricingschedule_getScheduleType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    getValue() {
        const ret = wasm.tokenpricingschedule_getValue(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenpricingschedule_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenSetPriceForDirectPurchaseTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokensetpricefordirectpurchasetransition_free(ptr >>> 0, 1));

export class TokenSetPriceForDirectPurchaseTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenSetPriceForDirectPurchaseTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenSetPriceForDirectPurchaseTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenSetPriceForDirectPurchaseTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokensetpricefordirectpurchasetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokensetpricefordirectpurchasetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokensetpricefordirectpurchasetransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokensetpricefordirectpurchasetransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {any} js_price
     * @param {string | null} [public_note]
     */
    constructor(base, js_price, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokensetpricefordirectpurchasetransition_new(base.__wbg_ptr, js_price, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenSetPriceForDirectPurchaseTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokensetpricefordirectpurchasetransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokensetpricefordirectpurchasetransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {any}
     */
    get price() {
        const ret = wasm.tokensetpricefordirectpurchasetransition_get_price(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {any} js_price
     */
    set price(js_price) {
        const ret = wasm.tokensetpricefordirectpurchasetransition_set_price(this.__wbg_ptr, js_price);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokensetpricefordirectpurchasetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenSetPriceResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokensetpriceresult_free(ptr >>> 0, 1));
/**
 * Result of setting the token price.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns pricing schedule and owner ID
 * - Tokens with history: returns document
 * - Group-managed tokens: returns group power and status
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenSetPriceResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenSetPriceResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenSetPriceResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenSetPriceResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokensetpriceresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokensetpriceresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The pricing schedule (for standard tokens or group actions without history).
     * @returns {TokenPricingSchedule | undefined}
     */
    get pricingSchedule() {
        const ret = wasm.tokensetpriceresult_pricing_schedule(this.__wbg_ptr);
        return ret === 0 ? undefined : TokenPricingSchedule.__wrap(ret);
    }
    /**
     * The group action status (for group actions).
     * @returns {string | undefined}
     */
    get groupActionStatus() {
        const ret = wasm.tokensetpriceresult_group_action_status(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokensetpriceresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
    /**
     * The identity that set the price (for standard tokens).
     * @returns {Identifier | undefined}
     */
    get ownerId() {
        const ret = wasm.tokensetpriceresult_owner_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
}

const TokenStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenstatus_free(ptr >>> 0, 1));

export class TokenStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenStatus.prototype);
        obj.__wbg_ptr = ptr;
        TokenStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenstatus_free(ptr, 0);
    }
    /**
     * @returns {boolean}
     */
    get paused() {
        const ret = wasm.tokenstatus_paused(this.__wbg_ptr);
        return ret !== 0;
    }
}

const TokenTotalSupplyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokentotalsupply_free(ptr >>> 0, 1));

export class TokenTotalSupply {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenTotalSupply.prototype);
        obj.__wbg_ptr = ptr;
        TokenTotalSupplyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenTotalSupplyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokentotalsupply_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {TokenTotalSupply}
     */
    static fromObject(obj) {
        const ret = wasm.tokentotalsupply_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenTotalSupply.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get totalSupply() {
        const ret = wasm.tokentotalsupply_total_supply(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.tokentotalsupply_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {TokenTotalSupply}
     */
    static fromJSON(js) {
        const ret = wasm.tokentotalsupply_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TokenTotalSupply.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.tokentotalsupply_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
}

const TokenTradeModeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokentrademode_free(ptr >>> 0, 1));

export class TokenTradeMode {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenTradeMode.prototype);
        obj.__wbg_ptr = ptr;
        TokenTradeModeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenTradeModeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokentrademode_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentrademode_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {TokenTradeMode}
     */
    static NotTradeable() {
        const ret = wasm.tokentrademode_NotTradeable();
        return TokenTradeMode.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getValue() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentrademode_getValue(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentrademode_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenTransferResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokentransferresult_free(ptr >>> 0, 1));
/**
 * Result of transferring tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns identities balances
 * - Tokens with history: returns a document
 * - Group-managed tokens: returns group power and document
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenTransferResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenTransferResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenTransferResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenTransferResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokentransferresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokentransferresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The sender's new balance after transfer.
     * @returns {bigint | undefined}
     */
    get senderBalance() {
        const ret = wasm.tokentransferresult_sender_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * The recipient's new balance after transfer.
     * @returns {bigint | undefined}
     */
    get recipientBalance() {
        const ret = wasm.tokentransferresult_recipient_balance(this.__wbg_ptr);
        return ret;
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokentransferresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const TokenTransferTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokentransfertransition_free(ptr >>> 0, 1));

export class TokenTransferTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenTransferTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenTransferTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenTransferTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokentransfertransition_free(ptr, 0);
    }
    /**
     * @returns {bigint}
     */
    get amount() {
        const ret = wasm.tokentransfertransition_get_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} amount
     */
    set amount(amount) {
        wasm.tokentransfertransition_set_amount(this.__wbg_ptr, amount);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransfertransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get recipientId() {
        const ret = wasm.tokentransfertransition_recipient_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokentransfertransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokentransfertransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_recipient
     */
    set recipientId(js_recipient) {
        const ret = wasm.tokentransfertransition_set_recipient_id(this.__wbg_ptr, js_recipient);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {SharedEncryptedNote | undefined}
     */
    get sharedEncryptedNote() {
        const ret = wasm.tokentransfertransition_get_shared_encrypted_note(this.__wbg_ptr);
        return ret === 0 ? undefined : SharedEncryptedNote.__wrap(ret);
    }
    /**
     * @param {any} js_shared_encrypted_note
     */
    set sharedEncryptedNote(js_shared_encrypted_note) {
        const ret = wasm.tokentransfertransition_set_shared_encrypted_note(this.__wbg_ptr, js_shared_encrypted_note);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {PrivateEncryptedNote | undefined}
     */
    get privateEncryptedNote() {
        const ret = wasm.tokentransfertransition_get_private_encrypted_note(this.__wbg_ptr);
        return ret === 0 ? undefined : PrivateEncryptedNote.__wrap(ret);
    }
    /**
     * @param {any} js_private_encrypted_note
     */
    set privateEncryptedNote(js_private_encrypted_note) {
        const ret = wasm.tokentransfertransition_set_private_encrypted_note(this.__wbg_ptr, js_private_encrypted_note);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {Identifier | Uint8Array | string} js_recipient_id
     * @param {bigint} amount
     * @param {string | null | undefined} public_note
     * @param {any} js_shared_encrypted_note
     * @param {any} js_private_encrypted_note
     */
    constructor(base, js_recipient_id, amount, public_note, js_shared_encrypted_note, js_private_encrypted_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokentransfertransition_new(base.__wbg_ptr, js_recipient_id, amount, ptr0, len0, js_shared_encrypted_note, js_private_encrypted_note);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenTransferTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokentransfertransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokentransfertransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransfertransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokentransition_free(ptr >>> 0, 1));

export class TokenTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokentransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get tokenId() {
        const ret = wasm.tokentransition_get_token_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     */
    set tokenId(js_id) {
        const ret = wasm.tokentransition_set_token_id(this.__wbg_ptr, js_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {any}
     */
    getTransition() {
        const ret = wasm.tokentransition_getTransition(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Identifier}
     */
    get contractId() {
        const ret = wasm.tokentransition_get_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_id
     */
    set contractId(js_id) {
        const ret = wasm.tokentransition_set_contract_id(this.__wbg_ptr, js_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    getTransitionType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransition_getTransitionType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Identifier | Uint8Array | string} js_owner
     * @returns {Identifier}
     */
    getHistoricalDocumentId(js_owner) {
        const ret = wasm.tokentransition_getHistoricalDocumentId(this.__wbg_ptr, js_owner);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Identifier.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    getTransitionTypeNumber() {
        const ret = wasm.tokentransition_getTransitionTypeNumber(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    get identityContractNonce() {
        const ret = wasm.tokentransition_get_identity_contract_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} nonce
     */
    set identityContractNonce(nonce) {
        wasm.tokentransition_set_identity_contract_nonce(this.__wbg_ptr, nonce);
    }
    /**
     * @returns {string}
     */
    getHistoricalDocumentTypeName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransition_getHistoricalDocumentTypeName(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {any} js_transition
     */
    constructor(js_transition) {
        const ret = wasm.tokentransition_new(js_transition);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokentransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenUnFreezeTransitionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenunfreezetransition_free(ptr >>> 0, 1));

export class TokenUnFreezeTransition {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenUnFreezeTransition.prototype);
        obj.__wbg_ptr = ptr;
        TokenUnFreezeTransitionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenUnFreezeTransitionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenunfreezetransition_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenunfreezetransition_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string | undefined}
     */
    get publicNote() {
        const ret = wasm.tokenunfreezetransition_get_public_note(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [note]
     */
    set publicNote(note) {
        var ptr0 = isLikeNone(note) ? 0 : passStringToWasm0(note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.tokenunfreezetransition_set_public_note(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {Identifier}
     */
    get frozenIdentityId() {
        const ret = wasm.tokenunfreezetransition_get_frozen_identity_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_frozen_identity_id
     */
    set frozenIdentityId(js_frozen_identity_id) {
        const ret = wasm.tokenunfreezetransition_set_frozen_identity_id(this.__wbg_ptr, js_frozen_identity_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {TokenBaseTransition} base
     * @param {Identifier | Uint8Array | string} js_frozen_identity_id
     * @param {string | null} [public_note]
     */
    constructor(base, js_frozen_identity_id, public_note) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = isLikeNone(public_note) ? 0 : passStringToWasm0(public_note, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.tokenunfreezetransition_new(base.__wbg_ptr, js_frozen_identity_id, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        TokenUnFreezeTransitionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {TokenBaseTransition}
     */
    get base() {
        const ret = wasm.tokenunfreezetransition_get_base(this.__wbg_ptr);
        return TokenBaseTransition.__wrap(ret);
    }
    /**
     * @param {TokenBaseTransition} base
     */
    set base(base) {
        _assertClass(base, TokenBaseTransition);
        var ptr0 = base.__destroy_into_raw();
        wasm.tokenunfreezetransition_set_base(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.tokenunfreezetransition_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const TokenUnfreezeResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tokenunfreezeresult_free(ptr >>> 0, 1));
/**
 * Result of unfreezing tokens.
 *
 * The result type depends on token configuration:
 * - Standard tokens: returns unfrozen identity ID
 * - Tokens with history: returns a document
 * - Group-managed tokens: returns group power and status
 *
 * Check which optional fields are present to determine the result type.
 */
export class TokenUnfreezeResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TokenUnfreezeResult.prototype);
        obj.__wbg_ptr = ptr;
        TokenUnfreezeResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TokenUnfreezeResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tokenunfreezeresult_free(ptr, 0);
    }
    /**
     * The accumulated group power (for group actions).
     * @returns {number | undefined}
     */
    get groupPower() {
        const ret = wasm.tokenunfreezeresult_group_power(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * The identity ID that was unfrozen.
     * @returns {Identifier | undefined}
     */
    get unfrozenIdentityId() {
        const ret = wasm.tokenunfreezeresult_unfrozen_identity_id(this.__wbg_ptr);
        return ret === 0 ? undefined : Identifier.__wrap(ret);
    }
    /**
     * The historical document (for tokens with history tracking).
     * @returns {Document | undefined}
     */
    get document() {
        const ret = wasm.tokenunfreezeresult_document(this.__wbg_ptr);
        return ret === 0 ? undefined : Document.__wrap(ret);
    }
}

const VoteFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vote_free(ptr >>> 0, 1));

export class Vote {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Vote.prototype);
        obj.__wbg_ptr = ptr;
        VoteFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoteFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vote_free(ptr, 0);
    }
    /**
     * @param {any} obj
     * @returns {Vote}
     */
    static fromObject(obj) {
        const ret = wasm.vote_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Vote.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vote_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {VotePoll} vote_poll
     */
    set votePoll(vote_poll) {
        _assertClass(vote_poll, VotePoll);
        wasm.vote_set_vote_poll(this.__wbg_ptr, vote_poll.__wbg_ptr);
    }
    /**
     * @returns {ResourceVoteChoice}
     */
    get resourceVoteChoice() {
        const ret = wasm.vote_resource_vote_choice(this.__wbg_ptr);
        return ResourceVoteChoice.__wrap(ret);
    }
    /**
     * @param {ResourceVoteChoice} resource_vote_choice
     */
    set resourceVoteChoice(resource_vote_choice) {
        _assertClass(resource_vote_choice, ResourceVoteChoice);
        wasm.vote_set_resource_vote_choice(this.__wbg_ptr, resource_vote_choice.__wbg_ptr);
    }
    /**
     * @param {VotePoll} vote_poll
     * @param {ResourceVoteChoice} resource_vote_choice
     */
    constructor(vote_poll, resource_vote_choice) {
        _assertClass(vote_poll, VotePoll);
        _assertClass(resource_vote_choice, ResourceVoteChoice);
        const ret = wasm.resourcevote_new(vote_poll.__wbg_ptr, resource_vote_choice.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        VoteFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.vote_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {Vote}
     */
    static fromJSON(js) {
        const ret = wasm.vote_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Vote.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.vote_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vote_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {VotePoll}
     */
    get votePoll() {
        const ret = wasm.vote_vote_poll(this.__wbg_ptr);
        return VotePoll.__wrap(ret);
    }
}

const VotePollFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votepoll_free(ptr >>> 0, 1));

export class VotePoll {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VotePoll.prototype);
        obj.__wbg_ptr = ptr;
        VotePollFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VotePollFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votepoll_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get indexName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votepoll_index_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Identifier}
     */
    get contractId() {
        const ret = wasm.votepoll_contract_id(this.__wbg_ptr);
        return Identifier.__wrap(ret);
    }
    /**
     * @param {any} obj
     * @returns {VotePoll}
     */
    static fromObject(obj) {
        const ret = wasm.votepoll_fromObject(obj);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VotePoll.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    static get __struct() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votepoll_struct_name();
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Array<any>}
     */
    get indexValues() {
        const ret = wasm.votepoll_index_values(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    toString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votepoll_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} index_name
     */
    set indexName(index_name) {
        const ptr0 = passStringToWasm0(index_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.votepoll_set_index_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     */
    set contractId(js_contract_id) {
        const ret = wasm.votepoll_set_contract_id(this.__wbg_ptr, js_contract_id);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {any} js_index_values
     */
    set indexValues(js_index_values) {
        const ret = wasm.votepoll_set_index_values(this.__wbg_ptr, js_index_values);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @returns {string}
     */
    get documentTypeName() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votepoll_document_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} document_type_name
     */
    set documentTypeName(document_type_name) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.votepoll_set_document_type_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @param {Identifier | Uint8Array | string} js_contract_id
     * @param {string} document_type_name
     * @param {string} index_name
     * @param {any} js_index_values
     */
    constructor(js_contract_id, document_type_name, index_name, js_index_values) {
        const ptr0 = passStringToWasm0(document_type_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(index_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.votepoll_new(js_contract_id, ptr0, len0, ptr1, len1, js_index_values);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        VotePollFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {any}
     */
    toJSON() {
        const ret = wasm.votepoll_toJSON(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {any} js
     * @returns {VotePoll}
     */
    static fromJSON(js) {
        const ret = wasm.votepoll_fromJSON(js);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VotePoll.__wrap(ret[0]);
    }
    /**
     * @returns {any}
     */
    toObject() {
        const ret = wasm.votepoll_toObject(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @returns {string}
     */
    get __type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votepoll_type_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const VotePollsByEndDateEntryFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votepollsbyenddateentry_free(ptr >>> 0, 1));

export class VotePollsByEndDateEntry {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VotePollsByEndDateEntry.prototype);
        obj.__wbg_ptr = ptr;
        VotePollsByEndDateEntryFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VotePollsByEndDateEntryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votepollsbyenddateentry_free(ptr, 0);
    }
    /**
     * @returns {Array<any>}
     */
    get votePolls() {
        const ret = wasm.votepollsbyenddateentry_vote_polls(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    get timestampMs() {
        const ret = wasm.votepollsbyenddateentry_timestamp_ms(this.__wbg_ptr);
        return ret;
    }
}

const WasmContextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmcontext_free(ptr >>> 0, 1));

export class WasmContext {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmContextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmcontext_free(ptr, 0);
    }
}

const WasmDppErrorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmdpperror_free(ptr >>> 0, 1));
/**
 * Structured error returned by wasm-dpp2 APIs.
 */
export class WasmDppError {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmDppError.prototype);
        obj.__wbg_ptr = ptr;
        WasmDppErrorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmDppErrorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmdpperror_free(ptr, 0);
    }
    /**
     * Optional numeric code. `-1` means absent.
     * @returns {number}
     */
    get code() {
        const ret = wasm.wasmdpperror_code(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the structured error kind.
     * @returns {WasmDppErrorKind}
     */
    get kind() {
        const ret = wasm.wasmdpperror_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * Backwards-compatible string representation of the kind.
     * @returns {string}
     */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmdpperror_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Human-readable error message.
     * @returns {string}
     */
    get message() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmdpperror_message(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const WasmSdkFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmsdk_free(ptr >>> 0, 1));

export class WasmSdk {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmSdk.prototype);
        obj.__wbg_ptr = ptr;
        WasmSdkFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmSdkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmsdk_free(ptr, 0);
    }
    /**
     * Transfers credits between Platform addresses.
     *
     * This method handles the complete transfer flow:
     * 1. Fetches current nonces for all input addresses
     * 2. Builds and signs the transfer transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Transfer options including inputs, outputs, and private keys
     * @returns Promise resolving to Map of PlatformAddress to PlatformAddressInfo
     * @param {AddressFundsTransferOptions} options
     * @returns {Map<PlatformAddress, PlatformAddressInfo>}
     */
    addressFundsTransfer(options) {
        const ret = wasm.wasmsdk_addressFundsTransfer(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Withdraws Platform address credits to Core (L1).
     *
     * This method handles the complete withdrawal flow:
     * 1. Fetches current nonces for all input addresses
     * 2. Builds and signs the withdrawal transition
     * 3. Broadcasts and waits for confirmation
     * 4. The withdrawal may be pooled with others depending on the pooling strategy
     *
     * @param options - Withdrawal options including inputs, output script, and private keys
     * @returns Promise resolving to Map of PlatformAddress to PlatformAddressInfo
     * @param {AddressFundsWithdrawOptions} options
     * @returns {Map<PlatformAddress, PlatformAddressInfo>}
     */
    addressFundsWithdraw(options) {
        const ret = wasm.wasmsdk_addressFundsWithdraw(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Create an identity funded from Platform addresses.
     *
     * This method handles the complete identity creation flow:
     * 1. Fetches current nonces for all input addresses
     * 2. Builds and signs the identity create from addresses transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Creation options including identity, inputs, and signers
     * @returns Promise resolving to result with created identity and updated address infos
     *
     * ## Unstable
     *
     * This function is planned to be changed to require address nonces in the options to avoid potential privacy leaks.
     * @param {IdentityCreateFromAddressesOptions} options
     * @returns {Promise<IdentityCreateFromAddressesResult>}
     */
    identityCreateFromAddresses(options) {
        const ret = wasm.wasmsdk_identityCreateFromAddresses(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Top up an identity from Platform addresses.
     *
     * This method handles the complete top up flow:
     * 1. Fetches current nonces for all input addresses
     * 2. Builds and signs the identity top up transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Top up options including identity, inputs, and signer
     * @returns Promise resolving to result with updated address infos and new identity balance
     * @param {IdentityTopUpFromAddressesOptions} options
     * @returns {Promise<IdentityTopUpFromAddressesResult>}
     */
    identityTopUpFromAddresses(options) {
        const ret = wasm.wasmsdk_identityTopUpFromAddresses(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Transfer credits from an identity to Platform addresses.
     *
     * This method handles the complete transfer flow:
     * 1. Finds the appropriate transfer key to use for signing (if signingTransferKeyId specified)
     * 2. Builds and signs the identity credit transfer to addresses transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Transfer options including identity, outputs, and signer
     * @returns Promise resolving to result with updated address infos and new identity balance
     * @param {IdentityTransferToAddressesOptions} options
     * @returns {Promise<IdentityTransferToAddressesResult>}
     */
    identityTransferToAddresses(options) {
        const ret = wasm.wasmsdk_identityTransferToAddresses(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Fund Platform addresses from an asset lock.
     *
     * This method handles the complete funding flow:
     * 1. Validates the asset lock proof
     * 2. Builds and signs the address funding transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Funding options including asset lock, outputs, and signer
     * @returns Promise resolving to Map of PlatformAddress to PlatformAddressInfo
     * @param {AddressFundingFromAssetLockOptions} options
     * @returns {Map<PlatformAddress, PlatformAddressInfo>}
     */
    addressFundingFromAssetLock(options) {
        const ret = wasm.wasmsdk_addressFundingFromAssetLock(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * @param {EpochsQuery} query
     * @returns {Map<number, ExtendedEpochInfo | undefined>}
     */
    getEpochsInfo(query) {
        const ret = wasm.wasmsdk_getEpochsInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @returns {Promise<ExtendedEpochInfo>}
     */
    getCurrentEpoch() {
        const ret = wasm.wasmsdk_getCurrentEpoch(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {FinalizedEpochsQuery} query
     * @returns {Map<number, FinalizedEpochInfo | undefined>}
     */
    getFinalizedEpochInfos(query) {
        const ret = wasm.wasmsdk_getFinalizedEpochInfos(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {EpochsQuery} query
     * @returns {ProofMetadataResponseTyped<Map<number, ExtendedEpochInfo | undefined>>}
     */
    getEpochsInfoWithProofInfo(query) {
        const ret = wasm.wasmsdk_getEpochsInfoWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @returns {ProofMetadataResponseTyped<ExtendedEpochInfo>}
     */
    getCurrentEpochWithProofInfo() {
        const ret = wasm.wasmsdk_getCurrentEpochWithProofInfo(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} epoch
     * @param {ProTxHashLike[]} ids
     * @returns {Map<Identifier, bigint>}
     */
    getEvonodesProposedEpochBlocksByIds(epoch, ids) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getEvonodesProposedEpochBlocksByIds(this.__wbg_ptr, epoch, ptr0, len0);
        return ret;
    }
    /**
     * @param {FinalizedEpochsQuery} query
     * @returns {ProofMetadataResponseTyped<Map<number, FinalizedEpochInfo | undefined>>}
     */
    getFinalizedEpochInfosWithProofInfo(query) {
        const ret = wasm.wasmsdk_getFinalizedEpochInfosWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {EvonodeProposedBlocksRangeQuery} query
     * @returns {Map<Identifier, bigint>}
     */
    getEvonodesProposedEpochBlocksByRange(query) {
        const ret = wasm.wasmsdk_getEvonodesProposedEpochBlocksByRange(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {number} epoch
     * @param {ProTxHashLike[]} proTxHashes
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getEvonodesProposedEpochBlocksByIdsWithProofInfo(epoch, proTxHashes) {
        const ptr0 = passArrayJsValueToWasm0(proTxHashes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getEvonodesProposedEpochBlocksByIdsWithProofInfo(this.__wbg_ptr, epoch, ptr0, len0);
        return ret;
    }
    /**
     * @param {EvonodeProposedBlocksRangeQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getEvonodesProposedEpochBlocksByRangeWithProofInfo(query) {
        const ret = wasm.wasmsdk_getEvonodesProposedEpochBlocksByRangeWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * Burn tokens from an identity's balance.
     *
     * @param options - Burn options including contract ID, token position, amount, and signer
     * @returns Promise resolving to TokenBurnResult with the remaining balance
     * @param {TokenBurnOptions} options
     * @returns {Promise<TokenBurnResult>}
     */
    tokenBurn(options) {
        const ret = wasm.wasmsdk_tokenBurn(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Mint new tokens according to the token's configuration.
     *
     * @param options - Mint options including contract ID, token position, amount, and signer
     * @returns Promise resolving to TokenMintResult with the new balance
     * @param {TokenMintOptions} options
     * @returns {Promise<TokenMintResult>}
     */
    tokenMint(options) {
        const ret = wasm.wasmsdk_tokenMint(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Claim tokens from a distribution.
     *
     * @param options - Claim options including contract ID, token position, distribution type, and signer
     * @returns Promise resolving to TokenClaimResult
     * @param {TokenClaimOptions} options
     * @returns {Promise<TokenClaimResult>}
     */
    tokenClaim(options) {
        const ret = wasm.wasmsdk_tokenClaim(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Freeze an identity's token balance.
     *
     * @param options - Freeze options including contract ID, token position, authority, frozen identity, and signer
     * @returns Promise resolving to TokenFreezeResult
     * @param {TokenFreezeOptions} options
     * @returns {Promise<TokenFreezeResult>}
     */
    tokenFreeze(options) {
        const ret = wasm.wasmsdk_tokenFreeze(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Transfer tokens from one identity to another.
     *
     * @param options - Transfer options including contract ID, token position, amount, sender, recipient, and signer
     * @returns Promise resolving to TokenTransferResult with transfer info
     * @param {TokenTransferOptions} options
     * @returns {Promise<TokenTransferResult>}
     */
    tokenTransfer(options) {
        const ret = wasm.wasmsdk_tokenTransfer(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Unfreeze an identity's token balance.
     *
     * @param options - Unfreeze options including contract ID, token position, authority, frozen identity, and signer
     * @returns Promise resolving to TokenUnfreezeResult
     * @param {TokenUnfreezeOptions} options
     * @returns {Promise<TokenUnfreezeResult>}
     */
    tokenUnfreeze(options) {
        const ret = wasm.wasmsdk_tokenUnfreeze(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Set the price of a token for direct purchase.
     *
     * @param options - Price options including contract ID, token position, price, and signer
     * @returns Promise resolving to TokenSetPriceResult
     * @param {TokenSetPriceOptions} options
     * @returns {Promise<TokenSetPriceResult>}
     */
    tokenSetPrice(options) {
        const ret = wasm.wasmsdk_tokenSetPrice(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Destroy a frozen identity's token balance.
     *
     * @param options - Destroy frozen options including contract ID, token position, authority, frozen identity, and signer
     * @returns Promise resolving to TokenDestroyFrozenResult
     * @param {TokenDestroyFrozenOptions} options
     * @returns {Promise<TokenDestroyFrozenResult>}
     */
    tokenDestroyFrozen(options) {
        const ret = wasm.wasmsdk_tokenDestroyFrozen(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Directly purchase tokens using credits.
     *
     * @param options - Purchase options including contract ID, token position, amount, max cost, and signer
     * @returns Promise resolving to TokenDirectPurchaseResult
     * @param {TokenDirectPurchaseOptions} options
     * @returns {Promise<TokenDirectPurchaseResult>}
     */
    tokenDirectPurchase(options) {
        const ret = wasm.wasmsdk_tokenDirectPurchase(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Perform an emergency action (pause or resume) on a token.
     *
     * @param options - Emergency action options including contract ID, token position, action type, and signer
     * @returns Promise resolving to TokenEmergencyActionResult
     * @param {TokenEmergencyActionOptions} options
     * @returns {Promise<TokenEmergencyActionResult>}
     */
    tokenEmergencyAction(options) {
        const ret = wasm.wasmsdk_tokenEmergencyAction(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * @param {ContestedResourceIdentityVotesQuery} query
     * @returns {Map<Identifier, ResourceVote>}
     */
    getContestedResourceIdentityVotes(query) {
        const ret = wasm.wasmsdk_getContestedResourceIdentityVotes(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {ContestedResourceIdentityVotesQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, ResourceVote>>}
     */
    getContestedResourceIdentityVotesWithProofInfo(query) {
        const ret = wasm.wasmsdk_getContestedResourceIdentityVotesWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {VotePollsByDocumentTypeQuery} query
     * @returns {Array<any>}
     */
    getContestedResources(query) {
        const ret = wasm.wasmsdk_getContestedResources(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {VotePollsByDocumentTypeQuery} query
     * @returns {ProofMetadataResponseTyped<Array<any>>}
     */
    getContestedResourcesWithProofInfo(query) {
        const ret = wasm.wasmsdk_getContestedResourcesWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * Waits for a state transition response after it has been broadcast.
     *
     * Use this after calling `broadcastStateTransition` to wait for the transition
     * to be processed by the network. This is useful when you want to broadcast
     * and wait separately (e.g., for monitoring or progress tracking).
     *
     * Note: This differs from `waitForStateTransitionResult` which takes a hash string.
     * This method takes the full state transition object and performs proof verification.
     *
     * @param stateTransition - The state transition that was broadcast
     * @param settings - Optional put settings (retries, timeout, waitTimeoutMs)
     * @returns JSON representation of the state transition result
     * @param {StateTransition} stateTransition
     * @param {PutSettings | null} [settings]
     * @returns {Promise<any>}
     */
    waitForResponse(stateTransition, settings) {
        _assertClass(stateTransition, StateTransition);
        const ret = wasm.wasmsdk_waitForResponse(this.__wbg_ptr, stateTransition.__wbg_ptr, isLikeNone(settings) ? 0 : addToExternrefTable0(settings));
        return ret;
    }
    /**
     * Broadcasts a state transition and waits for the result.
     *
     * This method broadcasts the transition and waits for confirmation from the network.
     * Returns once the transition has been processed or fails.
     * This is equivalent to calling `broadcastStateTransition` followed by
     * `waitForResponse`.
     *
     * @param stateTransition - The state transition to broadcast
     * @param settings - Optional put settings (retries, timeout, waitTimeoutMs)
     * @returns JSON representation of the state transition result
     * @param {StateTransition} stateTransition
     * @param {PutSettings | null} [settings]
     * @returns {Promise<any>}
     */
    broadcastAndWait(stateTransition, settings) {
        _assertClass(stateTransition, StateTransition);
        const ret = wasm.wasmsdk_broadcastAndWait(this.__wbg_ptr, stateTransition.__wbg_ptr, isLikeNone(settings) ? 0 : addToExternrefTable0(settings));
        return ret;
    }
    /**
     * Broadcasts a state transition to the network.
     *
     * This method only broadcasts but does not wait for the result.
     * Use `waitForResponse` to wait for confirmation after broadcasting,
     * or use `broadcastAndWait` to do both in one call.
     *
     * @param stateTransition - The state transition to broadcast
     * @param settings - Optional put settings (retries, timeout)
     * @param {StateTransition} stateTransition
     * @param {PutSettings | null} [settings]
     * @returns {Promise<void>}
     */
    broadcastStateTransition(stateTransition, settings) {
        _assertClass(stateTransition, StateTransition);
        const ret = wasm.wasmsdk_broadcastStateTransition(this.__wbg_ptr, stateTransition.__wbg_ptr, isLikeNone(settings) ? 0 : addToExternrefTable0(settings));
        return ret;
    }
    /**
     * Create a new document on Dash Platform.
     *
     * This method handles the complete document creation flow:
     * 1. Fetches the data contract from Platform
     * 2. Validates the document data against the document type schema
     * 3. Creates and signs the document create transition
     * 4. Broadcasts and waits for confirmation
     *
     * @param options - Creation options including document, identity key, and signer
     * @returns Promise that resolves when the document is created
     * @param {DocumentCreateOptions} options
     * @returns {Promise<void>}
     */
    documentCreate(options) {
        const ret = wasm.wasmsdk_documentCreate(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Delete a document from Dash Platform.
     *
     * This method handles the complete document deletion flow:
     * 1. Fetches the data contract from Platform
     * 2. Creates and signs the document delete transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Delete options including document (or document identifiers), identity key, and signer
     * @returns Promise that resolves when the document is deleted
     * @param {DocumentDeleteOptions} options
     * @returns {Promise<void>}
     */
    documentDelete(options) {
        const ret = wasm.wasmsdk_documentDelete(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Replace an existing document on Dash Platform.
     *
     * This method handles the complete document replacement flow:
     * 1. Fetches the data contract from Platform
     * 2. Validates the new document data against the document type schema
     * 3. Creates and signs the document replace transition
     * 4. Broadcasts and waits for confirmation
     *
     * @param options - Replace options including document, identity key, and signer
     * @returns Promise that resolves when the document is replaced
     * @param {DocumentReplaceOptions} options
     * @returns {Promise<void>}
     */
    documentReplace(options) {
        const ret = wasm.wasmsdk_documentReplace(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Purchase a document that has a price set.
     *
     * This method handles the complete document purchase flow:
     * 1. Fetches the data contract from Platform
     * 2. Creates and signs the document purchase transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Purchase options including document, buyer ID, price, and signer
     * @returns Promise that resolves when the purchase is complete
     * @param {DocumentPurchaseOptions} options
     * @returns {Promise<void>}
     */
    documentPurchase(options) {
        const ret = wasm.wasmsdk_documentPurchase(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Transfer a document to another identity.
     *
     * This method handles the complete document transfer flow:
     * 1. Fetches the data contract from Platform
     * 2. Creates and signs the document transfer transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Transfer options including document, recipient, and signer
     * @returns Promise that resolves when the document is transferred
     * @param {DocumentTransferOptions} options
     * @returns {Promise<void>}
     */
    documentTransfer(options) {
        const ret = wasm.wasmsdk_documentTransfer(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Set a price on a document to enable purchases.
     *
     * This method handles the complete price setting flow:
     * 1. Fetches the data contract from Platform
     * 2. Creates and signs the price update transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Set price options including document, price, and signer
     * @returns Promise that resolves when the price is set
     * @param {DocumentSetPriceOptions} options
     * @returns {Promise<void>}
     */
    documentSetPrice(options) {
        const ret = wasm.wasmsdk_documentSetPrice(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Convert extended private key to extended public key
     * @param {string} xprv
     * @returns {string}
     */
    static xprvToXpub(xprv) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(xprv, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.wasmsdk_xprvToXpub(ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * Derive a seed from a mnemonic phrase
     * @param {string} mnemonic
     * @param {string | null} [passphrase]
     * @returns {Uint8Array}
     */
    static mnemonicToSeed(mnemonic, passphrase) {
        const ptr0 = passStringToWasm0(mnemonic, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(passphrase) ? 0 : passStringToWasm0(passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_mnemonicToSeed(ptr0, len0, ptr1, len1);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v3 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v3;
    }
    /**
     * Generate a new mnemonic phrase
     * @param {GenerateMnemonicParams | null} [params]
     * @returns {string}
     */
    static generateMnemonic(params) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.wasmsdk_generateMnemonic(isLikeNone(params) ? 0 : addToExternrefTable0(params));
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * Validate a mnemonic phrase
     * @param {string} mnemonic
     * @param {string | null} [languageCode]
     * @returns {boolean}
     */
    static validateMnemonic(mnemonic, languageCode) {
        const ptr0 = passStringToWasm0(mnemonic, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(languageCode) ? 0 : passStringToWasm0(languageCode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_validateMnemonic(ptr0, len0, ptr1, len1);
        return ret !== 0;
    }
    /**
     * Get child public key from extended public key
     * @param {string} xpub
     * @param {number} index
     * @param {boolean} hardened
     * @returns {string}
     */
    static deriveChildPublicKey(xpub, index, hardened) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(xpub, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.wasmsdk_deriveChildPublicKey(ptr0, len0, index, hardened);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * Derive a key from mnemonic phrase using BIP39/BIP44
     * @param {DeriveKeyFromSeedPhraseParams} params
     * @returns {SeedPhraseKeyInfo}
     */
    static deriveKeyFromSeedPhrase(params) {
        const ret = wasm.wasmsdk_deriveKeyFromSeedPhrase(params);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SeedPhraseKeyInfo.__wrap(ret[0]);
    }
    /**
     * Create a DIP9 mainnet derivation path
     * @param {number} featureType
     * @param {number} account
     * @param {number} index
     * @returns {DerivationPathInfo}
     */
    static derivationPathDip9Mainnet(featureType, account, index) {
        const ret = wasm.wasmsdk_derivationPathDip9Mainnet(featureType, account, index);
        return DerivationPathInfo.__wrap(ret);
    }
    /**
     * Create a DIP9 testnet derivation path
     * @param {number} featureType
     * @param {number} account
     * @param {number} index
     * @returns {DerivationPathInfo}
     */
    static derivationPathDip9Testnet(featureType, account, index) {
        const ret = wasm.wasmsdk_derivationPathDip9Testnet(featureType, account, index);
        return DerivationPathInfo.__wrap(ret);
    }
    /**
     * Create a BIP44 mainnet derivation path
     * @param {number} account
     * @param {number} change
     * @param {number} index
     * @returns {DerivationPathInfo}
     */
    static derivationPathBip44Mainnet(account, change, index) {
        const ret = wasm.wasmsdk_derivationPathBip44Mainnet(account, change, index);
        return DerivationPathInfo.__wrap(ret);
    }
    /**
     * Create a BIP44 testnet derivation path
     * @param {number} account
     * @param {number} change
     * @param {number} index
     * @returns {DerivationPathInfo}
     */
    static derivationPathBip44Testnet(account, change, index) {
        const ret = wasm.wasmsdk_derivationPathBip44Testnet(account, change, index);
        return DerivationPathInfo.__wrap(ret);
    }
    /**
     * Create a DIP13 mainnet derivation path (for HD masternode keys)
     * @param {number} account
     * @returns {Dip13DerivationPathInfo}
     */
    static derivationPathDip13Mainnet(account) {
        const ret = wasm.wasmsdk_derivationPathDip13Mainnet(account);
        return Dip13DerivationPathInfo.__wrap(ret);
    }
    /**
     * Create a DIP13 testnet derivation path (for HD masternode keys)
     * @param {number} account
     * @returns {Dip13DerivationPathInfo}
     */
    static derivationPathDip13Testnet(account) {
        const ret = wasm.wasmsdk_derivationPathDip13Testnet(account);
        return Dip13DerivationPathInfo.__wrap(ret);
    }
    /**
     * Derive a key from seed phrase with arbitrary path
     * @param {DeriveKeyFromSeedWithPathParams} params
     * @returns {PathDerivedKeyInfo}
     */
    static deriveKeyFromSeedWithPath(params) {
        const ret = wasm.wasmsdk_deriveKeyFromSeedWithPath(params);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PathDerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @param {number} groupContractPosition
     * @returns {Promise<Group | undefined>}
     */
    getGroupInfo(dataContractId, groupContractPosition) {
        const ret = wasm.wasmsdk_getGroupInfo(this.__wbg_ptr, dataContractId, groupContractPosition);
        return ret;
    }
    /**
     * @param {GroupInfosQuery} query
     * @returns {Map<number, Group | undefined>}
     */
    getGroupInfos(query) {
        const ret = wasm.wasmsdk_getGroupInfos(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupActionsQuery} query
     * @returns {Map<Identifier, GroupAction | undefined>}
     */
    getGroupActions(query) {
        const ret = wasm.wasmsdk_getGroupActions(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupMembersQuery} query
     * @returns {Map<Identifier, bigint>}
     */
    getGroupMembers(query) {
        const ret = wasm.wasmsdk_getGroupMembers(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {IdentityGroupsQuery} query
     * @returns {Array<IdentityGroupInfo>}
     */
    getIdentityGroups(query) {
        const ret = wasm.wasmsdk_getIdentityGroups(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupActionSignersQuery} query
     * @returns {Map<Identifier, bigint>}
     */
    getGroupActionSigners(query) {
        const ret = wasm.wasmsdk_getGroupActionSigners(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} dataContractIds
     * @returns {Map<Identifier, Map<number, Group | undefined>>}
     */
    getGroupsDataContracts(dataContractIds) {
        const ptr0 = passArrayJsValueToWasm0(dataContractIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getGroupsDataContracts(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @param {number} groupContractPosition
     * @returns {ProofMetadataResponseTyped<Group | undefined>}
     */
    getGroupInfoWithProofInfo(dataContractId, groupContractPosition) {
        const ret = wasm.wasmsdk_getGroupInfoWithProofInfo(this.__wbg_ptr, dataContractId, groupContractPosition);
        return ret;
    }
    /**
     * @param {GroupInfosQuery} query
     * @returns {ProofMetadataResponseTyped<Map<number, Group | undefined>>}
     */
    getGroupInfosWithProofInfo(query) {
        const ret = wasm.wasmsdk_getGroupInfosWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupActionsQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, GroupAction | undefined>>}
     */
    getGroupActionsWithProofInfo(query) {
        const ret = wasm.wasmsdk_getGroupActionsWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupMembersQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getGroupMembersWithProofInfo(query) {
        const ret = wasm.wasmsdk_getGroupMembersWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {IdentityGroupsQuery} query
     * @returns {ProofMetadataResponseTyped<Array<IdentityGroupInfo>>}
     */
    getIdentityGroupsWithProofInfo(query) {
        const ret = wasm.wasmsdk_getIdentityGroupsWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {GroupActionSignersQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getGroupActionSignersWithProofInfo(query) {
        const ret = wasm.wasmsdk_getGroupActionSignersWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} dataContractIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, Map<number, Group | undefined>>>}
     */
    getGroupsDataContractsWithProofInfo(dataContractIds) {
        const ptr0 = passArrayJsValueToWasm0(dataContractIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getGroupsDataContractsWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @param {string} documentType
     * @param {Identifier | Uint8Array | string} documentId
     * @returns {Promise<Document | undefined>}
     */
    getDocument(dataContractId, documentType, documentId) {
        const ptr0 = passStringToWasm0(documentType, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDocument(this.__wbg_ptr, dataContractId, ptr0, len0, documentId);
        return ret;
    }
    /**
     * @param {DocumentsQuery} query
     * @returns {Map<Identifier, Document | undefined>}
     */
    getDocuments(query) {
        const ret = wasm.wasmsdk_getDocuments(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @param {string} documentType
     * @param {Identifier | Uint8Array | string} documentId
     * @returns {ProofMetadataResponseTyped<Document | undefined>}
     */
    getDocumentWithProofInfo(dataContractId, documentType, documentId) {
        const ptr0 = passStringToWasm0(documentType, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDocumentWithProofInfo(this.__wbg_ptr, dataContractId, ptr0, len0, documentId);
        return ret;
    }
    /**
     * @param {DocumentsQuery} query
     * @returns {ProofMetadataResponseTyped<Map<Identifier, Document | undefined>>}
     */
    getDocumentsWithProofInfo(query) {
        const ret = wasm.wasmsdk_getDocumentsWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * Update an existing data contract on Dash Platform.
     *
     * This method handles the complete contract update flow:
     * 1. Creates and signs the contract update transition
     * 2. Broadcasts and waits for confirmation
     *
     * @param options - Update options including the updated data contract, public key, and signer
     * @returns Promise that resolves when the contract is updated
     * @param {ContractUpdateOptions} options
     * @returns {Promise<void>}
     */
    contractUpdate(options) {
        const ret = wasm.wasmsdk_contractUpdate(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Publish a new data contract on Dash Platform.
     *
     * This method handles the complete contract publishing flow:
     * 1. Validates the contract
     * 2. Creates and signs the contract create transition
     * 3. Broadcasts and waits for confirmation
     *
     * Note: The contract ID is generated by the platform using the identity nonce
     * at the time of publishing. The returned contract contains the actual ID.
     *
     * @param options - Options including the data contract, public key, and signer
     * @returns Promise that resolves to the published DataContract with the actual ID
     * @param {ContractPublishOptions} options
     * @returns {Promise<DataContract>}
     */
    contractPublish(options) {
        const ret = wasm.wasmsdk_contractPublish(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * @param {string} name
     * @returns {Promise<string | undefined>}
     */
    dpnsResolveName(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_dpnsResolveName(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {IdentifierLike} identityId
     * @returns {Promise<string | undefined>}
     */
    getDpnsUsername(identityId) {
        const ret = wasm.wasmsdk_getDpnsUsername(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * Register a DPNS username on Dash Platform.
     *
     * This method handles the complete DPNS registration flow:
     * 1. Creates and submits a preorder document
     * 2. Waits for preorder confirmation
     * 3. Creates and submits the domain document
     * 4. Returns the result with both document IDs
     *
     * @param options - Registration options including label, identity, key, and signer
     * @returns Promise that resolves to the registration result
     * @param {DpnsRegisterNameOptions} options
     * @returns {Promise<RegisterDpnsNameResult>}
     */
    dpnsRegisterName(options) {
        const ret = wasm.wasmsdk_dpnsRegisterName(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * @param {DpnsUsernamesQuery} query
     * @returns {Array<string>}
     */
    getDpnsUsernames(query) {
        const ret = wasm.wasmsdk_getDpnsUsernames(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {string} label
     * @returns {Promise<boolean>}
     */
    dpnsIsNameAvailable(label) {
        const ptr0 = passStringToWasm0(label, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_dpnsIsNameAvailable(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {string} label
     * @returns {boolean}
     */
    static dpnsIsValidUsername(label) {
        const ptr0 = passStringToWasm0(label, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_dpnsIsValidUsername(ptr0, len0);
        return ret !== 0;
    }
    /**
     * @param {string} username
     * @returns {Promise<DpnsUsernameInfo | undefined>}
     */
    getDpnsUsernameByName(username) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDpnsUsernameByName(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {string} label
     * @returns {boolean}
     */
    static dpnsIsContestedUsername(label) {
        const ptr0 = passStringToWasm0(label, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_dpnsIsContestedUsername(ptr0, len0);
        return ret !== 0;
    }
    /**
     * @param {string} input
     * @returns {string}
     */
    static dpnsConvertToHomographSafe(input) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.wasmsdk_dpnsConvertToHomographSafe(ptr0, len0);
            deferred2_0 = ret[0];
            deferred2_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {IdentifierLike} identityId
     * @returns {ProofMetadataResponseTyped<string | null>}
     */
    getDpnsUsernameWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getDpnsUsernameWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {DpnsUsernamesQuery} query
     * @returns {ProofMetadataResponseTyped<Array<string>>}
     */
    getDpnsUsernamesWithProofInfo(query) {
        const ret = wasm.wasmsdk_getDpnsUsernamesWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {string} username
     * @returns {ProofMetadataResponseTyped<DpnsUsernameInfo | null>}
     */
    getDpnsUsernameByNameWithProofInfo(username) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDpnsUsernameByNameWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Sign a message with a private key
     * @param {string} message
     * @param {string} privateKeyWif
     * @returns {string}
     */
    static signMessage(message, privateKeyWif) {
        let deferred4_0;
        let deferred4_1;
        try {
            const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(privateKeyWif, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            const ret = wasm.wasmsdk_signMessage(ptr0, len0, ptr1, len1);
            var ptr3 = ret[0];
            var len3 = ret[1];
            if (ret[3]) {
                ptr3 = 0; len3 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred4_0 = ptr3;
            deferred4_1 = len3;
            return getStringFromWasm0(ptr3, len3);
        } finally {
            wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);
        }
    }
    /**
     * Validate a Dash address
     * @param {string} address
     * @param {NetworkLike} network
     * @returns {boolean}
     */
    static validateAddress(address, network) {
        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_validateAddress(ptr0, len0, network);
        return ret !== 0;
    }
    /**
     * Generate a new random key pair
     * @param {NetworkLike} network
     * @returns {KeyPair}
     */
    static generateKeyPair(network) {
        const ret = wasm.wasmsdk_generateKeyPair(network);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KeyPair.__wrap(ret[0]);
    }
    /**
     * Create key pair from private key hex
     * @param {string} privateKeyHex
     * @param {NetworkLike} network
     * @returns {KeyPair}
     */
    static keyPairFromHex(privateKeyHex, network) {
        const ptr0 = passStringToWasm0(privateKeyHex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_keyPairFromHex(ptr0, len0, network);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KeyPair.__wrap(ret[0]);
    }
    /**
     * Create key pair from private key WIF
     * @param {string} privateKeyWif
     * @returns {KeyPair}
     */
    static keyPairFromWif(privateKeyWif) {
        const ptr0 = passStringToWasm0(privateKeyWif, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_keyPairFromWif(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KeyPair.__wrap(ret[0]);
    }
    /**
     * Get address from public key
     * @param {string} pubkeyHex
     * @param {NetworkLike} network
     * @returns {string}
     */
    static pubkeyToAddress(pubkeyHex, network) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(pubkeyHex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.wasmsdk_pubkeyToAddress(ptr0, len0, network);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * Generate multiple key pairs
     * @param {NetworkLike} network
     * @param {number} count
     * @returns {KeyPair[]}
     */
    static generateKeyPairs(network, count) {
        const ret = wasm.wasmsdk_generateKeyPairs(network, count);
        if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
        }
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Generate deterministic test identity keys for SDK functional tests.
     *
     * This generates the same keys that are created in the genesis state when
     * SDK_TEST_DATA=true is set. The seed should match the first byte of the
     * identity ID (1, 2, or 3 for the test identities).
     *
     * Returns an array of objects containing:
     * - keyId: The identity key ID
     * - privateKeyHex: The 32-byte private key in hex format
     * - publicKeyData: The public key data in hex (33 bytes for ECDSA_SECP256K1, 20 bytes for ECDSA_HASH160)
     * - keyType: The key type (e.g., "ECDSA_SECP256K1", "ECDSA_HASH160")
     * - purpose: The key purpose (e.g., "AUTHENTICATION", "TRANSFER")
     * - securityLevel: The security level (e.g., "MASTER", "CRITICAL", "HIGH")
     *
     * Key indices:
     * - 0: MASTER level AUTHENTICATION key (ECDSA_SECP256K1)
     * - 1: CRITICAL level AUTHENTICATION key (ECDSA_SECP256K1)
     * - 2: HIGH level AUTHENTICATION key (ECDSA_SECP256K1)
     * - 3: CRITICAL level TRANSFER key (ECDSA_HASH160) - for credit transfers
     * @param {bigint} seed
     * @returns {any}
     */
    static generateTestIdentityKeys(seed) {
        const ret = wasm.wasmsdk_generateTestIdentityKeys(seed);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * Derive a DashPay contact key using DIP15 with full identity IDs
     * @param {DeriveDashpayContactKeyParams} params
     * @returns {DashpayContactKeyInfo}
     */
    static deriveDashpayContactKey(params) {
        const ret = wasm.wasmsdk_deriveDashpayContactKey(params);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DashpayContactKeyInfo.__wrap(ret[0]);
    }
    /**
     * Derive a key from seed phrase with extended path supporting 256-bit indices
     * This supports DIP14/DIP15 paths with identity IDs
     * @param {DeriveKeyFromSeedWithExtendedPathParams} params
     * @returns {DerivedKeyInfo}
     */
    static deriveKeyFromSeedWithExtendedPath(params) {
        const ret = wasm.wasmsdk_deriveKeyFromSeedWithExtendedPath(params);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DerivedKeyInfo.__wrap(ret[0]);
    }
    /**
     * @returns {Promise<StatusResponse>}
     */
    getStatus() {
        const ret = wasm.wasmsdk_getStatus(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {string[]} path
     * @param {string[]} keys
     * @returns {Array<PathElement>}
     */
    getPathElements(path, keys) {
        const ptr0 = passArrayJsValueToWasm0(path, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(keys, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getPathElements(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * @returns {Promise<CurrentQuorumsInfo>}
     */
    getCurrentQuorumsInfo() {
        const ret = wasm.wasmsdk_getCurrentQuorumsInfo(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Promise<bigint>}
     */
    getTotalCreditsInPlatform() {
        const ret = wasm.wasmsdk_getTotalCreditsInPlatform(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {string} stateTransitionHash
     * @returns {Promise<StateTransitionResult>}
     */
    waitForStateTransitionResult(stateTransitionHash) {
        const ptr0 = passStringToWasm0(stateTransitionHash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_waitForStateTransitionResult(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {string[]} path
     * @param {string[]} keys
     * @returns {ProofMetadataResponseTyped<Array<PathElement>>}
     */
    getPathElementsWithProofInfo(path, keys) {
        const ptr0 = passArrayJsValueToWasm0(path, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(keys, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getPathElementsWithProofInfo(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {Promise<PrefundedSpecializedBalance>}
     */
    getPrefundedSpecializedBalance(identityId) {
        const ret = wasm.wasmsdk_getPrefundedSpecializedBalance(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @returns {ProofMetadataResponseTyped<bigint | undefined>}
     */
    getTotalCreditsInPlatformWithProofInfo() {
        const ret = wasm.wasmsdk_getTotalCreditsInPlatformWithProofInfo(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {ProofMetadataResponseTyped<PrefundedSpecializedBalance | undefined>}
     */
    getPrefundedSpecializedBalanceWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getPrefundedSpecializedBalanceWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {ContestedResourceVoteStateQuery} query
     * @returns {Promise<ContestedResourceVoteState>}
     */
    getContestedResourceVoteState(query) {
        const ret = wasm.wasmsdk_getContestedResourceVoteState(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {ContestedResourceVoteStateQuery} query
     * @returns {ProofMetadataResponseTyped<ContestedResourceVoteState>}
     */
    getContestedResourceVoteStateWithProofInfo(query) {
        const ret = wasm.wasmsdk_getContestedResourceVoteStateWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * Create a new identity on Dash Platform.
     *
     * This method handles the complete identity creation flow:
     * 1. Validates the asset lock proof
     * 2. Signs each public key with the corresponding private key
     * 3. Builds and signs the identity create transition
     * 4. Broadcasts and waits for confirmation
     *
     * @param options - Creation options including identity, asset lock, and signer
     * @returns Promise that resolves when the identity is created
     * @param {IdentityCreateOptions} options
     * @returns {Promise<void>}
     */
    identityCreate(options) {
        const ret = wasm.wasmsdk_identityCreate(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Top up an existing identity with additional credits.
     *
     * This method handles the complete top up flow:
     * 1. Validates the asset lock proof
     * 2. Builds and signs the identity top up transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Top up options including identity, asset lock, and private key
     * @returns Promise resolving to the new balance after top up
     * @param {IdentityTopUpOptions} options
     * @returns {Promise<bigint>}
     */
    identityTopUp(options) {
        const ret = wasm.wasmsdk_identityTopUp(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Update an identity by adding or disabling public keys.
     *
     * This method handles the complete update flow:
     * 1. Validates the master key for signing
     * 2. Validates keys to add/disable
     * 3. Builds and signs the identity update transition
     * 4. Broadcasts and waits for confirmation
     *
     * @param options - Update options including identity, keys to add/disable, and signer
     * @returns Promise that resolves when the update is complete
     * @param {IdentityUpdateOptions} options
     * @returns {Promise<void>}
     */
    identityUpdate(options) {
        const ret = wasm.wasmsdk_identityUpdate(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Submit a masternode vote for a contested resource.
     *
     * This method handles the complete voting flow:
     * 1. Creates the voting public key from the signer
     * 2. Builds and signs the vote transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Vote options including masternode ID, vote poll, choice, and signer
     * @returns Promise that resolves when the vote is submitted
     * @param {MasternodeVoteOptions} options
     * @returns {Promise<void>}
     */
    masternodeVote(options) {
        const ret = wasm.wasmsdk_masternodeVote(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Transfer credits from one identity to another.
     *
     * This method handles the complete transfer flow:
     * 1. Finds the appropriate transfer key to use for signing (or uses the provided one)
     * 2. Builds and signs the credit transfer transition
     * 3. Broadcasts and waits for confirmation
     *
     * @param options - Transfer options including identity, recipient, amount, and signer
     * @returns Promise resolving to IdentityCreditTransferResult with both balances
     * @param {IdentityCreditTransferOptions} options
     * @returns {Promise<IdentityCreditTransferResult>}
     */
    identityCreditTransfer(options) {
        const ret = wasm.wasmsdk_identityCreditTransfer(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Withdraw credits from an identity to a Dash address.
     *
     * This method handles the complete withdrawal flow:
     * 1. Finds the appropriate transfer/owner key to use for signing (or uses the provided one)
     * 2. Builds and signs the withdrawal transition
     * 3. Broadcasts and waits for confirmation
     * 4. The withdrawal may be pooled with others depending on the pooling strategy
     *
     * @param options - Withdrawal options including identity, amount, destination, and signer
     * @returns Promise resolving to the remaining balance after withdrawal
     * @param {IdentityCreditWithdrawalOptions} options
     * @returns {Promise<bigint>}
     */
    identityCreditWithdrawal(options) {
        const ret = wasm.wasmsdk_identityCreditWithdrawal(this.__wbg_ptr, options);
        return ret;
    }
    /**
     * Configure tracing/logging level or filter (static, global)
     *
     * Accepts simple levels: "off", "error", "warn", "info", "debug", "trace"
     * or a full EnvFilter string like: "wasm_sdk=debug,rs_dapi_client=warn"
     * @param {string} levelOrFilter
     */
    static setLogLevel(levelOrFilter) {
        const ptr0 = passStringToWasm0(levelOrFilter, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_setLogLevel(ptr0, len0);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * Forces reload of the identity nonce from Platform on the next state transition.
     *
     * This clears the cached nonce for the given identity, ensuring that the next
     * state transition will fetch the current nonce from Platform instead of using
     * a potentially stale cached value.
     *
     * @param identityId - The identifier of the identity whose nonce cache should be cleared
     * @param {Identifier} identity_id
     * @returns {Promise<void>}
     */
    refreshIdentityNonce(identity_id) {
        _assertClass(identity_id, Identifier);
        var ptr0 = identity_id.__destroy_into_raw();
        const ret = wasm.wasmsdk_refreshIdentityNonce(this.__wbg_ptr, ptr0);
        return ret;
    }
    /**
     * Remove a data contract from the cache.
     * This forces a fresh fetch from the network on the next access.
     * Returns true if the contract was in the cache and was removed.
     * @param {Identifier} contractId
     * @returns {boolean}
     */
    removeCachedContract(contractId) {
        _assertClass(contractId, Identifier);
        const ret = wasm.wasmsdk_removeCachedContract(this.__wbg_ptr, contractId.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {Promise<void>}
     */
    static prefetchTrustedQuorumsLocal() {
        const ret = wasm.wasmsdk_prefetchTrustedQuorumsLocal();
        return ret;
    }
    /**
     * @returns {Promise<void>}
     */
    static prefetchTrustedQuorumsMainnet() {
        const ret = wasm.wasmsdk_prefetchTrustedQuorumsMainnet();
        return ret;
    }
    /**
     * @returns {Promise<void>}
     */
    static prefetchTrustedQuorumsTestnet() {
        const ret = wasm.wasmsdk_prefetchTrustedQuorumsTestnet();
        return ret;
    }
    /**
     * @returns {number}
     */
    version() {
        const ret = wasm.wasmsdk_version(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {Map<Identifier, TokenStatus>}
     */
    getTokenStatuses(tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getTokenStatuses(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {Promise<TokenTotalSupply | undefined>}
     */
    getTokenTotalSupply(tokenId) {
        const ret = wasm.wasmsdk_getTokenTotalSupply(this.__wbg_ptr, tokenId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @returns {Promise<TokenContractInfo | undefined>}
     */
    getTokenContractInfo(dataContractId) {
        const ret = wasm.wasmsdk_getTokenContractInfo(this.__wbg_ptr, dataContractId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {Map<Identifier, IdentityTokenInfo>}
     */
    getIdentityTokenInfos(identityId, tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentityTokenInfos(this.__wbg_ptr, identityId, ptr0, len0);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {Map<Identifier, IdentityTokenInfo>}
     */
    getIdentitiesTokenInfos(identityIds, tokenId) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesTokenInfos(this.__wbg_ptr, ptr0, len0, tokenId);
        return ret;
    }
    /**
     * Get the current price of a token by contract ID and position
     *
     * This is a convenience function that calculates the token ID from the contract ID
     * and position, then fetches the current pricing schedule for that token.
     *
     * # Arguments
     * * `sdk` - The WasmSdk instance
     * * `contract_id` - The data contract ID in base58 format
     * * `token_position` - The position of the token in the contract (0-indexed)
     *
     * # Returns
     * An object containing:
     * - `tokenId`: The calculated token ID
     * - `currentPrice`: The current price of the token
     * - `basePrice`: The base price of the token (may be same as current for single price)
     *
     * # Example
     * ```javascript
     * const priceInfo = await sdk.getTokenPriceByContract(
     *     sdk,
     *     "Hqyu8WcRwXCTwbNxdga4CN5gsVEGc67wng4TFzceyLUv",
     *     0
     * );
     * console.log(`Token ${priceInfo.tokenId.toBase58()} current price: ${priceInfo.currentPrice}`);
     * ```
     * @param {Identifier | Uint8Array | string} contractId
     * @param {number} tokenPosition
     * @returns {Promise<TokenPriceInfo>}
     */
    getTokenPriceByContract(contractId, tokenPosition) {
        const ret = wasm.wasmsdk_getTokenPriceByContract(this.__wbg_ptr, contractId, tokenPosition);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {Map<Identifier, bigint>}
     */
    getIdentitiesTokenBalances(identityIds, tokenId) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesTokenBalances(this.__wbg_ptr, ptr0, len0, tokenId);
        return ret;
    }
    /**
     * Calculate token ID from contract ID and token position
     *
     * This function calculates the unique token ID based on a data contract ID
     * and the position of the token within that contract.
     *
     * # Arguments
     * * `contract_id` - The data contract ID in base58 format
     * * `token_position` - The position of the token in the contract (0-indexed)
     *
     * # Returns
     * The calculated token ID in base58 format
     *
     * # Example
     * ```javascript
     * const tokenId = await sdk.calculateTokenId("Hqyu8WcRwXCTwbNxdga4CN5gsVEGc67wng4TFzceyLUv", 0);
     * ```
     * @param {Identifier | Uint8Array | string} contractId
     * @param {number} tokenPosition
     * @returns {string}
     */
    static calculateTokenIdFromContract(contractId, tokenPosition) {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.wasmsdk_calculateTokenIdFromContract(contractId, tokenPosition);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {Map<Identifier, TokenPriceInfo>}
     */
    getTokenDirectPurchasePrices(tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getTokenDirectPurchasePrices(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, TokenStatus>>}
     */
    getTokenStatusesWithProofInfo(tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getTokenStatusesWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {ProofMetadataResponseTyped<TokenTotalSupply | null>}
     */
    getTokenTotalSupplyWithProofInfo(tokenId) {
        const ret = wasm.wasmsdk_getTokenTotalSupplyWithProofInfo(this.__wbg_ptr, tokenId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} dataContractId
     * @returns {ProofMetadataResponseTyped<TokenContractInfo | undefined>}
     */
    getTokenContractInfoWithProofInfo(dataContractId) {
        const ret = wasm.wasmsdk_getTokenContractInfoWithProofInfo(this.__wbg_ptr, dataContractId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, IdentityTokenInfo>>}
     */
    getIdentityTokenInfosWithProofInfo(identityId, tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentityTokenInfosWithProofInfo(this.__wbg_ptr, identityId, ptr0, len0);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {ProofMetadataResponseTyped<Map<Identifier, IdentityTokenInfo>>}
     */
    getIdentitiesTokenInfosWithProofInfo(identityIds, tokenId) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesTokenInfosWithProofInfo(this.__wbg_ptr, ptr0, len0, tokenId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {Promise<RewardDistributionMoment | undefined>}
     */
    getTokenPerpetualDistributionLastClaim(identityId, tokenId) {
        const ret = wasm.wasmsdk_getTokenPerpetualDistributionLastClaim(this.__wbg_ptr, identityId, tokenId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getIdentitiesTokenBalancesWithProofInfo(identityIds, tokenId) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesTokenBalancesWithProofInfo(this.__wbg_ptr, ptr0, len0, tokenId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, TokenPriceInfo>>}
     */
    getTokenDirectPurchasePricesWithProofInfo(tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getTokenDirectPurchasePricesWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Identifier | Uint8Array | string} tokenId
     * @returns {ProofMetadataResponseTyped<TokenLastClaim | undefined>}
     */
    getTokenPerpetualDistributionLastClaimWithProofInfo(identityId, tokenId) {
        const ret = wasm.wasmsdk_getTokenPerpetualDistributionLastClaimWithProofInfo(this.__wbg_ptr, identityId, tokenId);
        return ret;
    }
    /**
     * @param {VotePollsByEndDateQuery | null} [query]
     * @returns {Array<VotePollsByEndDateEntry>}
     */
    getVotePollsByEndDate(query) {
        const ret = wasm.wasmsdk_getVotePollsByEndDate(this.__wbg_ptr, isLikeNone(query) ? 0 : addToExternrefTable0(query));
        return ret;
    }
    /**
     * @param {VotePollsByEndDateQuery | null} [query]
     * @returns {ProofMetadataResponseTyped<Array<VotePollsByEndDateEntry>>}
     */
    getVotePollsByEndDateWithProofInfo(query) {
        const ret = wasm.wasmsdk_getVotePollsByEndDateWithProofInfo(this.__wbg_ptr, isLikeNone(query) ? 0 : addToExternrefTable0(query));
        return ret;
    }
    /**
     * @param {ContestedResourceVotersForIdentityQuery} query
     * @returns {Array<Identifier>}
     */
    getContestedResourceVotersForIdentity(query) {
        const ret = wasm.wasmsdk_getContestedResourceVotersForIdentity(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {ContestedResourceVotersForIdentityQuery} query
     * @returns {ProofMetadataResponseTyped<Array<Identifier>>}
     */
    getContestedResourceVotersForIdentityWithProofInfo(query) {
        const ret = wasm.wasmsdk_getContestedResourceVotersForIdentityWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @returns {Promise<ProtocolVersionUpgradeState>}
     */
    getProtocolVersionUpgradeState() {
        const ret = wasm.wasmsdk_getProtocolVersionUpgradeState(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {ProTxHashLike | null} startProTxHash
     * @param {number} count
     * @returns {Map<string, ProtocolVersionUpgradeVoteStatus>}
     */
    getProtocolVersionUpgradeVoteStatus(startProTxHash, count) {
        const ret = wasm.wasmsdk_getProtocolVersionUpgradeVoteStatus(this.__wbg_ptr, startProTxHash, count);
        return ret;
    }
    /**
     * @returns {ProofMetadataResponseTyped<ProtocolVersionUpgradeState>}
     */
    getProtocolVersionUpgradeStateWithProofInfo() {
        const ret = wasm.wasmsdk_getProtocolVersionUpgradeStateWithProofInfo(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {ProTxHashLike | null} startProTxHash
     * @param {number} count
     * @returns {ProofMetadataResponseTyped<Map<string, ProtocolVersionUpgradeVoteStatus>>}
     */
    getProtocolVersionUpgradeVoteStatusWithProofInfo(startProTxHash, count) {
        const ret = wasm.wasmsdk_getProtocolVersionUpgradeVoteStatusWithProofInfo(this.__wbg_ptr, startProTxHash, count);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} contractId
     * @returns {Promise<DataContract | undefined>}
     */
    getDataContract(contractId) {
        const ret = wasm.wasmsdk_getDataContract(this.__wbg_ptr, contractId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} ids
     * @returns {Map<Identifier, DataContract | undefined>}
     */
    getDataContracts(ids) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDataContracts(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {DataContractHistoryQuery} query
     * @returns {Map<bigint, DataContract>}
     */
    getDataContractHistory(query) {
        const ret = wasm.wasmsdk_getDataContractHistory(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} contractId
     * @returns {ProofMetadataResponseTyped<DataContract>}
     */
    getDataContractWithProofInfo(contractId) {
        const ret = wasm.wasmsdk_getDataContractWithProofInfo(this.__wbg_ptr, contractId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} ids
     * @returns {ProofMetadataResponseTyped<Map<Identifier, DataContract | undefined>>}
     */
    getDataContractsWithProofInfo(ids) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getDataContractsWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {DataContractHistoryQuery} query
     * @returns {ProofMetadataResponseTyped<Map<bigint, DataContract>>}
     */
    getDataContractHistoryWithProofInfo(query) {
        const ret = wasm.wasmsdk_getDataContractHistoryWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * Fetches information about a Platform address including its nonce and balance.
     *
     * @param address - The platform address to query (PlatformAddress, Uint8Array, or bech32m string)
     * @returns PlatformAddressInfo containing address, nonce, and balance
     * @param {PlatformAddressLike} address
     * @returns {Promise<PlatformAddressInfo | undefined>}
     */
    getAddressInfo(address) {
        const ret = wasm.wasmsdk_getAddressInfo(this.__wbg_ptr, address);
        return ret;
    }
    /**
     * Fetches information about multiple Platform addresses.
     *
     * @param addresses - Array of platform addresses to query
     * @returns Map of PlatformAddress to PlatformAddressInfo (or undefined for unfunded addresses)
     * @param {Array<PlatformAddressLike>} addresses
     * @returns {Map<PlatformAddress, PlatformAddressInfo | undefined>}
     */
    getAddressesInfos(addresses) {
        const ptr0 = passArrayJsValueToWasm0(addresses, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getAddressesInfos(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Fetches information about a Platform address including its nonce and balance, with proof.
     *
     * @param address - The platform address to query (PlatformAddress, Uint8Array, or bech32m string)
     * @returns ProofMetadataResponse containing PlatformAddressInfo with proof information
     * @param {PlatformAddressLike} address
     * @returns {ProofMetadataResponseTyped<PlatformAddressInfo>}
     */
    getAddressInfoWithProofInfo(address) {
        const ret = wasm.wasmsdk_getAddressInfoWithProofInfo(this.__wbg_ptr, address);
        return ret;
    }
    /**
     * Fetches information about multiple Platform addresses with proof.
     *
     * @param addresses - Array of platform addresses to query
     * @returns ProofMetadataResponse containing Map of PlatformAddress to PlatformAddressInfo
     * @param {Array<PlatformAddressLike>} addresses
     * @returns {ProofMetadataResponseTyped<Map<PlatformAddress, PlatformAddressInfo | undefined>>}
     */
    getAddressesInfosWithProofInfo(addresses) {
        const ptr0 = passArrayJsValueToWasm0(addresses, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getAddressesInfosWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {Promise<Identity | undefined>}
     */
    getIdentity(identityId) {
        const ret = wasm.wasmsdk_getIdentity(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {IdentityKeysQuery} query
     * @returns {Array<IdentityPublicKey>}
     */
    getIdentityKeys(query) {
        const ret = wasm.wasmsdk_getIdentityKeys(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {bigint | null}
     */
    getIdentityNonce(identityId) {
        const ret = wasm.wasmsdk_getIdentityNonce(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {bigint | null}
     */
    getIdentityBalance(identityId) {
        const ret = wasm.wasmsdk_getIdentityBalance(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {Promise<Identity>}
     */
    getIdentityUnproved(identityId) {
        const ret = wasm.wasmsdk_getIdentityUnproved(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @returns {Map<Identifier, bigint | null>}
     */
    getIdentitiesBalances(identityIds) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesBalances(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Identifier | Uint8Array | string} contractId
     * @returns {bigint | null}
     */
    getIdentityContractNonce(identityId, contractId) {
        const ret = wasm.wasmsdk_getIdentityContractNonce(this.__wbg_ptr, identityId, contractId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {Map<Identifier, bigint>}
     */
    getIdentityTokenBalances(identityId, tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentityTokenBalances(this.__wbg_ptr, identityId, ptr0, len0);
        return ret;
    }
    /**
     * @param {IdentitiesContractKeysQuery} query
     * @returns {Array<IdentityContractKeys>}
     */
    getIdentitiesContractKeys(query) {
        const ret = wasm.wasmsdk_getIdentitiesContractKeys(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {ProofMetadataResponseTyped<Identity | null>}
     */
    getIdentityWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getIdentityWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {string | Uint8Array} publicKeyHash
     * @returns {Identity | null}
     */
    getIdentityByPublicKeyHash(publicKeyHash) {
        const ret = wasm.wasmsdk_getIdentityByPublicKeyHash(this.__wbg_ptr, publicKeyHash);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {IdentityBalanceAndRevision | null}
     */
    getIdentityBalanceAndRevision(identityId) {
        const ret = wasm.wasmsdk_getIdentityBalanceAndRevision(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {IdentityKeysQuery} query
     * @returns {ProofMetadataResponseTyped<Array<IdentityPublicKey>>}
     */
    getIdentityKeysWithProofInfo(query) {
        const ret = wasm.wasmsdk_getIdentityKeysWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {ProofMetadataResponseTyped<bigint | null>}
     */
    getIdentityNonceWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getIdentityNonceWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {ProofMetadataResponseTyped<bigint | null>}
     */
    getIdentityBalanceWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getIdentityBalanceWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {Array<Identifier | Uint8Array | string>} identityIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint | null>>}
     */
    getIdentitiesBalancesWithProofInfo(identityIds) {
        const ptr0 = passArrayJsValueToWasm0(identityIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentitiesBalancesWithProofInfo(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * @param {string | Uint8Array} publicKeyHash
     * @param {Identifier | Uint8Array | string | undefined} startAfterId
     * @returns {Array<Identity>}
     */
    getIdentityByNonUniquePublicKeyHash(publicKeyHash, startAfterId) {
        const ret = wasm.wasmsdk_getIdentityByNonUniquePublicKeyHash(this.__wbg_ptr, publicKeyHash, startAfterId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Identifier | Uint8Array | string} contractId
     * @returns {ProofMetadataResponseTyped<bigint | null>}
     */
    getIdentityContractNonceWithProofInfo(identityId, contractId) {
        const ret = wasm.wasmsdk_getIdentityContractNonceWithProofInfo(this.__wbg_ptr, identityId, contractId);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @param {Array<Identifier | Uint8Array | string>} tokenIds
     * @returns {ProofMetadataResponseTyped<Map<Identifier, bigint>>}
     */
    getIdentityTokenBalancesWithProofInfo(identityId, tokenIds) {
        const ptr0 = passArrayJsValueToWasm0(tokenIds, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdk_getIdentityTokenBalancesWithProofInfo(this.__wbg_ptr, identityId, ptr0, len0);
        return ret;
    }
    /**
     * @param {IdentitiesContractKeysQuery} query
     * @returns {ProofMetadataResponseTyped<Array<IdentityContractKeys>>}
     */
    getIdentitiesContractKeysWithProofInfo(query) {
        const ret = wasm.wasmsdk_getIdentitiesContractKeysWithProofInfo(this.__wbg_ptr, query);
        return ret;
    }
    /**
     * @param {string | Uint8Array} publicKeyHash
     * @returns {ProofMetadataResponseTyped<Identity | null>}
     */
    getIdentityByPublicKeyHashWithProofInfo(publicKeyHash) {
        const ret = wasm.wasmsdk_getIdentityByPublicKeyHashWithProofInfo(this.__wbg_ptr, publicKeyHash);
        return ret;
    }
    /**
     * @param {Identifier | Uint8Array | string} identityId
     * @returns {ProofMetadataResponseTyped<IdentityBalanceAndRevision | null>}
     */
    getIdentityBalanceAndRevisionWithProofInfo(identityId) {
        const ret = wasm.wasmsdk_getIdentityBalanceAndRevisionWithProofInfo(this.__wbg_ptr, identityId);
        return ret;
    }
    /**
     * @param {string | Uint8Array} publicKeyHash
     * @param {Identifier | Uint8Array | string | undefined} startAfterId
     * @returns {ProofMetadataResponseTyped<Array<Identity>>}
     */
    getIdentityByNonUniquePublicKeyHashWithProofInfo(publicKeyHash, startAfterId) {
        const ret = wasm.wasmsdk_getIdentityByNonUniquePublicKeyHashWithProofInfo(this.__wbg_ptr, publicKeyHash, startAfterId);
        return ret;
    }
}

const WasmSdkBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmsdkbuilder_free(ptr >>> 0, 1));

export class WasmSdkBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmSdkBuilder.prototype);
        obj.__wbg_ptr = ptr;
        WasmSdkBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmSdkBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmsdkbuilder_free(ptr, 0);
    }
    /**
     * @returns {WasmSdkBuilder}
     */
    static mainnet() {
        const ret = wasm.wasmsdkbuilder_mainnet();
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * @returns {WasmSdkBuilder}
     */
    static testnet() {
        const ret = wasm.wasmsdkbuilder_testnet();
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * @param {boolean} enableProofs
     * @returns {WasmSdkBuilder}
     */
    withProofs(enableProofs) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.wasmsdkbuilder_withProofs(ptr, enableProofs);
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * Configure platform version to use.
     *
     * Available versions:
     * - 1: Platform version 1
     * - 2: Platform version 2
     * - ... up to latest version
     *
     * Defaults to latest version if not specified.
     * @param {number} versionNumber
     * @returns {WasmSdkBuilder}
     */
    withVersion(versionNumber) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.wasmsdkbuilder_withVersion(ptr, versionNumber);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
    /**
     * Configure request settings for the SDK.
     *
     * Settings include:
     * - connect_timeout_ms: Timeout for establishing connection (in milliseconds)
     * - timeout_ms: Timeout for single request (in milliseconds)
     * - retries: Number of retries in case of failed requests
     * - ban_failed_address: Whether to ban DAPI address if node not responded or responded with error
     * @param {number | null} [connectTimeoutMs]
     * @param {number | null} [timeoutMs]
     * @param {number | null} [retries]
     * @param {boolean | null} [banFailedAddress]
     * @returns {WasmSdkBuilder}
     */
    withSettings(connectTimeoutMs, timeoutMs, retries, banFailedAddress) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.wasmsdkbuilder_withSettings(ptr, isLikeNone(connectTimeoutMs) ? 0x100000001 : (connectTimeoutMs) >>> 0, isLikeNone(timeoutMs) ? 0x100000001 : (timeoutMs) >>> 0, isLikeNone(retries) ? 0x100000001 : (retries) >>> 0, isLikeNone(banFailedAddress) ? 0xFFFFFF : banFailedAddress ? 1 : 0);
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * @returns {WasmSdkBuilder}
     */
    static localTrusted() {
        const ret = wasm.wasmsdkbuilder_localTrusted();
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
    /**
     * Create a new SdkBuilder with specific addresses and network.
     *
     * # Arguments
     * * `addresses` - Array of HTTPS URLs (e.g., ["https://127.0.0.1:1443"])
     * * `network` - Network identifier: "mainnet", "testnet" or "local"
     *
     * # Example
     * ```javascript
     * const builder = WasmSdkBuilder.withAddresses(['https://127.0.0.1:1443'], 'testnet');
     * const sdk = builder.build();
     * ```
     * @param {string[]} addresses
     * @param {string} network
     * @returns {WasmSdkBuilder}
     */
    static withAddresses(addresses, network) {
        const ptr0 = passArrayJsValueToWasm0(addresses, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(network, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdkbuilder_withAddresses(ptr0, len0, ptr1, len1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {WasmSdkBuilder}
     */
    static mainnetTrusted() {
        const ret = wasm.wasmsdkbuilder_mainnetTrusted();
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {WasmSdkBuilder}
     */
    static testnetTrusted() {
        const ret = wasm.wasmsdkbuilder_testnetTrusted();
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
    /**
     * @param {WasmContext} contextProvider
     * @returns {WasmSdkBuilder}
     */
    withContextProvider(contextProvider) {
        const ptr = this.__destroy_into_raw();
        _assertClass(contextProvider, WasmContext);
        var ptr0 = contextProvider.__destroy_into_raw();
        const ret = wasm.wasmsdkbuilder_withContextProvider(ptr, ptr0);
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * Get the latest platform version number
     * @returns {number}
     */
    static getLatestVersionNumber() {
        const ret = wasm.wasmsdkbuilder_getLatestVersionNumber();
        return ret >>> 0;
    }
    /**
     * @returns {WasmSdk}
     */
    build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.wasmsdkbuilder_build(ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdk.__wrap(ret[0]);
    }
    /**
     * Create a new SdkBuilder preconfigured for a local network using default dashmate gateway.
     * @returns {WasmSdkBuilder}
     */
    static local() {
        const ret = wasm.wasmsdkbuilder_local();
        return WasmSdkBuilder.__wrap(ret);
    }
    /**
     * Configure tracing/logging via the builder
     * Returns a new builder with logging configured
     * @param {string} levelOrFilter
     * @returns {WasmSdkBuilder}
     */
    withLogs(levelOrFilter) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(levelOrFilter, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmsdkbuilder_withLogs(ptr, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WasmSdkBuilder.__wrap(ret[0]);
    }
}

const WasmSdkErrorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmsdkerror_free(ptr >>> 0, 1));
/**
 * Structured error surfaced to JS consumers
 */
export class WasmSdkError {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmSdkError.prototype);
        obj.__wbg_ptr = ptr;
        WasmSdkErrorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmSdkErrorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmsdkerror_free(ptr, 0);
    }
    /**
     * Optional numeric code. -1 means absent/not applicable
     * @returns {number}
     */
    get code() {
        const ret = wasm.wasmsdkerror_code(this.__wbg_ptr);
        return ret;
    }
    /**
     * Error kind (enum)
     * @returns {WasmSdkErrorKind}
     */
    get kind() {
        const ret = wasm.wasmsdkerror_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * Backwards-compatible name string for the kind
     * @returns {string}
     */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmsdkerror_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Human-readable message
     * @returns {string}
     */
    get message() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmsdkerror_message(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Whether the error is retryable
     * @returns {boolean}
     */
    get retriable() {
        const ret = wasm.wasmsdkerror_retriable(this.__wbg_ptr);
        return ret !== 0;
    }
}

const EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);

                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_BigInt_0855c3daedcc918c = function() { return handleError(function (arg0) {
        const ret = BigInt(arg0);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_BigInt_b883561dbfd65c5d = function(arg0, arg1) {
        const ret = BigInt(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_BigInt_d53045318206d695 = function(arg0) {
        const ret = BigInt(arg0);
        return ret;
    };
    imports.wbg.__wbg_Error_1f3748b298f99708 = function(arg0, arg1) {
        const ret = Error(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_String_eecc4a11987127d6 = function(arg0, arg1) {
        const ret = String(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_abort_6665281623826052 = function(arg0) {
        arg0.abort();
    };
    imports.wbg.__wbg_abort_c11a5d245a242912 = function(arg0, arg1) {
        arg0.abort(arg1);
    };
    imports.wbg.__wbg_append_3e86b0cd6215edd8 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        arg0.append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments) };
    imports.wbg.__wbg_arrayBuffer_55e4a430671abfd8 = function() { return handleError(function (arg0) {
        const ret = arg0.arrayBuffer();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_assetlockproof_new = function(arg0) {
        const ret = AssetLockProof.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_authorizedactiontakers_new = function(arg0) {
        const ret = AuthorizedActionTakers.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_batchedtransition_new = function(arg0) {
        const ret = BatchedTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_blockbaseddistribution_new = function(arg0) {
        const ret = BlockBasedDistribution.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_body_be60ee806470b990 = function(arg0) {
        const ret = arg0.body;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_buffer_1f897e9f3ed6b41d = function(arg0) {
        const ret = arg0.buffer;
        return ret;
    };
    imports.wbg.__wbg_byobRequest_ba853121442653bf = function(arg0) {
        const ret = arg0.byobRequest;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_byteLength_7029fecd0c136e6d = function(arg0) {
        const ret = arg0.byteLength;
        return ret;
    };
    imports.wbg.__wbg_byteOffset_8161a341c0d72844 = function(arg0) {
        const ret = arg0.byteOffset;
        return ret;
    };
    imports.wbg.__wbg_call_2f8d426a20a307fe = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_f53f0647ceb9c567 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_cancel_8fc34c38a41c5d07 = function(arg0) {
        const ret = arg0.cancel();
        return ret;
    };
    imports.wbg.__wbg_catch_70a1618b6f59db8a = function(arg0, arg1) {
        const ret = arg0.catch(arg1);
        return ret;
    };
    imports.wbg.__wbg_clearTimeout_2e2c4939388cdfbb = function(arg0) {
        const ret = clearTimeout(arg0);
        return ret;
    };
    imports.wbg.__wbg_clearTimeout_42d9ccd50822fd3a = function(arg0) {
        const ret = clearTimeout(arg0);
        return ret;
    };
    imports.wbg.__wbg_clearTimeout_5a54f8841c30079a = function(arg0) {
        const ret = clearTimeout(arg0);
        return ret;
    };
    imports.wbg.__wbg_close_a90439b2444e47b4 = function() { return handleError(function (arg0) {
        arg0.close();
    }, arguments) };
    imports.wbg.__wbg_close_f602227805f17f95 = function() { return handleError(function (arg0) {
        arg0.close();
    }, arguments) };
    imports.wbg.__wbg_contestedresourcecontender_new = function(arg0) {
        const ret = ContestedResourceContender.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_contestedresourcevotestate_new = function(arg0) {
        const ret = ContestedResourceVoteState.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_contractbounds_new = function(arg0) {
        const ret = ContractBounds.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {
        const ret = arg0.crypto;
        return ret;
    };
    imports.wbg.__wbg_currentquorumsinfo_new = function(arg0) {
        const ret = CurrentQuorumsInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_datacontract_new = function(arg0) {
        const ret = DataContract.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionexponential_new = function(arg0) {
        const ret = DistributionExponential.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionfixedamount_new = function(arg0) {
        const ret = DistributionFixedAmount.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributioninvertedlogarithmic_new = function(arg0) {
        const ret = DistributionInvertedLogarithmic.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionlinear_new = function(arg0) {
        const ret = DistributionLinear.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionlogarithmic_new = function(arg0) {
        const ret = DistributionLogarithmic.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionpolynomial_new = function(arg0) {
        const ret = DistributionPolynomial.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionrandom_new = function(arg0) {
        const ret = DistributionRandom.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_distributionstepdecreasingamount_new = function(arg0) {
        const ret = DistributionStepDecreasingAmount.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_document_new = function(arg0) {
        const ret = Document.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_documenttransition_new = function(arg0) {
        const ret = DocumentTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_done_4a7743b6f942c9f3 = function(arg0) {
        const ret = arg0.done;
        return ret;
    };
    imports.wbg.__wbg_dpnsusernameinfo_new = function(arg0) {
        const ret = DpnsUsernameInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_enqueue_1e58bed4477a141f = function() { return handleError(function (arg0, arg1) {
        arg0.enqueue(arg1);
    }, arguments) };
    imports.wbg.__wbg_entries_17f7acbc2d691c0d = function(arg0) {
        const ret = Object.entries(arg0);
        return ret;
    };
    imports.wbg.__wbg_epochbaseddistribution_new = function(arg0) {
        const ret = EpochBasedDistribution.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0(arg0, arg1));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_extendedepochinfo_new = function(arg0) {
        const ret = ExtendedEpochInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_fetch_4fae101547df73b6 = function(arg0, arg1, arg2) {
        const ret = arg0.fetch(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_fetch_53eef7df7b439a49 = function(arg0, arg1) {
        const ret = fetch(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbg_fetch_6bbc32f991730587 = function(arg0) {
        const ret = fetch(arg0);
        return ret;
    };
    imports.wbg.__wbg_fetch_9885d2e26ad251bb = function(arg0, arg1) {
        const ret = arg0.fetch(arg1);
        return ret;
    };
    imports.wbg.__wbg_finalizedepochinfo_new = function(arg0) {
        const ret = FinalizedEpochInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_forEach_d3693088122c0e7b = function(arg0, arg1, arg2) {
        try {
            var state0 = {a: arg1, b: arg2};
            var cb0 = (arg0, arg1) => {
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_2496(a, state0.b, arg0, arg1);
                } finally {
                    state0.a = a;
                }
            };
            arg0.forEach(cb0);
        } finally {
            state0.a = state0.b = 0;
        }
    };
    imports.wbg.__wbg_from_237b1ad767238d8b = function(arg0) {
        const ret = Array.from(arg0);
        return ret;
    };
    imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() { return handleError(function (arg0, arg1) {
        arg0.getRandomValues(arg1);
    }, arguments) };
    imports.wbg.__wbg_getReader_48e00749fe3f6089 = function() { return handleError(function (arg0) {
        const ret = arg0.getReader();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_getTime_5b1dd03bb6d4b784 = function(arg0) {
        const ret = arg0.getTime();
        return ret;
    };
    imports.wbg.__wbg_get_27b4bcbec57323ca = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.get(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_get_59c6316d15f9f1d0 = function(arg0, arg1) {
        const ret = arg0[arg1 >>> 0];
        return ret;
    };
    imports.wbg.__wbg_getdone_8d12e2c5bfa23fbd = function(arg0) {
        const ret = arg0.done;
        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;
    };
    imports.wbg.__wbg_getvalue_8d746ccec318477b = function(arg0) {
        const ret = arg0.value;
        return ret;
    };
    imports.wbg.__wbg_getwithrefkey_6550b2c093d2eb18 = function(arg0, arg1) {
        const ret = arg0[arg1];
        return ret;
    };
    imports.wbg.__wbg_group_new = function(arg0) {
        const ret = Group.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_groupaction_new = function(arg0) {
        const ret = GroupAction.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_has_85abdd8aeb8edebf = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.has(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_headers_177bc880a5823968 = function(arg0) {
        const ret = arg0.headers;
        return ret;
    };
    imports.wbg.__wbg_identifier_new = function(arg0) {
        const ret = Identifier.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identity_new = function(arg0) {
        const ret = Identity.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitybalanceandrevision_new = function(arg0) {
        const ret = IdentityBalanceAndRevision.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitycontractkeys_new = function(arg0) {
        const ret = IdentityContractKeys.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitycreatefromaddressesresult_new = function(arg0) {
        const ret = IdentityCreateFromAddressesResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitycredittransferresult_new = function(arg0) {
        const ret = IdentityCreditTransferResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitygroupinfo_new = function(arg0) {
        const ret = IdentityGroupInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitypublickey_new = function(arg0) {
        const ret = IdentityPublicKey.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitypublickeyincreation_new = function(arg0) {
        const ret = IdentityPublicKeyInCreation.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitytokeninfo_new = function(arg0) {
        const ret = IdentityTokenInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitytopupfromaddressesresult_new = function(arg0) {
        const ret = IdentityTopUpFromAddressesResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_identitytransfertoaddressesresult_new = function(arg0) {
        const ret = IdentityTransferToAddressesResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_instanceof_ArrayBuffer_59339a3a6f0c10ea = function(arg0) {
        let result;
        try {
            result = arg0 instanceof ArrayBuffer;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Error_1e51a63e1736444c = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Error;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Map_dd89a82d76d1b25f = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Map;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Response_0ab386c6818f788a = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Response;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Uint8Array_91f3c5adee7e6672 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Uint8Array;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_isArray_55c23353d58297fd = function(arg0) {
        const ret = Array.isArray(arg0);
        return ret;
    };
    imports.wbg.__wbg_isArray_bc2498eba6fcb71f = function(arg0) {
        const ret = Array.isArray(arg0);
        return ret;
    };
    imports.wbg.__wbg_isSafeInteger_6091d6e3ee1b65fd = function(arg0) {
        const ret = Number.isSafeInteger(arg0);
        return ret;
    };
    imports.wbg.__wbg_iterator_96378c3c9a17347c = function() {
        const ret = Symbol.iterator;
        return ret;
    };
    imports.wbg.__wbg_keypair_new = function(arg0) {
        const ret = KeyPair.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_keys_7eff209f4f3c9f17 = function(arg0) {
        const ret = Object.keys(arg0);
        return ret;
    };
    imports.wbg.__wbg_length_246fa1f85a0dea5b = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_length_904c0910ed998bf3 = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_log_0cc1b7768397bcfe = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.log(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_log_cb9e190acc5753fb = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.log(getStringFromWasm0(arg0, arg1));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_mark_7438147ce31e9d4b = function(arg0, arg1) {
        performance.mark(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbg_measure_fb7825c11612c823 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
        let deferred0_0;
        let deferred0_1;
        let deferred1_0;
        let deferred1_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            deferred1_0 = arg2;
            deferred1_1 = arg3;
            performance.measure(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }, arguments) };
    imports.wbg.__wbg_message_86bd7dcf158b1dda = function(arg0) {
        const ret = arg0.message;
        return ret;
    };
    imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    };
    imports.wbg.__wbg_new0_85cc856927102294 = function() {
        const ret = new Date();
        return ret;
    };
    imports.wbg.__wbg_new_12588505388d0897 = function() { return handleError(function () {
        const ret = new Headers();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_new_1930cbb8d9ffc31b = function() {
        const ret = new Object();
        return ret;
    };
    imports.wbg.__wbg_new_56407f99198feff7 = function() {
        const ret = new Map();
        return ret;
    };
    imports.wbg.__wbg_new_6a8b180049d9484e = function() { return handleError(function () {
        const ret = new AbortController();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return ret;
    };
    imports.wbg.__wbg_new_9190433fb67ed635 = function(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    };
    imports.wbg.__wbg_new_97ddeb994a38bb69 = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_new_d5e3800b120e37e1 = function(arg0, arg1) {
        try {
            var state0 = {a: arg0, b: arg1};
            var cb0 = (arg0, arg1) => {
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_2496(a, state0.b, arg0, arg1);
                } finally {
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally {
            state0.a = state0.b = 0;
        }
    };
    imports.wbg.__wbg_new_e969dc3f68d25093 = function() {
        const ret = new Array();
        return ret;
    };
    imports.wbg.__wbg_newfromslice_d0d56929c6d9c842 = function(arg0, arg1) {
        const ret = new Uint8Array(getArrayU8FromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_newnoargs_a81330f6e05d8aca = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_9aade108cd45cf37 = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithlength_ed0ee6c1edca86fc = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithstrandinit_e8e22e9851f3c2fe = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = new Request(getStringFromWasm0(arg0, arg1), arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_next_2e6b37020ac5fe58 = function() { return handleError(function (arg0) {
        const ret = arg0.next();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_next_3de8f2669431a3ff = function(arg0) {
        const ret = arg0.next;
        return ret;
    };
    imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {
        const ret = arg0.node;
        return ret;
    };
    imports.wbg.__wbg_now_e3057dd824ca0191 = function() {
        const ret = Date.now();
        return ret;
    };
    imports.wbg.__wbg_pathelement_new = function(arg0) {
        const ret = PathElement.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_platformaddress_new = function(arg0) {
        const ret = PlatformAddress.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_platformaddressinfo_new = function(arg0) {
        const ret = PlatformAddressInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_prefundedspecializedbalance_new = function(arg0) {
        const ret = PrefundedSpecializedBalance.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {
        const ret = arg0.process;
        return ret;
    };
    imports.wbg.__wbg_proofmetadataresponse_new = function(arg0) {
        const ret = ProofMetadataResponse.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_protocolversionupgradestate_new = function(arg0) {
        const ret = ProtocolVersionUpgradeState.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_protocolversionupgradevotestatus_new = function(arg0) {
        const ret = ProtocolVersionUpgradeVoteStatus.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_prototypesetcall_c5f74efd31aea86b = function(arg0, arg1, arg2) {
        Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), arg2);
    };
    imports.wbg.__wbg_push_cd3ac7d5b094565d = function(arg0, arg1) {
        const ret = arg0.push(arg1);
        return ret;
    };
    imports.wbg.__wbg_queueMicrotask_bcc6e26d899696db = function(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    };
    imports.wbg.__wbg_queueMicrotask_f24a794d09c42640 = function(arg0) {
        queueMicrotask(arg0);
    };
    imports.wbg.__wbg_quoruminfo_new = function(arg0) {
        const ret = QuorumInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() { return handleError(function (arg0, arg1) {
        arg0.randomFillSync(arg1);
    }, arguments) };
    imports.wbg.__wbg_read_dc3d89b58ce2ae65 = function(arg0) {
        const ret = arg0.read();
        return ret;
    };
    imports.wbg.__wbg_registerdpnsnameresult_new = function(arg0) {
        const ret = RegisterDpnsNameResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_releaseLock_fbec365467db2e6c = function(arg0) {
        arg0.releaseLock();
    };
    imports.wbg.__wbg_require_60cc747a6bc5215a = function() { return handleError(function () {
        const ret = module.require;
        return ret;
    }, arguments) };
    imports.wbg.__wbg_resolve_5775c0ef9222f556 = function(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    };
    imports.wbg.__wbg_resourcevote_new = function(arg0) {
        const ret = ResourceVote.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_respond_0003f7c68aa35ef6 = function() { return handleError(function (arg0, arg1) {
        arg0.respond(arg1 >>> 0);
    }, arguments) };
    imports.wbg.__wbg_rewarddistributionmoment_new = function(arg0) {
        const ret = RewardDistributionMoment.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_setTimeout_4ec014681668a581 = function(arg0, arg1) {
        const ret = setTimeout(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbg_setTimeout_929c97a7c0f23d36 = function(arg0, arg1) {
        const ret = setTimeout(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbg_setTimeout_db2dbaeefb6f39c7 = function() { return handleError(function (arg0, arg1) {
        const ret = setTimeout(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_set_1d5fe1e3f51a48d8 = function(arg0, arg1, arg2) {
        arg0.set(getArrayU8FromWasm0(arg1, arg2));
    };
    imports.wbg.__wbg_set_2df374478acad331 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        arg0.set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments) };
    imports.wbg.__wbg_set_31197016f65a6a19 = function(arg0, arg1, arg2) {
        const ret = arg0.set(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_set_3807d5f0bfc24aa7 = function(arg0, arg1, arg2) {
        arg0[arg1] = arg2;
    };
    imports.wbg.__wbg_set_b33e7a98099eed58 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = Reflect.set(arg0, arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_set_d636a0463acf1dbc = function(arg0, arg1, arg2) {
        arg0[arg1 >>> 0] = arg2;
    };
    imports.wbg.__wbg_setbody_e324371c31597f2a = function(arg0, arg1) {
        arg0.body = arg1;
    };
    imports.wbg.__wbg_setcache_7c95e3469a5bfb76 = function(arg0, arg1) {
        arg0.cache = __wbindgen_enum_RequestCache[arg1];
    };
    imports.wbg.__wbg_setcredentials_55a9317ed2777533 = function(arg0, arg1) {
        arg0.credentials = __wbindgen_enum_RequestCredentials[arg1];
    };
    imports.wbg.__wbg_setheaders_ac0b1e4890a949cd = function(arg0, arg1) {
        arg0.headers = arg1;
    };
    imports.wbg.__wbg_setintegrity_b99a69a0174d6d2d = function(arg0, arg1, arg2) {
        arg0.integrity = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setmethod_9ce6e95af1ae0eaf = function(arg0, arg1, arg2) {
        arg0.method = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setmode_b89d1784e7e7f118 = function(arg0, arg1) {
        arg0.mode = __wbindgen_enum_RequestMode[arg1];
    };
    imports.wbg.__wbg_setredirect_4017ceebe5aecf8c = function(arg0, arg1) {
        arg0.redirect = __wbindgen_enum_RequestRedirect[arg1];
    };
    imports.wbg.__wbg_setreferrer_4625041984f4c279 = function(arg0, arg1, arg2) {
        arg0.referrer = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setreferrerpolicy_16cc29e0e528b435 = function(arg0, arg1) {
        arg0.referrerPolicy = __wbindgen_enum_ReferrerPolicy[arg1];
    };
    imports.wbg.__wbg_setsignal_e663c6d962763cd5 = function(arg0, arg1) {
        arg0.signal = arg1;
    };
    imports.wbg.__wbg_signal_bdb003fe19e53a13 = function(arg0) {
        const ret = arg0.signal;
        return ret;
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = arg1.stack;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_statetransitionresult_new = function(arg0) {
        const ret = StateTransitionResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_1f13249cc3acc96d = function() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_df7ae94b1e0ed6a3 = function() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_6265471db3b3c228 = function() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_16fb482f8ec52863 = function() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_status_31874648c8651949 = function(arg0) {
        const ret = arg0.status;
        return ret;
    };
    imports.wbg.__wbg_statusresponse_new = function(arg0) {
        const ret = StatusResponse.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_stringify_1f41b6198e0932e0 = function() { return handleError(function (arg0) {
        const ret = JSON.stringify(arg0);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_subarray_a219824899e59712 = function(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_text_42c080764c927da6 = function() { return handleError(function (arg0) {
        const ret = arg0.text();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_then_8d2fcccde5380a03 = function(arg0, arg1, arg2) {
        const ret = arg0.then(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_then_9cc266be2bf537b6 = function(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    };
    imports.wbg.__wbg_timebaseddistribution_new = function(arg0) {
        const ret = TimeBasedDistribution.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_toString_1144ec2f872e8cf3 = function(arg0) {
        const ret = arg0.toString();
        return ret;
    };
    imports.wbg.__wbg_toString_1588a16751ba3f70 = function(arg0) {
        const ret = arg0.toString();
        return ret;
    };
    imports.wbg.__wbg_toString_22c84ec5b4e33ea4 = function(arg0, arg1, arg2) {
        const ret = arg1.toString(arg2);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_toString_349e2a4aa036ef9c = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.toString(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_toString_83737cbd5ac9f7a7 = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.toString(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_tokenburnresult_new = function(arg0) {
        const ret = TokenBurnResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenburntransition_new = function(arg0) {
        const ret = TokenBurnTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenclaimresult_new = function(arg0) {
        const ret = TokenClaimResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenclaimtransition_new = function(arg0) {
        const ret = TokenClaimTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenconfigupdatetransition_new = function(arg0) {
        const ret = TokenConfigUpdateTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenconfiguration_new = function(arg0) {
        const ret = TokenConfiguration.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenconfigurationconvention_new = function(arg0) {
        const ret = TokenConfigurationConvention.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenconfigurationlocalization_new = function(arg0) {
        const ret = TokenConfigurationLocalization.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokencontractinfo_new = function(arg0) {
        const ret = TokenContractInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokendestroyfrozenfundstransition_new = function(arg0) {
        const ret = TokenDestroyFrozenFundsTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokendestroyfrozenresult_new = function(arg0) {
        const ret = TokenDestroyFrozenResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokendirectpurchaseresult_new = function(arg0) {
        const ret = TokenDirectPurchaseResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokendirectpurchasetransition_new = function(arg0) {
        const ret = TokenDirectPurchaseTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenemergencyactionresult_new = function(arg0) {
        const ret = TokenEmergencyActionResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenemergencyactiontransition_new = function(arg0) {
        const ret = TokenEmergencyActionTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenfreezeresult_new = function(arg0) {
        const ret = TokenFreezeResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenfreezetransition_new = function(arg0) {
        const ret = TokenFreezeTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenmintresult_new = function(arg0) {
        const ret = TokenMintResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenminttransition_new = function(arg0) {
        const ret = TokenMintTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenperpetualdistribution_new = function(arg0) {
        const ret = TokenPerpetualDistribution.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenpriceinfo_new = function(arg0) {
        const ret = TokenPriceInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenpricingschedule_new = function(arg0) {
        const ret = TokenPricingSchedule.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokensetpricefordirectpurchasetransition_new = function(arg0) {
        const ret = TokenSetPriceForDirectPurchaseTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokensetpriceresult_new = function(arg0) {
        const ret = TokenSetPriceResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenstatus_new = function(arg0) {
        const ret = TokenStatus.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokentotalsupply_new = function(arg0) {
        const ret = TokenTotalSupply.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokentrademode_new = function(arg0) {
        const ret = TokenTradeMode.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokentransferresult_new = function(arg0) {
        const ret = TokenTransferResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokentransfertransition_new = function(arg0) {
        const ret = TokenTransferTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokentransition_new = function(arg0) {
        const ret = TokenTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenunfreezeresult_new = function(arg0) {
        const ret = TokenUnfreezeResult.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_tokenunfreezetransition_new = function(arg0) {
        const ret = TokenUnFreezeTransition.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_url_d5273b9e10503471 = function(arg0, arg1) {
        const ret = arg1.url;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_value_09d0b4eaab48b91d = function(arg0) {
        const ret = arg0.value;
        return ret;
    };
    imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {
        const ret = arg0.versions;
        return ret;
    };
    imports.wbg.__wbg_view_d36d28552eb70661 = function(arg0) {
        const ret = arg0.view;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_votepoll_new = function(arg0) {
        const ret = VotePoll.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_votepollsbyenddateentry_new = function(arg0) {
        const ret = VotePollsByEndDateEntry.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmdpperror_new = function(arg0) {
        const ret = WasmDppError.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmsdkerror_new = function(arg0) {
        const ret = WasmSdkError.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wbindgenbigintgetasi64_7637cb1a7fb9a81e = function(arg0, arg1) {
        const v = arg1;
        const ret = typeof(v) === 'bigint' ? v : undefined;
        getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    };
    imports.wbg.__wbg_wbindgenbooleanget_59f830b1a70d2530 = function(arg0) {
        const v = arg0;
        const ret = typeof(v) === 'boolean' ? v : undefined;
        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;
    };
    imports.wbg.__wbg_wbindgencbdrop_a85ed476c6a370b9 = function(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    };
    imports.wbg.__wbg_wbindgendebugstring_bb652b1bc2061b6d = function(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_wbindgenin_192b210aa1c401e9 = function(arg0, arg1) {
        const ret = arg0 in arg1;
        return ret;
    };
    imports.wbg.__wbg_wbindgenisbigint_7d76a1ca6454e439 = function(arg0) {
        const ret = typeof(arg0) === 'bigint';
        return ret;
    };
    imports.wbg.__wbg_wbindgenisfunction_ea72b9d66a0e1705 = function(arg0) {
        const ret = typeof(arg0) === 'function';
        return ret;
    };
    imports.wbg.__wbg_wbindgenisnull_e1388bbe88158c3f = function(arg0) {
        const ret = arg0 === null;
        return ret;
    };
    imports.wbg.__wbg_wbindgenisobject_dfe064a121d87553 = function(arg0) {
        const val = arg0;
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbg_wbindgenisstring_4b74e4111ba029e6 = function(arg0) {
        const ret = typeof(arg0) === 'string';
        return ret;
    };
    imports.wbg.__wbg_wbindgenisundefined_71f08a6ade4354e7 = function(arg0) {
        const ret = arg0 === undefined;
        return ret;
    };
    imports.wbg.__wbg_wbindgenjsvaleq_f27272c0a890df7f = function(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    };
    imports.wbg.__wbg_wbindgenjsvallooseeq_9dd7bb4b95ac195c = function(arg0, arg1) {
        const ret = arg0 == arg1;
        return ret;
    };
    imports.wbg.__wbg_wbindgenlt_ab7deb4a53ea1252 = function(arg0, arg1) {
        const ret = arg0 < arg1;
        return ret;
    };
    imports.wbg.__wbg_wbindgenneg_32dfec7df2a39998 = function(arg0) {
        const ret = -arg0;
        return ret;
    };
    imports.wbg.__wbg_wbindgennumberget_d855f947247a3fbc = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'number' ? obj : undefined;
        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    };
    imports.wbg.__wbg_wbindgenstringget_43fe05afe34b0cb1 = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_wbindgenthrow_4c11a24fca429ccf = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {
        // Cast intrinsic for `Ref(String) -> Externref`.
        const ret = getStringFromWasm0(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_cast_24073220a434c5ab = function(arg0, arg1) {
        // Cast intrinsic for `Closure(Closure { dtor_idx: 3137, function: Function { arguments: [], shim_idx: 3138, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.
        const ret = makeMutClosure(arg0, arg1, 3137, __wbg_adapter_9);
        return ret;
    };
    imports.wbg.__wbindgen_cast_2ddd8a25ff58642a = function(arg0, arg1) {
        // Cast intrinsic for `I128 -> Externref`.
        const ret = (BigInt.asUintN(64, arg0) | (arg1 << BigInt(64)));
        return ret;
    };
    imports.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {
        // Cast intrinsic for `U64 -> Externref`.
        const ret = BigInt.asUintN(64, arg0);
        return ret;
    };
    imports.wbg.__wbindgen_cast_77bc3e92745e9a35 = function(arg0, arg1) {
        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();
        wasm.__wbindgen_free(arg0, arg1 * 1, 1);
        // Cast intrinsic for `Vector(U8) -> Externref`.
        const ret = v0;
        return ret;
    };
    imports.wbg.__wbindgen_cast_94c370e04c8d1163 = function(arg0, arg1) {
        // Cast intrinsic for `Closure(Closure { dtor_idx: 5575, function: Function { arguments: [], shim_idx: 5576, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.
        const ret = makeMutClosure(arg0, arg1, 5575, __wbg_adapter_16);
        return ret;
    };
    imports.wbg.__wbindgen_cast_9ae0607507abb057 = function(arg0) {
        // Cast intrinsic for `I64 -> Externref`.
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_cast_a42f11c9639541de = function(arg0, arg1) {
        // Cast intrinsic for `Closure(Closure { dtor_idx: 5546, function: Function { arguments: [], shim_idx: 5547, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.
        const ret = makeMutClosure(arg0, arg1, 5546, __wbg_adapter_27);
        return ret;
    };
    imports.wbg.__wbindgen_cast_bb82b35313aadd16 = function(arg0, arg1) {
        // Cast intrinsic for `Closure(Closure { dtor_idx: 5627, function: Function { arguments: [Externref], shim_idx: 5628, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.
        const ret = makeMutClosure(arg0, arg1, 5627, __wbg_adapter_6);
        return ret;
    };
    imports.wbg.__wbindgen_cast_cb9088102bce6b30 = function(arg0, arg1) {
        // Cast intrinsic for `Ref(Slice(U8)) -> NamedExternref("Uint8Array")`.
        const ret = getArrayU8FromWasm0(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {
        // Cast intrinsic for `F64 -> Externref`.
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_cast_e7b45dd881f38ce3 = function(arg0, arg1) {
        // Cast intrinsic for `U128 -> Externref`.
        const ret = (BigInt.asUintN(64, arg0) | (BigInt.asUintN(64, arg1) << BigInt(64)));
        return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
        ;
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {

}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint32ArrayMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

function initSync(module) {
    if (wasm !== undefined) return wasm;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module)
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')
        }
    }

    const imports = __wbg_get_imports();

    __wbg_init_memory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path)
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead')
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('wasm_sdk_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports);

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

export { initSync };
export default __wbg_init;
